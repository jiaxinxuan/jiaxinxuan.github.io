<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小咸菜</title>
  
  <subtitle>海到无边天做涯，山登绝顶我为峰。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiaxiaoxuan.top/"/>
  <updated>2018-01-02T15:02:41.973Z</updated>
  <id>http://jiaxiaoxuan.top/</id>
  
  <author>
    <name>二月江北</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-data-redis2</title>
    <link href="http://jiaxiaoxuan.top/2017/12/17/spring-data-redis2/"/>
    <id>http://jiaxiaoxuan.top/2017/12/17/spring-data-redis2/</id>
    <published>2017-12-17T06:53:43.000Z</published>
    <updated>2018-01-02T15:02:41.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>spring集成redis的RedisTemplate,也分别提供的对这些数据类型的操作。<br>主要有5大类：</p><ul><li>redisTemplate.opsForValue();//操作字符串</li><li>redisTemplate.opsForHash();//操作hash</li><li>redisTemplate.opsForList();//操作list</li><li>redisTemplate.opsForSet();//操作set</li><li>redisTemplate.opsForZSet();//操作有序set<h1 id="String类："><a href="#String类：" class="headerlink" title="String类："></a>String类：</h1></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1.redisTemplate.opsForValue().set(key,value)); //设置指定键的值</div><div class="line">2.redisTemplate.opsForValue().get(key)); //获取指定键的值。</div><div class="line">3.redisTemplate.opsForValue().get(key, start, end);//获取存储在键上的字符串的子字符串。</div><div class="line">4.redisTemplate.opsForValue().getAndSet(key, value);//设置键的字符串值并返回其旧值。</div><div class="line">5.redisTemplate.opsForValue().getBit(key, offset);//返回在键处存储的字符串值中偏移处的位值。</div><div class="line">6.redisTemplate.opsForValue().multiGet(keys);//获取所有给定键的值</div><div class="line">7.redisTemplate.opsForValue().setBit(key, offset, value);//存储在键上的字符串值中设置或清除偏移处的位</div><div class="line">8.redisTemplate.opsForValue().set(K key, V value, long timeout, TimeUnit unit);//使用键和到期时间来设置值</div><div class="line">9.redisTemplate.opsForValue().setIfAbsent(key, value);//设置键的值，仅当键不存在时</div><div class="line">10.redisTemplate.opsForValue().set(K key, V value, long offset);//在指定偏移处开始的键处覆盖字符串的一部分</div><div class="line">11.redisTemplate.opsForValue().size(key));//获取存储在键中的值的长度</div><div class="line">12.redisTemplate.opsForValue().multiGet(Collection keys);//为多个键分别设置它们的值</div><div class="line">13.redisTemplate.opsForValue().multiSetIfAbsent(Map m);// 为多个键分别设置它们的值，仅当键不存在时</div></pre></td></tr></table></figure><h1 id="Hash类"><a href="#Hash类" class="headerlink" title="Hash类:"></a>Hash类:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1.redisTemplate.opsForHash().delete(H key, Object... hashKeys);//删除一个或多个哈希字段。</div><div class="line">2.redisTemplate.opsForHash().hasKey(key, hashKey)；//判断是否存在散列字段。</div><div class="line">3.redisTemplate.opsForHash().get(key, hashKey)；//     获取存储在指定键的哈希字段的值。</div><div class="line">4.redisTemplate.opsForHash().entries(key);//返回map集合</div><div class="line">5.redisTemplate.opsForHash().increment(H key, HK hashKey, long delta);//获取存储在指定键的哈希中的所有字段和值</div><div class="line">6.redisTemplate.opsForHash().keys(key)；//返回map的key集合Set</div><div class="line">7.redisTemplate.opsForHash().size(key)； //获取散列中的字段数量</div><div class="line">8.redisTemplate.opsForHash().multiGet(H key, Collection hashKeys);//获取所有给定哈希字段的值</div><div class="line">9.redisTemplate.opsForHash().putAll(H key, Map m)；//为多个哈希字段分别设置它们的值</div><div class="line">10.redisTemplate.opsForHash().put(key, hashKey, value);//设置散列字段的字符串值</div><div class="line">11.redisTemplate.opsForHash().putIfAbsent(key, hashKey, value)；//仅当字段不存在时，才设置散列字段的值</div><div class="line">12.redisTemplate.opsForHash().values(key);// 获取哈希中的所有值</div></pre></td></tr></table></figure><h1 id="list类："><a href="#list类：" class="headerlink" title="list类："></a>list类：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.redisTemplate.opsForList().leftPush(key, value);//从左向右存压栈</div><div class="line">2.redisTemplate.opsForList().rightPush(key, value);//从右向左存压栈</div><div class="line">3.redisTemplate.opsForList().size(key);//获取大小</div><div class="line">4.redisTemplate.opsForList().range(key, start, end);//范围检索,根据下标，返回[start,end]的List</div><div class="line">5.redisTemplate.opsForList().remove(key, i, value);//移除key中值为value的i个,返回删除的个数；如果没有这个元素则返回0</div><div class="line">6.redisTemplate.opsForList().index(key, index);//检索</div><div class="line">7.redisTemplate.opsForList().set(key, index, value);//赋值.给指定位置的元素赋值，和String的set可不一样。</div><div class="line">8.redisTemplate.opsForList().trim(key, start, end);//裁剪,void,删除除了[start,end]以外的所有元素  </div><div class="line">9.redisTemplate.opsForList().rightPopAndLeftPush(String sourceKey, String destinationKey);//将源key的队列的右边的一个值删除，然后塞入目标key的队列的左边，返回这个值</div></pre></td></tr></table></figure><h1 id="set类："><a href="#set类：" class="headerlink" title="set类："></a>set类：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.redisTemplate.opsForSet().add(key, value); ;//如果不存在这个字符串，将字符串存入set集合，返回存入元素的个数；如果存在这个字符串就不操作，返回0；</div><div class="line">2.redisTemplate.opsForSet().members(key);//列出key的所有set集合</div><div class="line">3.redisTemplate.opsForSet().randomMember(key);//随机取key的一个set元素</div><div class="line">4.redisTemplate.opsForSet().distinctRandomMembers(key,n);//随机取N次key的元素，组成一个set集合，不可以重复取出</div><div class="line">5.redisTemplate.opsForSet().size(key);//返回set长度</div><div class="line">6.redisTemplate.opsForSet().difference(key, otherkey);//比较key与otherKey的set集合，取出与otherKey的set集合不一样的set集合</div><div class="line">7.redisTemplate.opsForSet().intersect(key, otherkey);//比较key与otherKey的set集合，取出二者交集，返回set交集合</div><div class="line">8.redisTemplate.opsForSet().union(key, otherkey);////比较key与otherKey的set集合，取出二者并集，返回set并集合</div><div class="line">9.redisTemplate.opsForSet().unionAndStore(key, otherkey,destkey);////比较key与otherKey的set集合，取出二者并集，并存入destKey集合，返回destKey集合个数</div></pre></td></tr></table></figure><h1 id="zset："><a href="#zset：" class="headerlink" title="zset："></a>zset：</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;spring集成redis的RedisTemplate,也分别提供的对这些数据类型的操作。&lt;br&gt;主要有5大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="redis" scheme="http://jiaxiaoxuan.top/categories/redis/"/>
    
    
      <category term="spring" scheme="http://jiaxiaoxuan.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring-data-redis1</title>
    <link href="http://jiaxiaoxuan.top/2017/12/17/spring-data-redis1/"/>
    <id>http://jiaxiaoxuan.top/2017/12/17/spring-data-redis1/</id>
    <published>2017-12-17T06:52:03.000Z</published>
    <updated>2018-01-02T15:02:41.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>常常用到redis做缓存，每次在新项目用的时候，总是copy以前写过的代码，对其中的原理并不是很清楚，趁着最近有空研究一下，做点笔记以备忘。  </p><h1 id="redis的数据库的存储格式"><a href="#redis的数据库的存储格式" class="headerlink" title="redis的数据库的存储格式"></a>redis的数据库的存储格式</h1><p>redis支持的数据格式主要有以下几种：  </p><ul><li>String——字符串</li><li>Hash——字典</li><li>List——列表</li><li>Set——集合</li><li>Sorted Set(zset)——有序集合<br>关于这几种数据的解释请看   <a href="http://www.jb51.net/article/54774.htm" target="_blank" rel="noopener">链接</a>    </li></ul><h1 id="spring与redis的集成"><a href="#spring与redis的集成" class="headerlink" title="spring与redis的集成"></a>spring与redis的集成</h1><p>由于jedisclientAPI不好操作，spring对其进行了封装，在spring-data-redis包中提供了两种操作redis的封装类，一种是RedisTemplate和他的子类<br>StringRedisTemplate，这两个类的只有一个地方是不相同的，就是对数据的序列化方式，RedisTemplate对数据的序列化方式是使用JdkSerializationRedisSerializer这个类。下面这段代码会在获取到redis链接之前执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public void afterPropertiesSet() &#123;</div><div class="line"></div><div class="line">super.afterPropertiesSet();</div><div class="line"></div><div class="line">boolean defaultUsed = false;</div><div class="line"></div><div class="line">if (defaultSerializer == null) &#123;</div><div class="line"></div><div class="line">defaultSerializer = new JdkSerializationRedisSerializer(</div><div class="line">classLoader != null ? classLoader : this.getClass().getClassLoader());</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (enableDefaultSerializer) &#123;</div><div class="line"></div><div class="line">if (keySerializer == null) &#123;</div><div class="line">keySerializer = defaultSerializer;</div><div class="line">defaultUsed = true;</div><div class="line">&#125;</div><div class="line">if (valueSerializer == null) &#123;</div><div class="line">valueSerializer = defaultSerializer;</div><div class="line">defaultUsed = true;</div><div class="line">&#125;</div><div class="line">if (hashKeySerializer == null) &#123;</div><div class="line">hashKeySerializer = defaultSerializer;</div><div class="line">defaultUsed = true;</div><div class="line">&#125;</div><div class="line">if (hashValueSerializer == null) &#123;</div><div class="line">hashValueSerializer = defaultSerializer;</div><div class="line">defaultUsed = true;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (enableDefaultSerializer &amp;&amp; defaultUsed) &#123;</div><div class="line">Assert.notNull(defaultSerializer, &quot;default serializer null and not all serializers initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (scriptExecutor == null) &#123;</div><div class="line">this.scriptExecutor = new DefaultScriptExecutor&lt;&gt;(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">initialized = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>StringRedisTemplate作为子类，在构造方法里面就指定StringRedisSerializer类来做序列化，代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public StringRedisTemplate() &#123;</div><div class="line">RedisSerializer&lt;String&gt; stringSerializer = new StringRedisSerializer();</div><div class="line">setKeySerializer(stringSerializer);</div><div class="line">setValueSerializer(stringSerializer);</div><div class="line">setHashKeySerializer(stringSerializer);</div><div class="line">setHashValueSerializer(stringSerializer);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两者有什么不同之处呢，StringRedisSerializer会将数据数列化成字符串，是在redis客户端中是可读的，JdkSerializationRedisSerializer类会将数据序列化为字节数据是不可读的。</p><p>请看下列代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * redis 单机模式测试</div><div class="line">   */</div><div class="line">  private static void redisStandaloneTest()&#123;</div><div class="line">      //以单机模式创建redis链接工厂</div><div class="line">      RedisStandaloneConfiguration config=new RedisStandaloneConfiguration();</div><div class="line">      config.setPassword(RedisPassword.of(&quot;123456&quot;));</div><div class="line">      RedisConnectionFactory redisConnectionFactory=new JedisConnectionFactory(config);</div><div class="line"></div><div class="line">      //创建redis的spring封装类RedisTemplate</div><div class="line">      RedisTemplate redisTemplate=new RedisTemplate();</div><div class="line">      redisTemplate.setConnectionFactory(redisConnectionFactory);</div><div class="line">      redisTemplate.setKeySerializer(new StringRedisSerializer());</div><div class="line">      //必须执行初始化操作，否则不会设置序列化，就无法存取值</div><div class="line">      redisTemplate.afterPropertiesSet();</div><div class="line">      //存取值，并打印</div><div class="line">      redisTemplate.opsForValue().set(&quot;jia&quot;,&quot;xinxuain&quot;);</div><div class="line">      System.out.println(redisTemplate.opsForValue().get(&quot;jia&quot;));</div><div class="line"></div><div class="line">      //创建redis的spring封装类StringRedisTemplate</div><div class="line">      StringRedisTemplate stringRedisTemplate=new StringRedisTemplate(redisConnectionFactory);</div><div class="line">      stringRedisTemplate.opsForValue().set(&quot;xin&quot;,&quot;xuan&quot;);</div><div class="line">      System.out.println(stringRedisTemplate.opsForValue().get(&quot;xin&quot;));</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>在redis中的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; keys *</div><div class="line">1) &quot;test&quot;</div><div class="line">2) &quot;jia&quot;</div><div class="line">3) &quot;foo&quot;</div><div class="line">4) &quot;\xac\xed\x00\x05t\x00\x03jia&quot;</div><div class="line">127.0.0.1:6379&gt; get jia</div><div class="line">&quot;\xac\xed\x00\x05t\x00\bxinxuain&quot;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure><p>程序运行后的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/home/jia/java/bin/java ...</div><div class="line">xinxuain</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure><p>对于RedisTemplate的对象，设置其key值使用StringRedisSerializer序列化，其value使用默认的JdkSerializationRedisSerializer序列化。在存取同一个值的时候，如果是不同系统，一定要约定序列化的方式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>spring在操作redis的时候，给提供的这两个封装类，stringRedisTemplate基本上就可以满足大部分需求了。RedisTemplate提供了更为灵活的配置。<br>在学习的过程中，遇到一个版本兼容的问题，一开始我使用的是jedis2.9版本，spring使用的是4.3版本，这时候sping-data-jedis的版本是2.0.2的。最新版本的dedis和spring-data-redis是支持Java8的，其中Java8里面有个重要的lambda表达式，而spring4.3是不支持Java8的。这样就出现bug了，后来把spring提升到5.0版本才好。<br>顺便再提一句，不知道什么时候，sprin-data-redis在创建RedisTemplate的时候，做了修改，反正就是对集群哨兵单机这三种情况，提供了配置文件的封装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;常常用到redis做缓存，每次在新项目用的时候，总是copy以前写过的代码，对其中的原理并不是很清楚，趁着最近有空研究一下，做点笔记以备忘。
      
    
    </summary>
    
      <category term="redis" scheme="http://jiaxiaoxuan.top/categories/redis/"/>
    
    
      <category term="spring" scheme="http://jiaxiaoxuan.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>使用py抓取b站影评</title>
    <link href="http://jiaxiaoxuan.top/2017/11/24/%E4%BD%BF%E7%94%A8py%E6%8A%93%E5%8F%96b%E7%AB%99%E5%BD%B1%E8%AF%84/"/>
    <id>http://jiaxiaoxuan.top/2017/11/24/使用py抓取b站影评/</id>
    <published>2017-11-24T13:36:18.000Z</published>
    <updated>2018-01-02T15:02:41.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>上周末看了一部甲方乙方的电影，看完以后发现下面的影评挺多的，就想分析一下，这个电影大家评论最多的关键词是什么。既然这么想了那就下手呗，f12查看b站评论的请求接口，一不小心被我找到了，，，，，，<br>那就请求这个接口呗，借用结巴分词和WordCloud词语，就是我想要的结果了。<br><a id="more"></a></p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p>当然话不多说，请看效果图<br><img src="/images/blibli.png" alt=""></p><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">&quot;&quot;&quot;</div><div class="line">简单Python爬虫，抓取b站某个电影的评论数据，生成词云</div><div class="line">&quot;&quot;&quot;</div><div class="line"></div><div class="line">import urllib.parse</div><div class="line">import urllib.request</div><div class="line">import urllib</div><div class="line">from wordcloud import WordCloud</div><div class="line">import json</div><div class="line">import jieba</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line"></div><div class="line"># get请求</div><div class="line"></div><div class="line"></div><div class="line">def login_get(url):</div><div class="line">    response = urllib.request.urlopen(url)</div><div class="line">    text = response.read()</div><div class="line">    return text.decode(&apos;UTF-8&apos;)</div><div class="line"># post 请求</div><div class="line"></div><div class="line"></div><div class="line">def login_post(url, header, data):</div><div class="line">    data = urllib.parse.urlencode(data)</div><div class="line">    req = urllib.request.Request(url, data=data, headers=header)</div><div class="line">    response = urllib.request.urlopen(req, timeout=5)</div><div class="line">    return response.read().decode(&apos;UTF-8&apos;)</div><div class="line">#   写入文件</div><div class="line"></div><div class="line"></div><div class="line">def output_file(content, outPutFile):</div><div class="line">    outfile = open(file=outPutFile, mode=&quot;a&quot;, encoding=&quot;UTF-8&quot;)  # 以写的方式打开该文件</div><div class="line">    outfile.write(content)</div><div class="line">    outfile.flush()</div><div class="line"></div><div class="line"># 结巴分词</div><div class="line"></div><div class="line"></div><div class="line">def sliptsentence(inputFile, outPutFile):</div><div class="line">    try:</div><div class="line">        # 以读的方式打开该文件</div><div class="line">        inFile=open(file=inputFile, mode=&quot;r&quot;,encoding=&quot;UTF-8&quot;)</div><div class="line">        # 以写的方式打开该文件</div><div class="line">        outFile=open(file=outPutFile,mode=&quot;w&quot;,encoding=&quot;UTF-8&quot;)</div><div class="line">        # 循环遍历打开的文件，取出其中每行，并对每行进行分词</div><div class="line">        for eachLine in inFile:</div><div class="line">            # 此句取某一行的数据，并且去除两端的空格，并以utf-8的形式编码</div><div class="line">            line=eachLine.strip().encode(&quot;UTF-8&quot;,&quot;ingore&quot;)</div><div class="line">            wordList=jieba.cut(line);</div><div class="line">            # 将当前行得到的分词数据，写入到输出文件中去</div><div class="line">            outstr=&apos;&apos;</div><div class="line">            for word in wordList:</div><div class="line">                outstr+=word</div><div class="line">                outstr+=&quot;/&quot;</div><div class="line">            outFile.write(outstr.strip()+&quot;\n&quot;)</div><div class="line">    except Exception as ex:</div><div class="line">        print(&quot;文件处理出错&quot;,ex)</div><div class="line">    finally:</div><div class="line">       inFile.close()</div><div class="line">       outFile.close()</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    for i in range(1,38):</div><div class="line">        url=&apos;http://api.bilibili.com/x/v2/reply?jsonp=jsonp&amp;pn=&apos;+str(i)+&apos;&amp;type=1&amp;oid=2651396&amp;sort=0&amp;_=1510978290823&apos;</div><div class="line">        result = login_get(url)</div><div class="line">        jsons = json.loads(result, encoding=&apos;UTF-8&apos;)</div><div class="line">        replies = jsons[&apos;data&apos;][&apos;replies&apos;]</div><div class="line">        message = &apos;&apos;</div><div class="line">        for user in replies:</div><div class="line">            content=user[&apos;content&apos;]</div><div class="line">            message += content[&apos;message&apos;]+&apos;\n&apos;</div><div class="line">            print(content[&apos;message&apos;])</div><div class="line">        output_file(message,&apos;/home/jia/content.log&apos;)</div><div class="line">    sliptsentence(&apos;/home/jia/content.log&apos;, &apos;/home/jia/jieba.json&apos;)</div><div class="line">    f = open(u&apos;/home/jia/jieba.json&apos;, &apos;r&apos;, encoding=&apos;UTF-8&apos;).read()</div><div class="line">    wordcloud = WordCloud(background_color=&quot;white&quot;, width=1000, height=860,</div><div class="line">                          margin=2, font_path=&apos;/home/jia/bole.ttf&apos;).generate(f)</div><div class="line">    plt.imshow(wordcloud)</div><div class="line">    plt.axis(&quot;off&quot;)</div><div class="line">    plt.show()</div><div class="line">    wordcloud.to_file(&apos;test.png&apos;)</div></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>请求评论的接口，请注意计算分页的大小。</li><li>使用WocrdCloud制作词语时，Linux系统一定要指定中文字体，不然人家不认识中文。Windows系统好像本来就是中文字体。。。</li><li>别的就没什么要注意的了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;上周末看了一部甲方乙方的电影，看完以后发现下面的影评挺多的，就想分析一下，这个电影大家评论最多的关键词是什么。既然这么想了那就下手呗，f12查看b站评论的请求接口，一不小心被我找到了，，，，，，&lt;br&gt;那就请求这个接口呗，借用结巴分词和WordCloud词语，就是我想要的结果了。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://jiaxiaoxuan.top/categories/python/"/>
    
    
      <category term="python" scheme="http://jiaxiaoxuan.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>linux日志查询技巧</title>
    <link href="http://jiaxiaoxuan.top/2017/11/24/linux%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E6%8A%80%E5%B7%A7/"/>
    <id>http://jiaxiaoxuan.top/2017/11/24/linux日志查询技巧/</id>
    <published>2017-11-24T13:26:28.000Z</published>
    <updated>2018-01-02T15:02:41.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统日志查询常用命令"><a href="#Linux系统日志查询常用命令" class="headerlink" title="Linux系统日志查询常用命令"></a>Linux系统日志查询常用命令</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>当线上程序出现bug的时候，往往都是由于某种小的原因导致的，这个时候bug不能适时地显示，只能通过日志文件来定位bug出现的位置。<br>上周程序出现bug个的时候，领导盯着我查，感觉当时好气，自己怎么不提前学习一下这些命令呢，现在总结以下，以备来日不时之需。<br>日志查询命令主要有以下几种:</p><ul><li>cat</li><li>tail</li><li>head</li><li>sed</li><li>more</li><li>less</li><li>grep<br>以后遇见新学习的命令，再添加。以下是详细总结。</li></ul><a id="more"></a><h1 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">参数：</div><div class="line">-n 或 --number 由 1 开始对所有输出的行数编号</div><div class="line">-b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号</div><div class="line">-s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行</div><div class="line">-v 或 --show-nonprinting</div></pre></td></tr></table></figure><p>三总用法</p><ol><li>创建新文件<br>cat test，此命令只能创建新文件，不能够编辑已有文件。</li><li>连接文件并打印到标准输出设备上<br>当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。<br>cat test.log | more</li><li>合并文件<br>把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat -n textfile1 &gt; textfile2</div></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</div></pre></td></tr></table></figure><p>把test.txt文件扔进垃圾箱，赋空值test.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /dev/null &gt; /etc/test.txt</div></pre></td></tr></table></figure><h1 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h1><p>tail命令用于显示文件中末尾的内容（默认显示最后10行内容）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tail语法格式：</div><div class="line">    tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]</div><div class="line">或者</div><div class="line">    tail [ -r ] [ -n Number ] [ File ]</div></pre></td></tr></table></figure></p><p>使用说明：</p><ul><li>tail 命令从指定点开始将 File 参数指定的文件写到标准输出。如果没有指定文件，则会使用标准输入。</li><li>Number 变量指定将多少单元写入标准输出。 Number 变量的值可以是正的或负的整数。</li><li>如果值的前面有 +（加号），从文件开头指定的单元数开始将文件写到标准输出。</li><li>如果值的前面有 -（减号），则从文件末尾指定的单元数开始将文件写到标准输出。</li><li>如果值前面没有 +（加号）或 -（减号），那么从文件末尾指定的单元号开始读取文件。<br>主要参数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">-f  用于循环读取文件的内容，监视文件的增长,常用此命令监控日志。</div><div class="line"></div><div class="line">tail -f test.log</div><div class="line"></div><div class="line">-F 与-f类似，区别在于当将监视的文件删除重建后-F仍能监视该文件内容-f则不行，-F有重试的功能，会不断重试</div><div class="line"></div><div class="line">-c N 显示文件末尾N字节的内容</div><div class="line"></div><div class="line">tail -c 10 seo-test.log ,这样会显示文件最后十个英文字母</div><div class="line"></div><div class="line">-n  显示文件末尾n行内容</div><div class="line"></div><div class="line">tail -n 100 test.log,显示最后100行内容。</div><div class="line"></div><div class="line">-q  显示多文件的末尾内容时，不显示文件名</div><div class="line">-v  显示多文件的末尾内容时，显示文件名（此为tail的默认选项）</div><div class="line">-s N 与-f合用，表示休眠N秒后在读取文件内容（默认为1s）</div><div class="line"></div><div class="line">--pid=&lt;进程号PID&gt; 与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令</div></pre></td></tr></table></figure><h1 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h1><p>head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看文件的结尾。</p><p>使用说明：<br>用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。<br>常用参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-q   隐藏文件名</div><div class="line"></div><div class="line">-v   显示文件名</div><div class="line"></div><div class="line">以上两个命令多用于打开多文件的情况</div><div class="line"></div><div class="line">-c   &lt;字节&gt; 显示字节数</div><div class="line"></div><div class="line">-n   &lt;行数&gt; 显示的行数</div><div class="line"></div><div class="line">-z   像屏幕滚动输出所有内容</div></pre></td></tr></table></figure><h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><p>暂缺</p><h1 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h1><p>more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。</p><p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）可以用下列不同的方法对提示做出回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">按Space键：显示文本的下一屏内容。</div><div class="line">按Enier键：只显示文本的下一行内容。</div><div class="line">按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。</div><div class="line">按H键：显示帮助屏，该屏上有相关的帮助信息。</div><div class="line">按B键：显示上一屏内容。 按Q键：退出rnore命令。</div></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-&lt;数字&gt;：指定每屏显示的行数；</div><div class="line">-d：显示“[press space to continue,&apos;q&apos; to quit.]”和“[Press &apos;h&apos; for instructions]”；</div><div class="line">-c：不进行滚屏操作。每次刷新这个屏幕；</div><div class="line">-s：将多个空行压缩成一行显示；</div><div class="line">-u：禁止下划线；</div><div class="line">+&lt;数字&gt;：从指定数字的行开始显示。</div></pre></td></tr></table></figure><p><strong><em>实例</em></strong><br>显示文件file的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">more -dc file</div></pre></td></tr></table></figure><p>显示文件file的内容，每10行显示一次，而且在显示之前先清屏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">more -c -10 file</div></pre></td></tr></table></figure><h1 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h1><p><a href="http://blog.csdn.net/mxj588love/article/details/54313769" target="_blank" rel="noopener">http://blog.csdn.net/mxj588love/article/details/54313769</a><br>放一篇博文链接,我没怎么使用过。</p><h1 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h1><p>这个命令很强大啊！我也不敢随便总结，下面是一位大神总结的，我感觉比较全了。<br><a href="https://www.cnblogs.com/end/archive/2012/02/21/2360965.html" target="_blank" rel="noopener">https://www.cnblogs.com/end/archive/2012/02/21/2360965.html</a></p><h1 id="常用查询命令组合"><a href="#常用查询命令组合" class="headerlink" title="常用查询命令组合:"></a>常用查询命令组合:</h1><p>1.查询日志中含有某个关键字的信息</p><p>cat app.log | grep ‘error’</p><p>2.查询日志尾部最后10行的日志</p><p>tail  -n 10  app.log</p><p>3.查询10行之后的所有日志</p><p>tail -n +10 app.log</p><p>4.查询日志文件中的头10行日志</p><p>head -n 10  app.log</p><p>5.查询日志文件除了最后10行的其他所有日志</p><p>head -n -10  app.log</p><p>6.查询日志中含有某个关键字的信息,显示出行号(在1的基础上修改)</p><p>cat -n  app.log | grep ‘error’</p><p>7.显示102行,前10行和后10行的日志</p><p>cat -n app.log | tail -n+92 | head -n 20</p><p>8.根据日期时间段查询(前提日志总必须打印日期,先通过grep确定是否有该时间点)</p><p><strong><em>sed -n ‘/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p’  app.log</em></strong></p><p>9.使用more和less命令(分页查看,使用空格翻页)</p><p> cat -n app.log | grep “error” |more</p><p>10.把日志保存到文件</p><p>cat -n app.log | grep “error”  &gt; temp.txt</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux系统日志查询常用命令&quot;&gt;&lt;a href=&quot;#Linux系统日志查询常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux系统日志查询常用命令&quot;&gt;&lt;/a&gt;Linux系统日志查询常用命令&lt;/h1&gt;&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;当线上程序出现bug的时候，往往都是由于某种小的原因导致的，这个时候bug不能适时地显示，只能通过日志文件来定位bug出现的位置。&lt;br&gt;上周程序出现bug个的时候，领导盯着我查，感觉当时好气，自己怎么不提前学习一下这些命令呢，现在总结以下，以备来日不时之需。&lt;br&gt;日志查询命令主要有以下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cat&lt;/li&gt;
&lt;li&gt;tail&lt;/li&gt;
&lt;li&gt;head&lt;/li&gt;
&lt;li&gt;sed&lt;/li&gt;
&lt;li&gt;more&lt;/li&gt;
&lt;li&gt;less&lt;/li&gt;
&lt;li&gt;grep&lt;br&gt;以后遇见新学习的命令，再添加。以下是详细总结。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="http://jiaxiaoxuan.top/categories/linux/"/>
    
    
      <category term="linux" scheme="http://jiaxiaoxuan.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>elk+logback的简单日志收集-单机版</title>
    <link href="http://jiaxiaoxuan.top/2017/11/08/elk-logback%E7%9A%84%E7%AE%80%E5%8D%95%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86-%E5%8D%95%E6%9C%BA%E7%89%88/"/>
    <id>http://jiaxiaoxuan.top/2017/11/08/elk-logback的简单日志收集-单机版/</id>
    <published>2017-11-08T08:59:44.000Z</published>
    <updated>2018-01-02T15:02:41.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>微服务架构中，多个服务都是分离部署的，在实际的操作中，常常需要实时监测运行日志，或者查找日志记录，以确定程序bug的所在位置。服务的分离部署就增加了查找难度，必须登录多台主机打开多个终端查看日志。elk日志搜集系统能够很好的解决这个问题，网上教程已是相当的多，这里仅仅是贴合自己的实际开发来搭建的，只是为了更好的同时监测多台服务器的日志。本文只是单机搭建实验，准备最近在公司测试环境搭建一份。</p><a id="more"></a><h1 id="组件介绍与安装"><a href="#组件介绍与安装" class="headerlink" title="组件介绍与安装"></a>组件介绍与安装</h1><p>日志流行图：</p><p><img src="/images/elk/elk-1.png" alt=""></p><p>从左边看起，每一台webserver上都会部署一个logstash-agent,它的作用是用类似tailf的方式监听日志文件，然后把新添加的日志发送到redis队列里面，logstash-indexer负责从redis相应的队列里面取出日志，对日志进进行加工后输出到elasticsearch中，elasticsearch会根据要求对日志进行索引归集，最后用户可以通过kibana来查看和分析日志。</p><p>在ELK官网下载相应的压缩包</p><p><a href="https://www.elastic.co/downloads" target="_blank" rel="noopener">https://www.elastic.co/downloads</a></p><h2 id="logstash和logbach的结合"><a href="#logstash和logbach的结合" class="headerlink" title="logstash和logbach的结合"></a>logstash和logbach的结合</h2><p>公司里面使用的是logback日志，通过在maven中添加logback-redis-appender依赖来结合logstash,进行日志收集。步骤如下：</p><p>1、加入apender jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.cwbase&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;logback-redis-appender&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>2、配置logback.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">  &lt;property name=&quot;type.name&quot; value=&quot;&quot; /&gt;</div><div class="line">  &lt;appender name=&quot;TEST&quot; class=&quot;com.cwbase.logback.RedisAppender&quot;&gt;</div><div class="line">    &lt;source&gt;test-application&lt;/source&gt;</div><div class="line">    &lt;!--type 可定为项目类型--&gt;</div><div class="line">    &lt;type&gt;$&#123;type.name&#125;&lt;/type&gt;</div><div class="line">    &lt;!--redis ip--&gt;</div><div class="line">    &lt;host&gt;192.168.1.218&lt;/host&gt;</div><div class="line">    &lt;!--redis存放的key--&gt;</div><div class="line">    &lt;key&gt;logstash:redis&lt;/key&gt;</div><div class="line">    &lt;tags&gt;test-2&lt;/tags&gt;</div><div class="line">    &lt;mdc&gt;true&lt;/mdc&gt;</div><div class="line">    &lt;location&gt;true&lt;/location&gt;</div><div class="line">    &lt;callerStackIndex&gt;0&lt;/callerStackIndex&gt;</div><div class="line">    &lt;!--additionalField添加附加字段 用于head插件显示--&gt;</div><div class="line">    &lt;additionalField&gt;</div><div class="line">      &lt;key&gt;MyKey&lt;/key&gt;</div><div class="line">      &lt;value&gt;MyValue&lt;/value&gt;</div><div class="line">    &lt;/additionalField&gt;</div><div class="line">    &lt;additionalField&gt;</div><div class="line">      &lt;key&gt;MySecondKey&lt;/key&gt;</div><div class="line">      &lt;value&gt;MyOtherValue&lt;/value&gt;</div><div class="line">    &lt;/additionalField&gt;</div><div class="line">  &lt;/appender&gt;</div><div class="line">  &lt;!--日志输出--&gt;</div><div class="line">  &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</div><div class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</div><div class="line">      &lt;fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</div><div class="line">      &lt;!--日志回滚周期30天--&gt;</div><div class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</div><div class="line">    &lt;/rollingPolicy&gt;</div><div class="line">    &lt;!-- &lt;encoder&gt;</div><div class="line">       &lt;pattern&gt;%logger&#123;15&#125; - %message%n%xException&#123;5&#125;&lt;/pattern&gt;</div><div class="line">     &lt;/encoder&gt;--&gt;</div><div class="line">    &lt;encoder&gt;</div><div class="line">      &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-4relative [%thread] %-5level %logger&#123;35&#125; %caller&#123;3&#125; - %msg%n%xException&#123;5&#125;&lt;/pattern&gt;</div><div class="line">    &lt;/encoder&gt;</div><div class="line"></div><div class="line">  &lt;/appender&gt;</div><div class="line"></div><div class="line">  &lt;logger name=&quot;application&quot; level=&quot;DEBUG&quot; /&gt;</div><div class="line"></div><div class="line">  &lt;root level=&quot;DEBUG&quot;&gt;</div><div class="line">    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</div><div class="line">    &lt;appender-ref ref=&quot;TEST&quot; /&gt;</div><div class="line">  &lt;/root&gt;</div><div class="line"></div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure><h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><p>安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ wget http://download.redis.io/releases/redis-4.0.2.tar.gz</div><div class="line">$ tar xzf redis-4.0.2.tar.gz</div><div class="line">$ cd redis-4.0.2</div><div class="line">$ make</div></pre></td></tr></table></figure><p>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ src/redis-server</div></pre></td></tr></table></figure><p>链接测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ src/redis-cli</div><div class="line">redis&gt; set foo bar</div><div class="line">OK</div><div class="line">redis&gt; get foo</div><div class="line">&quot;bar&quot;</div></pre></td></tr></table></figure><p>后台启动脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!bin/bash</div><div class="line">nohup ./src/redis-server &gt; /data/logs/redis.log 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure><h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><p>配置logstash的时候，log4j或者其他方式的日志收集，可能需要在webserver上配置logstash-agent。logback的话按照上面的方式在maven依赖添加相关jar包就可以了。然后在日志server上配置logstash-indexer.<br><strong>在日志server上安装logstash-indexer</strong></p><p>1.解压 tar -zxvf logstash<em>**</em></p><p>2.检验安装是否成功 bin/logstash -e “input{stdin{}}output{stdout{}}”,然后在终端输入hello，看看有没有内容返回<br>3.编写logstash-indexer.conf文件，保存至conf目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">#输入日志</div><div class="line">input &#123;</div><div class="line">    redis &#123;</div><div class="line">    host =&gt; &quot;localhost&quot;#redis地址</div><div class="line">    data_type =&gt; &quot;list&quot;</div><div class="line">    key =&gt; &quot;logstash:redis:customer&quot;</div><div class="line">    type =&gt; &quot;redis-input&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">#过滤日志</div><div class="line">#filter &#123;</div><div class="line">#    grok &#123;</div><div class="line">#    match =&gt; &#123;</div><div class="line">#    &quot;message&quot; =&gt; &quot;%&#123;TIMESTAMP_ISO8601:date&#125; \[(?.+?)\] (?\w+)\s*(?     #  &#125;</div><div class="line">#&#125;</div><div class="line">#定义时间格式</div><div class="line">date &#123;</div><div class="line">    match =&gt; [&quot;timestamp&quot;, &quot;dd/MMM/YYYY:HH:mm:ss Z&quot;]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#输出日志</div><div class="line">output &#123;</div><div class="line">    if[type] == &quot;customer_service&quot; &#123;</div><div class="line">                    elasticsearch &#123;</div><div class="line">                        #embedded =&gt; false</div><div class="line">                        #protocol =&gt; &quot;http&quot;</div><div class="line">                        hosts =&gt; &quot;localhost:9200&quot;</div><div class="line">                        index =&gt; &quot;customer-%&#123;+YYYY.MM.dd&#125;&quot;</div><div class="line">                    &#125;</div><div class="line">    &#125;else if[type] == &quot;其他类型&quot; &#123;</div><div class="line"></div><div class="line">                    elasticsearch &#123;</div><div class="line">                    #embedded =&gt; false</div><div class="line">                    #protocol =&gt; &quot;http&quot;</div><div class="line">                    hosts =&gt; &quot;localhost:9200&quot;</div><div class="line">                    index =&gt; &quot;其他类型索引名字-%&#123;+YYYY.MM.dd&#125;&quot;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">    &#125;else &#123;</div><div class="line">                    //做其他处理</div><div class="line">    &#125;</div><div class="line">    stdout&#123; #输出到标准输出，可以去掉</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上配置，需要自行修改，方可使用。</p><p>启动logstash-indexer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ./bin/logstash -f conf/logstash-indexer.conf 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure><p>可以仿照redis的方式，写个启动脚本。</p><h2 id="elelasticsearch"><a href="#elelasticsearch" class="headerlink" title="elelasticsearch"></a>elelasticsearch</h2><p>1.解压tar -zxvf elasticsearch-2.3.1.tar.gz</p><p>2.修改安装目录下的配置文件config/elasticsearch.yml</p><p>把network.host字段给反注释掉，把地址改为0.0.0.0（官方并没明确说要去改这配置，默认配置应该就可以了，不过实测的时候发现如果不做这修改，elasticsearch访问不了）</p><p><img src="/images/elk/elk-3.png" alt=""></p><p>3.后台启动elasticsearch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ./bin/elasticsearch &gt;  &amp;</div></pre></td></tr></table></figure><h2 id="安装elasticsearch-head插件"><a href="#安装elasticsearch-head插件" class="headerlink" title="安装elasticsearch-head插件"></a>安装elasticsearch-head插件</h2><p>在使用该插件时，请实现安装好nodejs。<br>1.下载安装包<br>下载地址:<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a><br>2.解压elasticsearch-head 包<br>3.全局安装grunt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g grunt -cli --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure><p>4.在elasticsearch-head-master文件下的Gruntfile.js文件中增加server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">connect: &#123;</div><div class="line">    server: &#123;</div><div class="line">        options: &#123;</div><div class="line">            hostname: &apos;0.0.0.0&apos;,</div><div class="line">            port: 9100,</div><div class="line">            base: &apos;.&apos;,</div><div class="line">            keepalive: true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5.elasticsearch.yml 添加如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 是否支持跨域</div><div class="line">http.cors.enabled: true</div><div class="line"># *表示支持所有域名</div><div class="line">http.cors.allow-origin: &quot;*&quot;</div></pre></td></tr></table></figure><p>安装完成以后，要注意重启elasticsearch,以让修改后的配置文件生效。</p><p>6.运行grunt服务<br>进入elasticsearch-head-master文件夹运行grunt server命令<br><img src="/images/elk/elk-4.png" alt=""><br><img src="/images/elk/elk-2.png" alt=""></p><h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.解压tar -zxvf kibana<strong>*</strong></p><p>2.后台启动kibana nohup ./bin/kibana &amp;</p><p>这里没有特别去配置kibana要访问的elasticsearch地址，默认它会找本地的，如果需要，可以到conf/kibana.yml修改</p><h3 id="访问kibana主页"><a href="#访问kibana主页" class="headerlink" title="访问kibana主页"></a>访问kibana主页</h3><p>1.打开kibana主页<a href="http://your-kibana-ip:5601/" target="_blank" rel="noopener">http://your-kibana-ip:5601/</a></p><p>2.按照页面提示输入，并点击create<br><img src="/images/elk/elk-5.png" alt=""></p><h2 id="编写日志服务器启动脚本"><a href="#编写日志服务器启动脚本" class="headerlink" title="编写日志服务器启动脚本"></a>编写日志服务器启动脚本</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;微服务架构中，多个服务都是分离部署的，在实际的操作中，常常需要实时监测运行日志，或者查找日志记录，以确定程序bug的所在位置。服务的分离部署就增加了查找难度，必须登录多台主机打开多个终端查看日志。elk日志搜集系统能够很好的解决这个问题，网上教程已是相当的多，这里仅仅是贴合自己的实际开发来搭建的，只是为了更好的同时监测多台服务器的日志。本文只是单机搭建实验，准备最近在公司测试环境搭建一份。&lt;/p&gt;
    
    </summary>
    
      <category term="elk" scheme="http://jiaxiaoxuan.top/categories/elk/"/>
    
    
      <category term="elk" scheme="http://jiaxiaoxuan.top/tags/elk/"/>
    
  </entry>
  
  <entry>
    <title>POI之SXSSF导出图片</title>
    <link href="http://jiaxiaoxuan.top/2017/10/22/POI%E4%B9%8BSXSSF%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87/"/>
    <id>http://jiaxiaoxuan.top/2017/10/22/POI之SXSSF导出图片/</id>
    <published>2017-10-22T14:22:24.000Z</published>
    <updated>2018-01-02T15:02:41.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在Java中经常要导出报表，基本上用的都是poi提供的解决方法。在实际操作中excel有两种格式的，一种是2003-xls,一种是2007-xlsx,poi在设计中提供了HSSF和XSSF分别对应，从poi3点几以后的版本有提供了SXSSF的方式。这种方式避免了直接创建workbook对象，而是以接口的形式。具体是的实例是根据读到的文件属性来创建。高明了许多。<br><a id="more"></a></p><h2 id="poi图片导出"><a href="#poi图片导出" class="headerlink" title="poi图片导出"></a>poi图片导出</h2><p>最近在项目中遇到使用SXSSF接口的形式导出图片，代码简记如下！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//创建字节输出流对象</div><div class="line">byteArrayOut = new ByteArrayOutputStream();</div><div class="line">bufferImg = ImageIO.read(new File(&quot;/data/www/&quot;+o.toString().substring(o.toString().lastIndexOf(&quot;//&quot;)+1)));</div><div class="line">ImageIO.write(bufferImg, &quot;jpg&quot;, byteArrayOut);</div><div class="line">int pictureIdx = wb.addPicture(byteArrayOut.toByteArray(), Workbook.PICTURE_TYPE_PNG);</div><div class="line">CreationHelper helper = wb.getCreationHelper();</div><div class="line">//获取绘制管理器</div><div class="line">Drawing drawing = sheet1.createDrawingPatriarch();</div><div class="line">ClientAnchor anchor = helper.createClientAnchor();</div><div class="line">// 图片插入坐标</div><div class="line">anchor.setCol1(h);</div><div class="line">anchor.setRow1(m);</div><div class="line">// 插入图片</div><div class="line">Picture pict = drawing.createPicture(anchor, pictureIdx);</div><div class="line">//一定要重新绘制图片大小</div><div class="line">pict.resize(1,1);</div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实现中有些代码是直接创建HSSF或者XSSF类型的对象来输出图片。这样做代码就不具有健壮性，不同够同时适应2003和2007两种格式的导出需求。图片导出以后，其实是浮现在excel表格之上的，excel中表格中，并不能存放图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在Java中经常要导出报表，基本上用的都是poi提供的解决方法。在实际操作中excel有两种格式的，一种是2003-xls,一种是2007-xlsx,poi在设计中提供了HSSF和XSSF分别对应，从poi3点几以后的版本有提供了SXSSF的方式。这种方式避免了直接创建workbook对象，而是以接口的形式。具体是的实例是根据读到的文件属性来创建。高明了许多。&lt;br&gt;
    
    </summary>
    
      <category term="POI" scheme="http://jiaxiaoxuan.top/categories/POI/"/>
    
    
      <category term="-poi -SXSSF" scheme="http://jiaxiaoxuan.top/tags/poi-SXSSF/"/>
    
  </entry>
  
  <entry>
    <title>ubantu开发软件安装</title>
    <link href="http://jiaxiaoxuan.top/2017/10/14/ubantu%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://jiaxiaoxuan.top/2017/10/14/ubantu开发软件安装/</id>
    <published>2017-10-13T21:33:48.000Z</published>
    <updated>2018-01-02T15:02:42.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一个屌丝程序员，时常需要的软件也就那几个。当然，做为一个Java小白，我需要的软件大概就是以下几个，jdk、tomcat、git、vim、jb全家桶、chrome、atom、lantern等一些个人生活常用软件。下面就一一介绍以下这些软件如何安装。  </p><h2 id="软件安装介绍"><a href="#软件安装介绍" class="headerlink" title="软件安装介绍"></a>软件安装介绍</h2><p>在安装软件之前，首先要明白两个命令，sudo apt-get install 和 sudo dpck。这两个命令一个是在线安装，一个是下载deb的安装包即离线安装。不明白的可以参考别的博文。这里不在介绍!（所有安装包默认都已下载完毕,所有命令都是在非root用户下操作）<br><a id="more"></a></p><h3 id="vim和git的安装"><a href="#vim和git的安装" class="headerlink" title="vim和git的安装"></a>vim和git的安装</h3><p>这两个很简单，直接在终端中分别执行以下两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div><div class="line">sudo apt-get install vim</div></pre></td></tr></table></figure></p><h3 id="java开发环境的搭建"><a href="#java开发环境的搭建" class="headerlink" title="java开发环境的搭建"></a>java开发环境的搭建</h3><p>jdk的安装包直接可以在甲骨文公司的官方网站下载，ubantu的安装包请下载tar.gz结尾的文件。下载成以后，自己选择安装目录，然后将压缩包拷贝过去，在终端中CD到安装目录，执行以下命令解压:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf XXX.tar.gz</div></pre></td></tr></table></figure></p><p>解压成以后使用mv命令重新命名为java，然后在终端中执行<strong><em>vim ~/.bashrc</em></strong>命令配置Java环境变量,该文件编辑的是当前用户的环境变量，不是全局的，只在当前用户生效。内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#java</div><div class="line">export JAVA_HOME=/home/jia/java</div><div class="line">export PATH=$JAVA_HOME/bin:$PATH</div><div class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div></pre></td></tr></table></figure></p><p>编辑保存以后，执行<strong><em>source ~/.bashrc</em></strong> 命令，这条命令会使刚编译的配置文件生效，在终端中执行java\javac命令，查看环境变量是否生效。  </p><h3 id="maven的安装"><a href="#maven的安装" class="headerlink" title="maven的安装"></a>maven的安装</h3><p>在Apache的官方网站下载maven后，使用tar命令解压。建议解压后的文件和Java文件放在一起。然后配置maven环境变量，和Java环境变量一样。bashrc文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#maven</div><div class="line">MAVEN_HOME=/home/jia/maven/</div><div class="line">export MAVEN_HOME</div><div class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</div></pre></td></tr></table></figure></p><h3 id="JB全家桶安装"><a href="#JB全家桶安装" class="headerlink" title="JB全家桶安装"></a>JB全家桶安装</h3><p>JB公司的IDE很好用，我在学校学习的时候，也是使用的eclipse，后来就慢慢的换成idea了，后来接触了pycharm和webstrom,感觉这些都是神器啊。我在JB公司下载的都是tar.gz的压缩文件。安装十分简单。tar -zxvf ×××.tar.gz命令解压，然后在解压后的文件中找到sh启动脚本启动。一般脚本都是在bin目录下，仔细找找就能发现了，启动完成以后，IDE会自动创建桌面图标，不过它会智能的提问你一下，这时千万不要拒绝啊！    </p><h3 id="chrome、atom、lantern、搜狗输入法的安装"><a href="#chrome、atom、lantern、搜狗输入法的安装" class="headerlink" title="chrome、atom、lantern、搜狗输入法的安装"></a>chrome、atom、lantern、搜狗输入法的安装</h3><p>chrome下载传送门  <a href="https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" target="_blank" rel="noopener">chrome下载链接</a><br>lantern下载请移步github搜索关键词lantern<br>atom下载传送门  <a href="https://atom-installer.github.com/v1.21.1/atom-amd64.deb?s=1507768431&amp;ext=.deb" target="_blank" rel="noopener">atom</a><br>搜狗输入法下载传送门  <a href="http://cdn2.ime.sogou.com/dl/index/1491565850/sogoupinyin_2.1.0.0086_amd64.deb?st=H5kpm_eorYrsD3PGM4mueQ&amp;e=1507907727&amp;fn=sogoupinyin_2.1.0.0086_amd64.deb" target="_blank" rel="noopener">搜狗</a><br>这几个下载的都是deb安装包，必须使用dpck 命令安装，命令介绍如下：<br> dpkg dpkg命令软件包管理 dpkg命令是Linux系统用来安装、创建和管理软件包的实用工具。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">语法 dpkg(选项)(参数)</div><div class="line">选项</div><div class="line">-i：安装软件包；</div><div class="line">-r：删除软件包；</div><div class="line">-P：删除软件包的同时删除其配置文件；</div><div class="line">-L：显示于软件包关联的文件；</div><div class="line">-l：显示已安装软件包列表；</div><div class="line">--unpack：解开软件包；</div><div class="line">-c：显示软件包内文件列表；</div><div class="line">--confiugre：配置软件包。</div><div class="line"></div><div class="line">参数</div><div class="line">Deb软件包：指定要操作的.deb软件包。</div><div class="line"></div><div class="line">实例</div><div class="line">dpkg -i package.deb #安装包</div><div class="line">dpkg -r package #删除包</div><div class="line">dpkg -P package #删除包（包括配置文件）</div><div class="line">dpkg -L package #列出与该包关联的文件</div><div class="line">dpkg -l package #显示该包的版本</div><div class="line">dpkg --unpack package.deb #解开deb包的内容</div><div class="line">dpkg -S keyword #搜索所属的包内容</div><div class="line">dpkg -l #列出当前已安装的包</div><div class="line">dpkg -c package.deb #列出deb包的内容 dpkg --configure package #配置包</div><div class="line">来自: http://man.linuxde.net/dpkg</div></pre></td></tr></table></figure></p><p>当然，以下三种也有在线安装的方式，喜欢的话可以自己尝试以下。<br><a href="http://www.linuxidc.com/Linux/2016-05/131096.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2016-05/131096.htm</a><br>上面的这个链接比较详细的介绍了chrome的命令行安装方式，当然这个是我尝试过的。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在Linux系统安装软件并不是很困难，命令就是那几个，多用几次就习惯了。这样基本的开发环境和学习环境就搭建起来了。喜欢听音乐的同学，可以安装一个网易云音乐，不过它ubantu系统磨合的不太好，就每次切换音乐的时候会卡顿一次。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;一个屌丝程序员，时常需要的软件也就那几个。当然，做为一个Java小白，我需要的软件大概就是以下几个，jdk、tomcat、git、vim、jb全家桶、chrome、atom、lantern等一些个人生活常用软件。下面就一一介绍以下这些软件如何安装。  &lt;/p&gt;
&lt;h2 id=&quot;软件安装介绍&quot;&gt;&lt;a href=&quot;#软件安装介绍&quot; class=&quot;headerlink&quot; title=&quot;软件安装介绍&quot;&gt;&lt;/a&gt;软件安装介绍&lt;/h2&gt;&lt;p&gt;在安装软件之前，首先要明白两个命令，sudo apt-get install 和 sudo dpck。这两个命令一个是在线安装，一个是下载deb的安装包即离线安装。不明白的可以参考别的博文。这里不在介绍!（所有安装包默认都已下载完毕,所有命令都是在非root用户下操作）&lt;br&gt;
    
    </summary>
    
      <category term="ubantu" scheme="http://jiaxiaoxuan.top/categories/ubantu/"/>
    
    
      <category term="ubantu" scheme="http://jiaxiaoxuan.top/tags/ubantu/"/>
    
  </entry>
  
  <entry>
    <title>ubantu桌面美化</title>
    <link href="http://jiaxiaoxuan.top/2017/10/10/ubantu%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    <id>http://jiaxiaoxuan.top/2017/10/10/ubantu桌面美化/</id>
    <published>2017-10-10T14:03:46.000Z</published>
    <updated>2018-01-02T15:02:41.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>安装好ubantu系统以后，作为一个简洁的程序员，一方面要美化操作系统，毕竟老夫也是有着一番少女心的，另一方面就要体现程序员的本色了。美化桌面环境和安装各种IDE。</p><h2 id="ubantu桌面环境的美化"><a href="#ubantu桌面环境的美化" class="headerlink" title="ubantu桌面环境的美化"></a>ubantu桌面环境的美化</h2><p>当你安装好ubantu系统以后，肯定是欣喜若狂的，都听大婶说Linux操作系统妙用无穷，是程序员居家旅行必备良品。可是当你进入这系统以后，尝试着使用的时候，你却发现这么垃圾反人类的系统是给人用的嘛？当然喽，我第一次也就是这种感觉，垃圾的桌面环境，不友好的图形化操作！唯一看顺眼的就是ubantu内置的火狐浏览器。不过当你喜欢上它以后就再也离不开他了！</p><a id="more"></a><h3 id="ubantu-unity桌面"><a href="#ubantu-unity桌面" class="headerlink" title="ubantu unity桌面"></a>ubantu unity桌面</h3><p>当你进入乌班图系统后，接触到的其实是unity桌面，根据百度百科的解释，它是脱胎于gnome桌面的，它使用了一些gnome桌面的一些组件，但是并没有完全使用gnome shell。<br><strong><em>百科解释</em></strong><br><img src="/images/ubantu/ubantu16.png" alt=""></p><h3 id="ubantu-gnome-桌面的安装"><a href="#ubantu-gnome-桌面的安装" class="headerlink" title="ubantu gnome 桌面的安装"></a>ubantu gnome 桌面的安装</h3><p>gnome桌面是很美的，你再选择一个美美哒的桌面背景，那美轮美奂的感觉，很快你就会忘记在失去Windows的痛苦，沉醉在这简洁的环境中，就像婴儿肌肤般的润滑。和Windows相比，它就行豆蔻年华的少女，通红的胴体，任由你去探索，而万恶的Windows就像浓妆艳抹的恶妇，臃肿不堪！<br>安装gnome桌面只需要以下几条命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">安装之前先添加库并更新，已保证后面的安装顺利</div><div class="line">sudo add-apt-repository ppa:gnome3-team/gnome3-staging</div><div class="line">sudo add-apt-repository ppa:gnome3-team/gnome3</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get dist-upgrade</div><div class="line"></div><div class="line">sudo apt-get install gnome-shell</div><div class="line">sudo apt-get install ubuntu-gnome-desktop</div></pre></td></tr></table></figure></p><p>安装时弹出窗选择如下:<br><img src="/images/ubantu/ubantu17.png" alt=""><br>当然萝卜白菜各有所爱，卸载命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove gnome-shell</div><div class="line">sudo apt-get remove ubuntu-gnome-desktop</div></pre></td></tr></table></figure></p><p>安装重启的时候要注意,登录的时候要选择第一项哦,千万不要尝试第二项，否则会开不了机，不要怪我没有告诉你！<br><img src="/images/ubantu/ubantu18.png" alt="">  </p><p>重启进入系统如下:<br><img src="/images/ubantu/ubantu14.png" alt=""></p><p>选择安装ARC主题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">arc-theme安装方法：</div><div class="line">sudo add-apt-repository ppa:noobslab/themes</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install arc-theme</div><div class="line">安装gnome-tweak-tool用于切换主题：</div><div class="line">sudo apt-get install gnome-tweak-tool</div><div class="line">运行gnome-tweak-tool选择Arc-Dark为GTK+主题。</div></pre></td></tr></table></figure></p><p>arc主题提供了很多选择，各种颜色搭配。可以让你定制自己喜欢的桌面。  </p><h2 id="系统美化总结"><a href="#系统美化总结" class="headerlink" title="系统美化总结"></a>系统美化总结</h2><p>如果你喜欢Mac桌面下的那个dock风格，你也可以在乌班图下安装，就在乌班图的软件中心搜索dock即可，不过我个人认为那个工具很鸡肋，消耗内存，和乌班图系统融合的也不是很好，不太建议使用。arc-theme主题还在使用中感觉也很不错。配置高的话可以安装一个试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;安装好ubantu系统以后，作为一个简洁的程序员，一方面要美化操作系统，毕竟老夫也是有着一番少女心的，另一方面就要体现程序员的本色了。美化桌面环境和安装各种IDE。&lt;/p&gt;
&lt;h2 id=&quot;ubantu桌面环境的美化&quot;&gt;&lt;a href=&quot;#ubantu桌面环境的美化&quot; class=&quot;headerlink&quot; title=&quot;ubantu桌面环境的美化&quot;&gt;&lt;/a&gt;ubantu桌面环境的美化&lt;/h2&gt;&lt;p&gt;当你安装好ubantu系统以后，肯定是欣喜若狂的，都听大婶说Linux操作系统妙用无穷，是程序员居家旅行必备良品。可是当你进入这系统以后，尝试着使用的时候，你却发现这么垃圾反人类的系统是给人用的嘛？当然喽，我第一次也就是这种感觉，垃圾的桌面环境，不友好的图形化操作！唯一看顺眼的就是ubantu内置的火狐浏览器。不过当你喜欢上它以后就再也离不开他了！&lt;/p&gt;
    
    </summary>
    
      <category term="ubantu" scheme="http://jiaxiaoxuan.top/categories/ubantu/"/>
    
    
      <category term="ubantu" scheme="http://jiaxiaoxuan.top/tags/ubantu/"/>
    
  </entry>
  
  <entry>
    <title>ubantu优盘安装</title>
    <link href="http://jiaxiaoxuan.top/2017/10/09/ubantu%E4%BC%98%E7%9B%98%E5%AE%89%E8%A3%85/"/>
    <id>http://jiaxiaoxuan.top/2017/10/09/ubantu优盘安装/</id>
    <published>2017-10-09T13:21:58.000Z</published>
    <updated>2018-01-02T15:02:41.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文将介绍如何通过u盘安装ubantu系统，首先是在Windows系统下通过软通牒制作u盘镜像，其次是在安装过程中的分区问题，以及如何与自己的Windows系统共存，其实Windows10/8/7与ubantu双系统是举一反三的，本人安装的是ubantu17.04/Windows10双系统。（有些图是引用网络上的，步骤完全没问题）</p><a id="more"></a><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><p>在安装前请准备以下安装包和工具。<br>  1.U盘一个。<br>  2.ubantu系统 <a href="http://releases.ubuntu.com/17.04/ubuntu-17.04-desktop-amd64.iso" target="_blank" rel="noopener">下载地址</a><br>  3.软通牒系统 <a href="http://sw.bos.baidu.com/sw-search-sp/software/25aa83cb6273c/uiso9_cn_9.7.0.3476.exe" target="_blank" rel="noopener">百度下载中心</a><br>在Windows系统上下载软通牒并安装，下载ubantu系统备用。  </p><h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><p>1.软通牒软件如何安装不再介绍，安装好后选择试用即可。<br>如下图：<br><img src="/images/ubantu/ubantu1.png" alt=""><br>2.进入软通牒，选择文件-&gt;打开<br><img src="/images/ubantu/ubantu3.png" alt=""><br>3.选择已下载好的ubantu镜像ISO文件<br><img src="/images/ubantu/ubantu4.png" alt=""><br>4.打开之后是这个样子，注意软件的顶部文字，显示的是打开ubantu镜像的<br><img src="/images/ubantu/ubantu5.png" alt=""><br>5.然后选择启动-&gt;写入硬盘镜像<br><img src="/images/ubantu/ubantu6.png" alt=""><br>6.此时设置如图，注意引导的写入是USB-HDD++，写入时间较长，请耐心等待<br><img src="/images/ubantu/ubantu8.png" alt=""><br>7.写入完成以后，打开U盘是这个样子的！<br><img src="/images/ubantu/ubantu7.png" alt=""><br>制作好U盘镜像以后，接下来我们就要安装了！</p><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>系统安装并没有特殊的地方，和普通的Windows安装一样，F12（电脑型号不同按键可能不一样，同时有些人的电脑可能禁止了从u盘启动的选项，需要进入BIOS界面重新设置）进入启动选择操作。选择USB，也就是你的U盘，这样就可以直接进入ubantu安装界面。<br><img src="/images/ubantu/ubantu11.png" alt=""><br>上图要选择安装语言，默认是英文，左侧列表往下拉，就能找到中文简体选项。<br>选择安装(当然你也可以选择试用)以后，会让选择是否链接WiFi，是否安装驱动和更新，全部选否，或者不要勾选，等安装完成再更新。<br><img src="/images/ubantu/ubantu9.png" alt=""><br>点击下一步，会出现下面两种情况，一种是已经安装有其他操作系统，一种是没有，如下图。<br><img src="/images/ubantu/ubantu10.png" alt=""><img src="/images/ubantu/ubantu12.png" alt=""><br>傻瓜式安装选择第一项就可。<br>下面的选择继续<br><img src="/images/ubantu/ubantu13.png" alt=""><br>后面的过程就是下一步，下一步了。时区、键盘设置、用户密码设置不在叙述。  </p><h2 id="分区问题"><a href="#分区问题" class="headerlink" title="分区问题"></a>分区问题</h2><p>如果在上面不是选择傻瓜式安装，而是选择自定义分区了，怎么办呢，其实作为从事开发工作的就应该选择自定义安装，这确实能够学到些东西。  </p><p>以下知乎上面说的，我截取了下了<br>作者：知乎用户<br>链接：<a href="https://www.zhihu.com/question/20565314/answer/15518260" target="_blank" rel="noopener">https://www.zhihu.com/question/20565314/answer/15518260</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p> Ubuntu 桌面系统的分区方案。<br> 要了解分区方案，先从 Linux 系统的目录结构说起。使用 Windows 系统的用户都知道，Windows 系统先有分区的存在，然后在不同的分区下创建文件目录结构。于是我们看到诸如 C:\Windows D:\Downloads 之类目录，也就是说每一个目录首先是存在于某个分区的。Linux 系统则相反，它首先确定有目录的存在，例如：/， /usr， /media/usb，/media/cdrom， /disk 然后才确定这个目录上挂载的是哪个分区（甚至挂载的可能是CDROM， USB等外设以及ISO光盘镜像文件：类似 Windows 下虚拟光驱的作用）。访问某个目录，实质上就相当于访问挂载在这个目录上的分区，外设或者光盘镜像文件。<br> 我们在 上一篇 博客中提到过一个系统存储重要数据的目录： /home 目录， 在通常的最佳实践中，可以把这个 home 目录作为一个单独的挂载点，挂载一个独立分区。这样做有几个好处：<br> 系统分区如果损坏，幷不影响到 /home 分区所在的数据。这些数据通常非常重要，包括有你常用的软件，重要的文档以及各类软件的配置信息，反过来我们也鼓励把重要的数据存放在 /home 目录下，使得他们保存在系统分区以外的分区，避免因为系统的问题受损。在重装系统，或者升级系统以后，/home 分区的数据可以得到保留，最大程度的避免了软件安装和重新配置的耗时工作。在日常备份的工作中可以选择只备份 /home 分区所在的数据，避免做全盘的备份。我自己就曾经因为在两年前安装Ubuntu 10.04的时候只分了一个分区，把 /home 目录下的数据和系统文件存储在了同一个分区下，导致在安装Ubuntu 12.04的时候，在没有第二个分区和第二台电脑用来备份/home目录数据的情况下，忍痛将整个系统连同/home目录里的数据全部格式化，损失惨重， 教训深刻。<br> 所以一般来说一个 Ubuntu 的系统在安装之初应该有三个分区，他们分别是挂载于根目录： /, home目录： /home 的两个分区以及 swap 分区。swap分区是指虚拟内存的交换区，一般设置为实际内存容量的两倍大小即可。假设你有一台500G硬盘，2G内存的PC，那么比较好的分区分配方案是：根目录所在分区分配50G左右， swap分区分配4G，剩余空间全部留给 /home 所在分区即可。<br><strong>安装注意事项在安装之前</strong>  ，记得备份本机重要数据。在电脑上插入启动U盘后，选择从U盘启动计算机：大多数电脑可以在出现启动画面的时候按F12选择启动媒介，此时选择U盘即可。之后一路安装 Ubuntu 会比较顺利，但是以下几个地方仍然需要注意：在 Installation type 界面选择 Something else 选项，这样你才有机会调整，保留现有分区以及分区上的数据，并将多个分区挂载到同一个系统的不同挂载点（上文所述的根目录和home目录）【推荐】。选择 ext4 文件系统格式作为 Linux 的文件系统格式。三个分区大小可按上个小节分配，根目录分区大小不必过大，50G至多，如果硬盘本身不大，只分配15G问题也不大。大多的数据应该存放在 /home， 因此 /home 所在分区应该足够大。Installation type 界面中 Device for boot loader installation 选项列表中记得选择硬盘所在条目一般是：/dev/sda，笔者安装 12.04 时因为不慎选择了 USB 所在媒介：/dev/sdb 导致安装完毕后只有插着USB才能启动系统，悲剧！(此种情况本人在安装过程也遇到了，只能费劲再重新来过！！！！！！)   </p><p>下面是本人整理的分区方案:</p><table><thead><tr><th>目录</th><th>建议大小</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>/</td><td>10G-20G</td><td>ext4</td><td>根目录</td></tr><tr><td>swap</td><td>&lt;2048M</td><td>swap</td><td>交换空间</td></tr><tr><td>/boot</td><td>500M左右</td><td>ext4</td><td>Linux的内核及引导系统程序所需要的文件，比如 vmlinuz initrd.img文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；启动撞在文件存放位置，如kernels，initrd，grub。有人说200M可惜ubantu17不够用，我被迫重装。</td></tr><tr><td>/tmp</td><td>5G左右</td><td>ext4</td><td>系统的临时文件，一般系统重启不会被保存。（建立服务器需要？）</td></tr><tr><td>/home</td><td>尽量大些</td><td>ext4</td><td>用户工作目录；个人配置文件，如个人环境变量等；所有账号分配一个工作目录。</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>国庆八天假，几乎每天回来都会倒腾ubantu系统，来来回回重装了好几次，可是折腾死我了！明天再接着介绍如何美化ubantu，总不能装个那么丑的ubantu工作吧，原生的unity主题太丑，影响我心情！  放个图!  </p><p><img src="/images/ubantu/ubantu14.png" alt="">  </p><p>JB公司全家桶！<br><img src="/images/ubantu/ubantu15.png" alt="">   </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文将介绍如何通过u盘安装ubantu系统，首先是在Windows系统下通过软通牒制作u盘镜像，其次是在安装过程中的分区问题，以及如何与自己的Windows系统共存，其实Windows10/8/7与ubantu双系统是举一反三的，本人安装的是ubantu17.04/Windows10双系统。（有些图是引用网络上的，步骤完全没问题）&lt;/p&gt;
    
    </summary>
    
      <category term="ubantu" scheme="http://jiaxiaoxuan.top/categories/ubantu/"/>
    
    
      <category term="ubantu" scheme="http://jiaxiaoxuan.top/tags/ubantu/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://jiaxiaoxuan.top/2017/09/25/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jiaxiaoxuan.top/2017/09/25/装饰模式/</id>
    <published>2017-09-25T06:23:43.000Z</published>
    <updated>2018-01-02T15:02:41.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>装饰设计模式</em></strong></p><h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。<br>（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2） 装饰对象包含一个真实对象的引用（reference）<br>（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</p><a id="more"></a><h1 id="理论详解"><a href="#理论详解" class="headerlink" title="理论详解"></a>理论详解</h1><p>要求：自定义一些Reader类，读取不同的数据(装饰和继承的区别)<br>MyReader //专门用于读取数据的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">|--MyTextReader</div><div class="line">        |--MyBufferTextReader</div><div class="line">|--MyMediaReader</div><div class="line">        |--MyBufferMediaReader</div><div class="line">|--MyDataReader</div><div class="line">        |--MyBufferDataReader</div></pre></td></tr></table></figure><p>如果将他们抽取出来，设计一个MyBufferReader，可以根据传入的类型进行增强</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyBufferReader &#123;</div><div class="line">    MyBufferReader (MyTextReader text) &#123;&#125;</div><div class="line">    MyBufferReader (MyMediaReader media) &#123;&#125;</div><div class="line">    MyBufferReader (MyDataReader data) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是上面的类拓展性很差。找到其参数的共同类型即共同实现的接口或者继承的类，通过多态的形式，可以提高拓展性.这样以后的类只要继承共同的类型,都能用这个增强类增强自身的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MyBufferReader  extends MyReader&#123;</div><div class="line">    private MyReader r;                        //从继承变为了组成模式  装饰设计模式</div><div class="line">    MyBufferReader(MyReader r) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>优化后的体系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|--MyTextReader</div><div class="line">    |--MyMediaReader</div><div class="line">    |--MyDataReader</div><div class="line">    |--MyBufferReader</div></pre></td></tr></table></figure><p> //增强上面三个。装饰模式比继承灵活，避免继承体系的臃肿。降低类与类之间的耦合性</p><p>装饰类只能增强已有的对象，具备的功能是相同的。所以装饰类和被装饰类属于同一个体系.</p><p>MyBuffereReader类：  自己写一个MyBuffereReader类，功能与BuffereReader相同</p><h1 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.FileNotFoundException;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.io.Reader;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 基于i/o流的装饰模式练习</div><div class="line"> * @author Administrator</div><div class="line"> * 2017年8月18日  下午4:32:00</div><div class="line"> */</div><div class="line">public class MyBufferReader extends Reader&#123;</div><div class="line"></div><div class="line">     private Reader r;  </div><div class="line">     MyBufferReader(Reader r)&#123;  </div><div class="line">          this.r  = r;  </div><div class="line">     &#125;</div><div class="line">@Override</div><div class="line">public int read(char[] cbuf, int off, int len) throws IOException &#123;</div><div class="line">return  r.read(cbuf,off,len);  </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void close() throws IOException &#123;</div><div class="line"> r.close();  </div><div class="line">&#125;</div><div class="line">   //一次读一行数据的方法  </div><div class="line">   public String myReaderline()  throws IOException &#123;  </div><div class="line">       //定义一个临时容器，原BufferReader封装的是字符数组。  </div><div class="line">       //为了演示方便。定义一个StringBuilder容器。最终要将数据变成字符串  </div><div class="line">       StringBuilder sb = new StringBuilder();  </div><div class="line">       int ch = 0;  </div><div class="line">       while((ch = r.read()) != -1)  </div><div class="line">       &#123;  </div><div class="line">           if(ch == &apos;\r&apos;)   </div><div class="line">               continue;  </div><div class="line">           if(ch == &apos;\n&apos;)                    //遇到换行符\n,返回字符串  </div><div class="line">               return sb.toString();  </div><div class="line">           else  </div><div class="line">           sb.append((char)ch);  </div><div class="line">       &#125;  </div><div class="line">       if(sb.length()!=0)                    //当最后一行不是以\n结束时候，这里需要判断  </div><div class="line">           return sb.toString();  </div><div class="line">       return null;  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   @SuppressWarnings(&quot;resource&quot;)</div><div class="line">public static void main(String[] args) throws Exception &#123;</div><div class="line">   MyBufferReader myReader=new MyBufferReader(new InputStreamReader(new FileInputStream(&quot;E:/files.txt&quot;)));</div><div class="line">   System.out.println(myReader.myReaderline());</div><div class="line">   myReader.close();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>装饰模式相当于对房屋进行装修，不过在设计的时候，要避免对一个房屋装修，应该通过接口，定义一类房屋，对实现了这个接口的一类房屋进行装修。这样设计出来的装饰类，更具拓展性。只要符合这个接口的新建房屋都可以使用这个装修队来装修。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;装饰设计模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot; title=&quot;摘要：&quot;&gt;&lt;/a&gt;摘要：&lt;/h1&gt;&lt;p&gt;装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;br&gt;（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。&lt;br&gt;（2） 装饰对象包含一个真实对象的引用（reference）&lt;br&gt;（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。&lt;br&gt;（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://jiaxiaoxuan.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="装饰模式" scheme="http://jiaxiaoxuan.top/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC之参数绑定</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/SpringMVC%E4%B9%8B%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/SpringMVC之参数绑定/</id>
    <published>2017-09-24T14:44:15.000Z</published>
    <updated>2018-01-02T15:02:41.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><p>前段时间项目中用到了REST风格来开发程序，但是当用POST、PUT模式提交数据时，发现服务器端接受不到提交的数据（服务器端参数绑定没有加任何注解），查看了提交方式为application/json， 而且服务器端通过request.getReader() 打出的数据里确实存在浏览器提交的数据。为了找出原因，便对参数绑定<br>@RequestParam<br>@RequestBody<br>@RequestHeader<br>@PathVariable<br>进行了研究，同时也看了一下HttpMessageConverter的相关内容，在此一并总结。</p><p>此篇文章虽然也是摘抄自网络，但是也解决了最近一来我得困惑，对这些注解的选用，同样的我也在继续的研究中!<br><a id="more"></a></p><h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>RequestMapping注解有六个属性，下面我们把她分成三类进行说明。  </p><h2 id="1、-value，-method"><a href="#1、-value，-method" class="headerlink" title="1、 value， method"></a>1、 value， method</h2><ul><li><p>value:指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；当之设置value一个属性时，value可以省略不写，当有其他属性时则需要加上进行区分，如下图：<br>　　　　　<br>　　<img src="/images/spring1.png" alt="image">　　　</p></li><li><p>method：  指定请求的method类型， GET、POST、PUT、DELETE等；</p><h2 id="2、-consumes，produces"><a href="#2、-consumes，produces" class="headerlink" title="2、 consumes，produces:"></a>2、 consumes，produces:</h2></li><li><p>consumes:指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;  </p></li><li><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；  </p><h2 id="3、-params，headers"><a href="#3、-params，headers" class="headerlink" title="3、 params，headers:"></a>3、 params，headers:</h2></li><li>params： 指定request中必须包含某些参数值是，才让该方法处理。  </li><li>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。  <h1 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h1><h2 id="1、value-method-示例"><a href="#1、value-method-示例" class="headerlink" title="1、value  / method 示例"></a>1、value  / method 示例</h2>默认RequestMapping(“….str…”)即为value的值；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@Controller  </div><div class="line">@RequestMapping(&quot;/appointments&quot;)  </div><div class="line">public class AppointmentsController &#123;  </div><div class="line"></div><div class="line">    private final AppointmentBook appointmentBook;  </div><div class="line"></div><div class="line">    @Autowired  </div><div class="line">    public AppointmentsController(AppointmentBook appointmentBook) &#123;  </div><div class="line">        this.appointmentBook = appointmentBook;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @RequestMapping(method = RequestMethod.GET)  </div><div class="line">    public Map&lt;String, Appointment&gt; get() &#123;  </div><div class="line">        return appointmentBook.getAppointmentsForToday();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @RequestMapping(value=&quot;/&#123;day&#125;&quot;, method = RequestMethod.GET)  </div><div class="line">    public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) &#123;  </div><div class="line">        return appointmentBook.getAppointmentsForDay(day);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @RequestMapping(value=&quot;/new&quot;, method = RequestMethod.GET)  </div><div class="line">    public AppointmentForm getNewForm() &#123;  </div><div class="line">        return new AppointmentForm();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @RequestMapping(method = RequestMethod.POST)  </div><div class="line">    public String add(@Valid AppointmentForm appointment, BindingResult result) &#123;  </div><div class="line">        if (result.hasErrors()) &#123;  </div><div class="line">            return &quot;appointments/new&quot;;  </div><div class="line">        &#125;  </div><div class="line">        appointmentBook.addAppointment(appointment);  </div><div class="line">        return &quot;redirect:/appointments&quot;;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>value的uri值为以下三类：<br>A） 可以指定为普通的具体值；<br>B)  可以指定为含有某变量的一类值(URI Template Patterns with Path Variables)；<br>C) 可以指定为含正则表达式的一类值( URI Template Patterns with Regular Expressions);   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">example B)</div><div class="line">@RequestMapping(value=&quot;/owners/&#123;ownerId&#125;&quot;, method=RequestMethod.GET)  </div><div class="line">public String findOwner(@PathVariable String ownerId, Model model) &#123;  </div><div class="line">  Owner owner = ownerService.findOwner(ownerId);    </div><div class="line">  model.addAttribute(&quot;owner&quot;, owner);    </div><div class="line">  return &quot;displayOwner&quot;;   </div><div class="line">&#125;</div><div class="line">example C)</div><div class="line">@RequestMapping(&quot;/spring-web/&#123;symbolicName:[a-z-]+&#125;-&#123;version:\d\.\d\.\d&#125;.&#123;extension:\.[a-z]&#125;&quot;)  </div><div class="line">  public void handle(@PathVariable String version, @PathVariable String extension) &#123;      </div><div class="line">    // ...  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-consumes、produces-示例"><a href="#2-consumes、produces-示例" class="headerlink" title="2 consumes、produces 示例"></a>2 consumes、produces 示例</h2><p><strong>cousumes的样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1 @Controller  </div><div class="line">2 @RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;)  </div><div class="line">3 public void addPet(@RequestBody Pet pet, Model model) &#123;      </div><div class="line">4     // implementation omitted  </div><div class="line">5 &#125;</div></pre></td></tr></table></figure><p>方法仅处理request Content-Type为“application/json”类型的请求。  </p><p><strong>produces的样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Controller  </div><div class="line">@RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, produces=&quot;application/json&quot;)  </div><div class="line">@ResponseBody  </div><div class="line">public Pet getPet(@PathVariable String petId, Model model) &#123;      </div><div class="line">    // implementation omitted  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法仅处理request请求中Accept头中包含了”application/json”的请求，同时暗示了返回的内容类型为application/json;  </p><h2 id="3-params、headers-示例"><a href="#3-params、headers-示例" class="headerlink" title="3 params、headers 示例"></a>3 params、headers 示例</h2><p><strong>params的样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1 @Controller  </div><div class="line">2 @RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)  </div><div class="line">3 public class RelativePathUriTemplateController &#123;  </div><div class="line">4   </div><div class="line">5   @RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)  </div><div class="line">6   public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;      </div><div class="line">7     // implementation omitted  </div><div class="line">8   &#125;  </div><div class="line">9 &#125;</div></pre></td></tr></table></figure><p>仅处理请求中包含了名为“myParam”，值为“myValue”的请求；<br><strong>headers的样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1 @Controller  </div><div class="line">2 @RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)  </div><div class="line">3 public class RelativePathUriTemplateController &#123;  </div><div class="line">4   </div><div class="line">5 @RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)  </div><div class="line">6   public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;      </div><div class="line">7     // implementation omitted  </div><div class="line">8   &#125;  </div><div class="line">9 &#125;</div></pre></td></tr></table></figure><p>仅处理request的header中包含了指定“Refer”请求头和对应值为“<a href="http://www.ifeng.com/”的请求；" target="_blank" rel="noopener">http://www.ifeng.com/”的请求；</a>  </p><h1 id="参数绑定注解简介："><a href="#参数绑定注解简介：" class="headerlink" title="参数绑定注解简介："></a>参数绑定注解简介：</h1><p>handler method 参数绑定常用的注解,我们根据他们处理的Request的不同内容部分分为四类七个注解 ：（主要讲解常用类型）<br>A、处理requet uri 部分（这里指uri template中variable，不含queryString部分）的注解：   @PathVariable;<br>B、处理request header部分的注解：   @RequestHeader, @CookieValue;<br>C、处理request body部分的注解：@RequestParam,  @RequestBody;<br>D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;   </p><h2 id="1、-PathVariable"><a href="#1、-PathVariable" class="headerlink" title="1、 @PathVariable"></a>1、 @PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。<br>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1. @Controller  </div><div class="line">2. @RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)  </div><div class="line">3. public class RelativePathUriTemplateController &#123;  </div><div class="line">4. @RequestMapping(&quot;/pets/&#123;petId&#125;&quot;)  </div><div class="line">5. public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;      </div><div class="line">6. // implementation omitted  </div><div class="line">7.   &#125;  </div><div class="line">8. &#125;</div></pre></td></tr></table></figure><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h2 id="2、-RequestHeader、-CookieValue"><a href="#2、-RequestHeader、-CookieValue" class="headerlink" title="2、 @RequestHeader、@CookieValue"></a>2、 @RequestHeader、@CookieValue</h2><p><strong>@RequestHeader</strong> 注解，可以把Request请求header部分的值绑定到方法的参数上。<br>示例代码：<br>这是一个Request 的header部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. Host                    localhost:8080  </div><div class="line">2. Accept                  text/html,application/xhtml+xml,application/xml;q=0.9  </div><div class="line">3. Accept-Language         fr,en-gb;q=0.7,en;q=0.3  </div><div class="line">4. Accept-Encoding         gzip,deflate  </div><div class="line">5. Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7  </div><div class="line">6. Keep-Alive              300</div></pre></td></tr></table></figure></p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. @RequestMapping(&quot;/displayHeaderInfo.do&quot;)  </div><div class="line">2. public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,  </div><div class="line">3. @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive)  &#123;  </div><div class="line">4. //...  </div><div class="line">5. &#125;</div></pre></td></tr></table></figure><p>上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。<br><strong>@CookieValue</strong> 可以把Request header中关于cookie的值绑定到方法的参数上。<br>例如有如下Cookie值：  </p><pre><code>1. JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84  </code></pre><p>参数绑定的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. @RequestMapping(&quot;/displayHeaderInfo.do&quot;)  </div><div class="line">2. public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  &#123;  </div><div class="line">3. //...  </div><div class="line">4. &#125;</div></pre></td></tr></table></figure><p>即把JSESSIONID的值绑定到参数cookie上。  </p><h2 id="3、-RequestParam-RequestBody"><a href="#3、-RequestParam-RequestBody" class="headerlink" title="3、@RequestParam, @RequestBody"></a>3、@RequestParam, @RequestBody</h2><p><strong>@RequestParam</strong><br>A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；<br>因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；</p><p>B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；  </p><p>C) 该注解有两个属性： value、required；  </p><p>value用来指定要传入值的id名称，required用来指示参数是否必须绑定；<br>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. @Controller  </div><div class="line">2. @RequestMapping(&quot;/pets&quot;)  </div><div class="line">3. @SessionAttributes(&quot;pet&quot;)  </div><div class="line">4. public class EditPetForm &#123;  </div><div class="line">5. // ...  </div><div class="line">6. @RequestMapping(method = RequestMethod.GET)  </div><div class="line">7. public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) &#123;  </div><div class="line">8.         Pet pet = this.clinic.loadPet(petId);  </div><div class="line">9.         model.addAttribute(&quot;pet&quot;, pet);  </div><div class="line">10. return &quot;petForm&quot;;  </div><div class="line">11.     &#125;  </div><div class="line">12. // ...</div></pre></td></tr></table></figure><p><strong>@RequestBody</strong><br>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；<br>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。<br>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;<br>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. @RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)  </div><div class="line">2. public void handle(@RequestBody String body, Writer writer) throws IOException &#123;  </div><div class="line">3.   writer.write(body);  </div><div class="line">4. &#125;</div></pre></td></tr></table></figure><h2 id="4、-SessionAttributes-ModelAttribute"><a href="#4、-SessionAttributes-ModelAttribute" class="headerlink" title="4、@SessionAttributes, @ModelAttribute"></a>4、@SessionAttributes, @ModelAttribute</h2><p><strong>@SessionAttributes:</strong><br>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。<br>该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象；<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. @Controller  </div><div class="line">2. @RequestMapping(&quot;/editPet.do&quot;)  </div><div class="line">3. @SessionAttributes(&quot;pet&quot;)  </div><div class="line">4. public class EditPetForm &#123;  </div><div class="line">5. // ...  </div><div class="line">6. &#125;</div></pre></td></tr></table></figure></p><h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><p>该注解有两个用法，一个是用于方法上，一个是用于参数上；  </p><ul><li>用于方法上时：  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；   </li><li>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：<br>A） @SessionAttributes 启用的attribute 对象上；<br>B） @ModelAttribute 用于方法上时指定的model对象；<br>C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。<br>用到方法上@ModelAttribute的示例代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1. // Add one attribute  </div><div class="line">2. // The return value of the method is added to the model under the name &quot;account&quot;  </div><div class="line">3. // You can customize the name via @ModelAttribute(&quot;myAccount&quot;)  </div><div class="line">4. @ModelAttribute  </div><div class="line">5. public Account addAccount(@RequestParam String number) &#123;  </div><div class="line">6. return accountManager.findAccount(number);  </div><div class="line">7. &#125;</div></pre></td></tr></table></figure><p>这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）；  </p><p>用在参数上的@ModelAttribute示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. @RequestMapping(value=&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)  </div><div class="line">2. public String processSubmit(@ModelAttribute Pet pet) &#123;  </div><div class="line">3. &#125;</div></pre></td></tr></table></figure></p><p>首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。</p><h1 id="源码剖析："><a href="#源码剖析：" class="headerlink" title="源码剖析："></a>源码剖析：</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：<br>i) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；<br>ii) 再把HttpMessageConverter返回的对象数据绑定到   controller中方法的参数上。</p><pre><code>使用时机：  A) GET、POST方式提时， 根据request header Content-Type的值来判断:● application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam,  @ModelAttribute也可以处理，当然@RequestBody也能处理）；● multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；● 其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；B) PUT方式提交时， 根据request header Content-Type的值来判断:  ●  application/x-www-form-urlencoded， 必须；  ●  multipart/form-data, 不能处理；  ●  其他格式， 必须；  </code></pre><p>说明：request的body部分的数据编码格式由header部分的Content-Type指定；  </p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>作用：<br>该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">HttpMessageConverter</div><div class="line">1. &quot;font-family:Microsoft YaHei;&quot;&gt;/**</div><div class="line">2.  * Strategy interface that specifies a converter that can convert from and to HTTP requests and responses.</div><div class="line">3.  *</div><div class="line">4.  * @author Arjen Poutsma</div><div class="line">5.  * @author Juergen Hoeller</div><div class="line">6.  * @since 3.0</div><div class="line">7.  */  </div><div class="line">8. public interface HttpMessageConverter &#123;  </div><div class="line">9. /**</div><div class="line">10.      * Indicates whether the given class can be read by this converter.</div><div class="line">11.      * @param clazz the class to test for readability</div><div class="line">12.      * @param mediaType the media type to read, can be &#123;@code null&#125; if not specified.</div><div class="line">13.      * Typically the value of a &#123;@code Content-Type&#125; header.</div><div class="line">14.      * @return &#123;@code true&#125; if readable; &#123;@code false&#125; otherwise</div><div class="line">15.      */  </div><div class="line">16. boolean canRead(Class clazz, MediaType mediaType);  </div><div class="line">17. /**</div><div class="line">18.      * Indicates whether the given class can be written by this converter.</div><div class="line">19.      * @param clazz the class to test for writability</div><div class="line">20.      * @param mediaType the media type to write, can be &#123;@code null&#125; if not specified.</div><div class="line">21.      * Typically the value of an &#123;@code Accept&#125; header.</div><div class="line">22.      * @return &#123;@code true&#125; if writable; &#123;@code false&#125; otherwise</div><div class="line">23.      */  </div><div class="line">24. boolean canWrite(Class clazz, MediaType mediaType);  </div><div class="line">25. /**</div><div class="line">26.      * Return the list of &#123;@link MediaType&#125; objects supported by this converter.</div><div class="line">27.      * @return the list of supported media types</div><div class="line">28.      */  </div><div class="line">29.     List getSupportedMediaTypes();  </div><div class="line">30. /**</div><div class="line">31.      * Read an object of the given type form the given input message, and returns it.</div><div class="line">32.      * @param clazz the type of object to return. This type must have previously been passed to the</div><div class="line">33.      * &#123;@link #canRead canRead&#125; method of this interface, which must have returned &#123;@code true&#125;.</div><div class="line">34.      * @param inputMessage the HTTP input message to read from</div><div class="line">35.      * @return the converted object</div><div class="line">36.      * @throws IOException in case of I/O errors</div><div class="line">37.      * @throws HttpMessageNotReadableException in case of conversion errors</div><div class="line">38.      */  </div><div class="line">39.     T read(Classextends T&gt; clazz, HttpInputMessage inputMessage)  </div><div class="line">40. throws IOException, HttpMessageNotReadableException;  </div><div class="line">41. /**</div><div class="line">42.      * Write an given object to the given output message.</div><div class="line">43.      * @param t the object to write to the output message. The type of this object must have previously been</div><div class="line">44.      * passed to the &#123;@link #canWrite canWrite&#125; method of this interface, which must have returned &#123;@code true&#125;.</div><div class="line">45.      * @param contentType the content type to use when writing. May be &#123;@code null&#125; to indicate that the</div><div class="line">46.      * default content type of the converter must be used. If not &#123;@code null&#125;, this media type must have</div><div class="line">47.      * previously been passed to the &#123;@link #canWrite canWrite&#125; method of this interface, which must have</div><div class="line">48.      * returned &#123;@code true&#125;.</div><div class="line">49.      * @param outputMessage the message to write to</div><div class="line">50.      * @throws IOException in case of I/O errors</div><div class="line">51.      * @throws HttpMessageNotWritableException in case of conversion errors</div><div class="line">52.      */  </div><div class="line">53. void write(T t, MediaType contentType, HttpOutputMessage outputMessage)  </div><div class="line">54. throws IOException, HttpMessageNotWritableException;  </div><div class="line">55. &#125;  </div><div class="line">56.</div></pre></td></tr></table></figure><p>该接口定义了四个方法，分别是读取数据时的 canRead(), read() 和 写入数据时的canWrite(), write()方法。<br>在使用 标签配置时，默认配置了RequestMappingHandlerAdapter（注意是RequestMappingHandlerAdapter不是AnnotationMethodHandlerAdapter,详情查看spring 3.1 document “16.14 Configuring Spring MVC”章节），并为他配置了一下默认的HttpMessageConverter：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1. ByteArrayHttpMessageConverter converts byte arrays.  </div><div class="line">2. StringHttpMessageConverter converts strings.  </div><div class="line">3. ResourceHttpMessageConverter converts to/from org.springframework.core.io.Resource for all media types.  </div><div class="line">4. SourceHttpMessageConverter converts to/from a javax.xml.transform.Source.  </div><div class="line">5. FormHttpMessageConverter converts form data to/from a MultiValueMap.  </div><div class="line">6. Jaxb2RootElementHttpMessageConverter converts Java objects to/from XML — added if JAXB2 is present on the classpath.  </div><div class="line">7. MappingJacksonHttpMessageConverter converts to/from JSON — added if Jackson is present on the classpath.  </div><div class="line">8. AtomFeedHttpMessageConverter converts Atom feeds — added if Rome is present on the classpath.  </div><div class="line">9. RssChannelHttpMessageConverter converts RSS feeds — added if Rome is present on the classpath.</div></pre></td></tr></table></figure><ul><li>ByteArrayHttpMessageConverter:负责读取二进制格式的数据和写出二进制格式的数据；</li><li>StringHttpMessageConverter：   负责读取字符串格式的数据和写出二进制格式的数据；</li><li>ResourceHttpMessageConverter：负责读取资源文件和写出资源文件数据；</li><li>FormHttpMessageConverter：<br>负责读取form提交的数据（能读取的数据格式为 application/x-www-form-urlencoded，不能读取multipart/form-data格式数据）；负责写入application/x-www-from-urlencoded和multipart/form-data格式的数据；</li><li>MappingJacksonHttpMessageConverter:  负责读取和写入json格式的数据；</li><li>SouceHttpMessageConverter：                   负责读取和写入 xml 中javax.xml.transform.Source定义的数据；</li><li>Jaxb2RootElementHttpMessageConverter:  负责读取和写入xml 标签格式的数据；</li><li>AtomFeedHttpMessageConverter:              负责读取和写入Atom格式的数据；</li><li>RssChannelHttpMessageConverter:           负责读取和写入RSS格式的数据；<br>当使用@RequestBody和@ResponseBody注解时，RequestMappingHandlerAdapter就使用它们来进行读取或者写入相应格式的数据。<br>HttpMessageConverter匹配过程：<br><strong>@RequestBody注解时：</strong><br>根据Request对象header部分的Content-Type类型，逐一匹配合适的HttpMessageConverter来读取数据；<br>spring 3.1源代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">1. &quot;font-family:Microsoft YaHei;&quot;&gt;private Object readWithMessageConverters(MethodParameter methodParam, HttpInputMessage inputMessage, Class paramType)  </div><div class="line">  2. throws Exception &#123;  </div><div class="line">  3.         MediaType contentType = inputMessage.getHeaders().getContentType();  </div><div class="line">  4. if (contentType == null) &#123;  </div><div class="line">  5.             StringBuilder builder = new StringBuilder(ClassUtils.getShortName(methodParam.getParameterType()));  </div><div class="line">  6.             String paramName = methodParam.getParameterName();  </div><div class="line">  7. if (paramName != null) &#123;  </div><div class="line">  8.                 builder.append(&apos; &apos;);  </div><div class="line">  9.                 builder.append(paramName);  </div><div class="line">  10.             &#125;  </div><div class="line">  11. throw new HttpMediaTypeNotSupportedException(  </div><div class="line">  12. &quot;Cannot extract parameter (&quot; + builder.toString() + &quot;): no Content-Type found&quot;);  </div><div class="line">  13.         &#125;  </div><div class="line">  14.         List allSupportedMediaTypes = new ArrayList();  </div><div class="line">  15. if (this.messageConverters != null) &#123;  </div><div class="line">  16. for (HttpMessageConverter messageConverter : this.messageConverters) &#123;  </div><div class="line">  17.                 allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());  </div><div class="line">  18. if (messageConverter.canRead(paramType, contentType)) &#123;  </div><div class="line">  19. if (logger.isDebugEnabled()) &#123;  </div><div class="line">  20.                         logger.debug(&quot;Reading [&quot; + paramType.getName() + &quot;] as \&quot;&quot; + contentType  </div><div class="line">  21.                                 +&quot;\&quot; using [&quot; + messageConverter + &quot;]&quot;);  </div><div class="line">  22.                     &#125;  </div><div class="line">  23. return messageConverter.read(paramType, inputMessage);  </div><div class="line">  24.                 &#125;  </div><div class="line">  25.             &#125;  </div><div class="line">  26.         &#125;  </div><div class="line">  27. throw new HttpMediaTypeNotSupportedException(contentType, allSupportedMediaTypes);  </div><div class="line">  28.     &#125;</div></pre></td></tr></table></figure><p><strong>@ResponseBody注解时：</strong> 根据Request对象header部分的Accept属性（逗号分隔），逐一按accept中的类型，去遍历找到能处理的HttpMessageConverter；<br>源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">1. &quot;font-family:Microsoft YaHei;&quot;&gt;private void writeWithMessageConverters(Object returnValue,  </div><div class="line">2.                 HttpInputMessage inputMessage, HttpOutputMessage outputMessage)  </div><div class="line">3. throws IOException, HttpMediaTypeNotAcceptableException &#123;  </div><div class="line">4.             List acceptedMediaTypes = inputMessage.getHeaders().getAccept();  </div><div class="line">5. if (acceptedMediaTypes.isEmpty()) &#123;  </div><div class="line">6.                 acceptedMediaTypes = Collections.singletonList(MediaType.ALL);  </div><div class="line">7.             &#125;  </div><div class="line">8.             MediaType.sortByQualityValue(acceptedMediaTypes);  </div><div class="line">9.             Class returnValueType = returnValue.getClass();  </div><div class="line">10.             List allSupportedMediaTypes = new ArrayList();  </div><div class="line">11. if (getMessageConverters() != null) &#123;  </div><div class="line">12. for (MediaType acceptedMediaType : acceptedMediaTypes) &#123;  </div><div class="line">13. for (HttpMessageConverter messageConverter : getMessageConverters()) &#123;  </div><div class="line">14. if (messageConverter.canWrite(returnValueType, acceptedMediaType)) &#123;  </div><div class="line">15.                             messageConverter.write(returnValue, acceptedMediaType, outputMessage);  </div><div class="line">16. if (logger.isDebugEnabled()) &#123;  </div><div class="line">17.                                 MediaType contentType = outputMessage.getHeaders().getContentType();  </div><div class="line">18. if (contentType == null) &#123;  </div><div class="line">19.                                     contentType = acceptedMediaType;  </div><div class="line">20.                                 &#125;  </div><div class="line">21.                                 logger.debug(&quot;Written [&quot; + returnValue + &quot;] as \&quot;&quot; + contentType +  </div><div class="line">22. &quot;\&quot; using [&quot; + messageConverter + &quot;]&quot;);  </div><div class="line">23.                             &#125;  </div><div class="line">24. this.responseArgumentUsed = true;  </div><div class="line">25. return;  </div><div class="line">26.                         &#125;  </div><div class="line">27.                     &#125;  </div><div class="line">28.                 &#125;  </div><div class="line">29. for (HttpMessageConverter messageConverter : messageConverters) &#123;  </div><div class="line">30.                     allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());  </div><div class="line">31.                 &#125;  </div><div class="line">32.             &#125;  </div><div class="line">33. throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);  </div><div class="line">34.         &#125;</div></pre></td></tr></table></figure><p>补充：<br>MappingJacksonHttpMessageConverter调用了objectMapper.writeValue(OutputStream stream, Object)方法，使用@ResponseBody注解返回的对象就传入Object参数内。若返回的对象为已经格式化好的json串时，不使用@RequestBody注解，而应该这样处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、response.setContentType(&quot;application/json; charset=UTF-8&quot;);</div><div class="line"></div><div class="line">2、response.getWriter().print(jsonStr);</div></pre></td></tr></table></figure><p>直接输出到body区，然后的视图为void。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot; title=&quot;摘要：&quot;&gt;&lt;/a&gt;摘要：&lt;/h1&gt;&lt;p&gt;前段时间项目中用到了REST风格来开发程序，但是当用POST、PUT模式提交数据时，发现服务器端接受不到提交的数据（服务器端参数绑定没有加任何注解），查看了提交方式为application/json， 而且服务器端通过request.getReader() 打出的数据里确实存在浏览器提交的数据。为了找出原因，便对参数绑定&lt;br&gt;@RequestParam&lt;br&gt;@RequestBody&lt;br&gt;@RequestHeader&lt;br&gt;@PathVariable&lt;br&gt;进行了研究，同时也看了一下HttpMessageConverter的相关内容，在此一并总结。&lt;/p&gt;
&lt;p&gt;此篇文章虽然也是摘抄自网络，但是也解决了最近一来我得困惑，对这些注解的选用，同样的我也在继续的研究中!&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://jiaxiaoxuan.top/categories/Spring/"/>
    
    
      <category term="SpringMvc" scheme="http://jiaxiaoxuan.top/tags/SpringMvc/"/>
    
  </entry>
  
  <entry>
    <title>swagger注解说明</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/swagger%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/swagger注解说明/</id>
    <published>2017-09-24T09:58:04.000Z</published>
    <updated>2018-01-02T15:02:42.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用到的注解有："><a href="#常用到的注解有：" class="headerlink" title="常用到的注解有："></a>常用到的注解有：</h1><p>  ● Api<br>  ● ApiModel<br>  ● ApiModelProperty<br>  ● ApiOperation<br>  ● ApiParam<br>  ● ApiResponse<br>  ● ApiResponses<br>  ● ResponseHeader<br>  <a id="more"></a></p><h1 id="1-api标记"><a href="#1-api标记" class="headerlink" title="1. api标记"></a>1. api标记</h1><p>Api 用在类上，说明该类的作用。可以标记一个Controller类做为swagger 文档资源，使用方式：</p><pre><code>@Api(value = &quot;/user&quot;, description = &quot;Operations about user&quot;)</code></pre><p>与Controller注解并列使用。 属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>url的路径值</td></tr><tr><td>tags</td><td>如果设置这个值、value的值会被覆盖</td></tr><tr><td>description</td><td>对api资源的描述</td></tr><tr><td>basePath</td><td>基本路径可以不配置</td></tr><tr><td>position</td><td>如果配置多个Api 想改变显示的顺序位置</td></tr><tr><td>produces</td><td>For example, “application/json, application/xml”</td></tr><tr><td>consumes</td><td>For example, “application/json, application/xml”</td></tr><tr><td>protocols</td><td>Possible values: http, https, ws, wss.</td></tr><tr><td>authorizations</td><td>高级特性认证时配置</td></tr><tr><td>hidden</td><td>配置为true 将在文档中隐藏</td></tr></tbody></table><p>在SpringMvc中的配置如下：  </p><pre><code>@Controller    @RequestMapping(value = &quot;/api/pet&quot;, produces = {APPLICATION_JSON_VALUE, APPLICATION_XML_VALUE})  @Api(value = &quot;/pet&quot;, description = &quot;Operations about pets&quot;)  public class PetController {}</code></pre><h1 id="2-ApiOperation标记"><a href="#2-ApiOperation标记" class="headerlink" title="2. ApiOperation标记"></a>2. ApiOperation标记</h1><p>ApiOperation：用在方法上，说明方法的作用，每一个url资源的定义,使用方式：</p><pre><code>@ApiOperation(value = &quot;Find purchase order by ID&quot;,notes = &quot;For valid response try integer IDs with value &lt;= 5 or &gt; 10. Other values will generated exceptions&quot;,response = Order,          tags = {&quot;Pet Store&quot;})</code></pre><p>与Controller中的方法并列使用。</p><p>属性配置：  </p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>url的路径值</td></tr><tr><td>tags</td><td>如果设置这个值、value的值会被覆盖</td></tr><tr><td>description</td><td>对api资源的描述</td></tr><tr><td>basePath</td><td>基本路径可以不配置</td></tr><tr><td>position</td><td>如果配置多个Api 想改变显示的顺序位置</td></tr><tr><td>produces</td><td>For example, “application/json, application/xml”</td></tr><tr><td>consumes</td><td>For example, “application/json, application/xml”</td></tr><tr><td>protocols</td><td>Possible values: http, https, ws, wss.</td></tr><tr><td>authorizations</td><td>高级特性认证时配置</td></tr><tr><td>hidden</td><td>配置为true 将在文档中隐藏</td></tr><tr><td>response</td><td>返回的对象</td></tr><tr><td>responseContainer</td><td>这些对象是有效的 “List”, “Set” or “Map”.，其他无效</td></tr><tr><td>httpMethod</td><td>“GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH”</td></tr><tr><td>code</td><td>http的状态码 默认 200</td></tr><tr><td>extensions</td><td>扩展属性</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><pre><code>@RequestMapping(value = &quot;/order/{orderId}&quot;, method = GET)@ApiOperation(    value = &quot;Find purchase order by ID&quot;,    notes = &quot;For valid response try integer IDs with value &lt;= 5 or &gt; 10. Other values will generated exceptions&quot;,    response = Order.class,    tags = { &quot;Pet Store&quot; })    public ResponseEntity getOrderById(@PathVariable(&quot;orderId&quot;) String orderId)      throws NotFoundException {    Order order = storeData.get(Long.valueOf(orderId));    if (null != order) {    return ok(order);        } else {    throw new NotFoundException(404, &quot;Order not found&quot;);    }}</code></pre><h1 id="3-ApiParam标记"><a href="#3-ApiParam标记" class="headerlink" title="3. ApiParam标记"></a>3. ApiParam标记</h1><p>ApiParam请求属性,使用方式：  </p><pre><code>public ResponseEntity createUser(@RequestBody @ApiParam(value = &quot;Created user object&quot;, required = true)  User user)</code></pre><p>与Controller中的方法并列使用。</p><p>属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>name</td><td>属性名称</td></tr><tr><td>value</td><td>属性值</td></tr><tr><td>defaultValue</td><td>默认属性值</td></tr><tr><td>allowableValues</td><td>可以不配置</td></tr><tr><td>required</td><td>是否属性必填</td></tr><tr><td>access</td><td>不过多描述</td></tr><tr><td>allowMultiple</td><td>默认为false</td></tr><tr><td>hidden</td><td>隐藏该属性</td></tr><tr><td>example</td><td>举例子</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><pre><code>public ResponseEntity getOrderById(@ApiParam(value = &quot;ID of pet that needs to be fetched&quot;, allowableValues = &quot;range[1,5]&quot;, required = true)@PathVariable(&quot;orderId&quot;) String orderId)</code></pre><h1 id="4-ApiResponse"><a href="#4-ApiResponse" class="headerlink" title="4. ApiResponse"></a>4. ApiResponse</h1><p>ApiResponse：响应配置，使用方式：</p><pre><code>@ApiResponse(code = 400, message = &quot;Invalid user supplied&quot;)</code></pre><p>与Controller中的方法并列使用。 属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>code</td><td>http的状态码</td></tr><tr><td>message</td><td>描述</td></tr><tr><td>response</td><td>默认响应类 Void</td></tr><tr><td>reference</td><td>参考ApiOperation中配置</td></tr><tr><td>responseHeaders</td><td>参考 ResponseHeader 属性配置说明</td></tr><tr><td>responseContainer</td><td>参考ApiOperation中配置</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><pre><code>@RequestMapping(value = &quot;/order&quot;, method = POST)@ApiOperation(value = &quot;Place an order for a pet&quot;, response = Order.class)  @ApiResponses({ @ApiResponse(code = 400, message = &quot;Invalid Order&quot;) })  public ResponseEntity placeOrder(@ApiParam(value = &quot;order placed for purchasing the pet&quot;, required = true) Order order) {storeData.add(order);return ok(&quot;&quot;);}</code></pre><h1 id="5-ApiResponses"><a href="#5-ApiResponses" class="headerlink" title="5. ApiResponses"></a>5. ApiResponses</h1><p>ApiResponses：响应集配置，使用方式：</p><pre><code>@ApiResponses({ @ApiResponse(code = 400, message = &quot;Invalid Order&quot;) })</code></pre><p>与Controller中的方法并列使用。 属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>多个ApiResponse配置</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value = &quot;/order&quot;, method = POST)   </div><div class="line">@ApiOperation(value = &quot;Place an order for a pet&quot;, response = Order.class)</div><div class="line">@ApiResponses(&#123; @ApiResponse(code = 400, message = &quot;Invalid Order&quot;) &#125;)  </div><div class="line">public ResponseEntity placeOrder(</div><div class="line">@ApiParam(value = &quot;order placed for purchasing the pet&quot;, required = true) Order order) &#123;</div><div class="line">storeData.add(order);</div><div class="line">return ok(&quot;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="6-ResponseHeader"><a href="#6-ResponseHeader" class="headerlink" title="6. ResponseHeader"></a>6. ResponseHeader</h1><p>响应头设置，使用方法</p><pre><code>@ResponseHeader(name=&quot;head1&quot;,description=&quot;response head conf&quot;)</code></pre><p>与Controller中的方法并列使用。 属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>name</td><td>响应头名称</td></tr><tr><td>description</td><td>头描述</td></tr><tr><td>response</td><td>默认响应类 Void</td></tr><tr><td>responseContainer</td><td>参考ApiOperation中配置</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><pre><code>@ApiModel(description = &quot;群组&quot;)</code></pre><h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h1><p>● @ApiImplicitParams：用在方法上包含一组参数说明；<br>● @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面</p><pre><code>○ paramType：参数放在哪个地方  ○ name：参数代表的含义  ○ value：参数名称  ○ dataType： 参数类型，有String/int，无用  ○ required ： 是否必要  ○ defaultValue：参数的默认值  </code></pre><p>● @ApiResponses：用于表示一组响应；<br>● @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息；</p><pre><code>○ code： 响应码(int型)，可自定义  ○ message：状态码对应的响应信息  </code></pre><p>● @ApiModel：描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候；<br>● @ApiModelProperty：描述一个model的属性。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用到的注解有：&quot;&gt;&lt;a href=&quot;#常用到的注解有：&quot; class=&quot;headerlink&quot; title=&quot;常用到的注解有：&quot;&gt;&lt;/a&gt;常用到的注解有：&lt;/h1&gt;&lt;p&gt;  ● Api&lt;br&gt;  ● ApiModel&lt;br&gt;  ● ApiModelProperty&lt;br&gt;  ● ApiOperation&lt;br&gt;  ● ApiParam&lt;br&gt;  ● ApiResponse&lt;br&gt;  ● ApiResponses&lt;br&gt;  ● ResponseHeader&lt;br&gt;
    
    </summary>
    
      <category term="swagger" scheme="http://jiaxiaoxuan.top/categories/swagger/"/>
    
    
      <category term="swagger" scheme="http://jiaxiaoxuan.top/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>swagger简明教程</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/swagger%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/swagger简明教程/</id>
    <published>2017-09-24T09:24:09.000Z</published>
    <updated>2018-01-02T15:02:41.961Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://my.oschina.net/dlam/blog/808315" target="_blank" rel="noopener">https://my.oschina.net/dlam/blog/808315</a>  </p><h1 id="1：认识Swagger"><a href="#1：认识Swagger" class="headerlink" title="1：认识Swagger"></a>1：认识Swagger</h1><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。<br> 作用：  </p><pre><code>1. 接口的文档在线自动生成。  2. 功能测试。  </code></pre><p>Swagger是一组开源项目，其中主要要项目如下：  </p><a id="more"></a><ol><li>Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。  </li><li>Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。  </li><li>Swagger-js: 用于JavaScript的Swagger实现。  </li><li>Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。  </li><li>Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。  </li><li>Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。  </li></ol><h1 id="2：Maven-配置"><a href="#2：Maven-配置" class="headerlink" title="2：Maven 配置"></a>2：Maven 配置</h1><p>版本号请根据实际情况自行更改。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt; 2.2.2&lt;/version&gt;&lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;io.springfox &lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt; 2.2.2 &lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="3：创建Swagger2配置类"><a href="#3：创建Swagger2配置类" class="headerlink" title="3：创建Swagger2配置类"></a>3：创建Swagger2配置类</h1><p>在Application.java同级创建Swagger2的配置类Swagger2    </p><pre><code>package com.swaggerTest;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Swagger2配置类 * 在与spring boot集成时，放在与Application.java同级的目录下。 * 通过@Configuration注解，让Spring来加载该类配置。 * 再通过@EnableSwagger2注解来启用Swagger2。 */@Configuration@EnableSwagger2public class Swagger2 {    /**     * 创建API应用     * apiInfo() 增加API相关信息     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，     * 本例采用指定扫描的包路径来定义指定要建立API的目录。     *      * @return     */    @Bean    public Docket createRestApi() {        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.swaggerTest.controller&quot;))                .paths(PathSelectors.any())                .build();    }    /**     * 创建该API的基本信息（这些基本信息会展现在文档页面中）     * 访问地址：http://项目实际地址/swagger-ui.html     * @return     */    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)                .description(&quot;更多请关注http://www.baidu.com&quot;)                .termsOfServiceUrl(&quot;http://www.baidu.com&quot;)                .contact(&quot;sunf&quot;)                .version(&quot;1.0&quot;)                .build();    }}</code></pre><p>如上代码所示，通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。  </p><h1 id="4：添加文档内容"><a href="#4：添加文档内容" class="headerlink" title="4：添加文档内容"></a>4：添加文档内容</h1><p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，描述的主要来源是函数的命名，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。<br>Swagger使用的注解及其说明：<br>@Api：用在类上，说明该类的作用。<br>@ApiOperation：注解来给API增加方法说明。<br>@ApiImplicitParams : 用在方法上包含一组参数说明。<br>@ApiImplicitParam：用来注解来给方法入参增加说明。<br>@ApiResponses：用于表示一组响应<br>@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息<br>l   code：数字，例如400<br>l   message：信息，例如”请求参数没填好”<br>l   response：抛出异常的类<br>@ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）<br>l   @ApiModelProperty：描述一个model的属性  </p><p>==注意：@ApiImplicitParam的参数说明：==   </p><pre><code>paramType：指定参数放在哪个地方   header：请求参数放置于Request Header，使用@RequestHeader获取  query：请求参数放置于请求地址，使用@RequestParam获取  path：（用于restful接口）--&gt;请求参数的获取：@PathVariablebody：（不常用）    form（不常用）  name：参数名   dataType：参数类型   required：参数是否必须传 true | false  value：说明参数的意思   defaultValue：参数的默认值 </code></pre><p>例子：</p><pre><code>package com.swaggerTest.controller;import org.springframework.stereotype.Controller;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;/** * 一个用来测试swagger注解的控制器 * 注意@ApiImplicitParam的使用会影响程序运行，如果使用不当可能造成控制器收不到消息 *  * @author SUNF */@Controller@RequestMapping(&quot;/say&quot;)@Api(value = &quot;SayController|一个用来测试swagger注解的控制器&quot;)public class SayController {    @ResponseBody    @RequestMapping(value =&quot;/getUserName&quot;, method= RequestMethod.GET)    @ApiOperation(value=&quot;根据用户编号获取用户姓名&quot;, notes=&quot;test: 仅1和2有正确返回&quot;)    @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;userNumber&quot;, value = &quot;用户编号&quot;, required = true, dataType = &quot;Integer&quot;)    public String getUserName(@RequestParam Integer userNumber){        if(userNumber == 1){            return &quot;张三丰&quot;;        }        else if(userNumber == 2){            return &quot;慕容复&quot;;        }        else{            return &quot;未知&quot;;        }    }    @ResponseBody    @RequestMapping(&quot;/updatePassword&quot;)    @ApiOperation(value=&quot;修改用户密码&quot;, notes=&quot;根据用户id修改密码&quot;)    @ApiImplicitParams({        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;userId&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;),        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;password&quot;, value = &quot;旧密码&quot;, required = true, dataType = &quot;String&quot;),        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;newPassword&quot;, value = &quot;新密码&quot;, required = true, dataType = &quot;String&quot;)    })    public String updatePassword(@RequestParam(value=&quot;userId&quot;) Integer userId, @RequestParam(value=&quot;password&quot;) String password,             @RequestParam(value=&quot;newPassword&quot;) String newPassword){      if(userId &lt;= 0 || userId &gt; 2){          return &quot;未知的用户&quot;;      }      if(StringUtils.isEmpty(password) || StringUtils.isEmpty(newPassword)){          return &quot;密码不能为空&quot;;      }      if(password.equals(newPassword)){          return &quot;新旧密码不能相同&quot;;      }      return &quot;密码修改成功!&quot;;    }}</code></pre><p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a><br><img src="/images/swagger1.png" alt="image"><br>如上图，可以看到暴漏出来的控制器信息，点击进入可以看到详细信息。<br><img src="/images/swagger2.png" alt="image"><br>两个注意点：<br><strong>1.  paramType会直接影响程序的运行期，如果paramType与方法参数获取使用的注解不一致，会直接影响到参数的接收。</strong><br>例如：<br><img src="/images/swagger3.png" alt="image"><br>使用Sawgger UI进行测试，接收不到！<br><img src="/images/swagger4.png" alt="image"><br><strong>2.  还有一个需要注意的地方：</strong><br>Conntroller中定义的方法必须在@RequestMapper中显示的指定RequestMethod类型，否则SawggerUi会默认为全类型皆可访问， API列表中会生成多条项目。<br><img src="/images/swagger5.png" alt="image"><br>如上图：updatePassword()未指定requestMethod，结果生成了7条API信息。所以如果没有特殊需求，建议根据实际情况加上requestMethod。<br><img src="/images/swagger6.png" alt="image"> </p><h1 id="5：Swagger-UI面板说明"><a href="#5：Swagger-UI面板说明" class="headerlink" title="5：Swagger UI面板说明"></a>5：Swagger UI面板说明</h1><p><img src="/images/swagger7.png" alt="image"> </p><h1 id="6：参考"><a href="#6：参考" class="headerlink" title="6：参考"></a>6：参考</h1><p><a href="http://blog.didispace.com/springbootswagger2/" target="_blank" rel="noopener">http://blog.didispace.com/springbootswagger2/</a><br><a href="http://blog.csdn.net/jia20003/article/details/50700736" target="_blank" rel="noopener">http://blog.csdn.net/jia20003/article/details/50700736</a><br>Swagger官网 ：<a href="http://swagger.io/" target="_blank" rel="noopener">http://swagger.io/</a><br>Spring Boot &amp; Swagger UI ： <a href="http://fruzenshtein.com/spring-boot-swagger-ui/" target="_blank" rel="noopener">http://fruzenshtein.com/spring-boot-swagger-ui/</a></p><h2 id="Github：https-github-com-swagger-api-swagger-core-wiki-Annotations"><a href="#Github：https-github-com-swagger-api-swagger-core-wiki-Annotations" class="headerlink" title="Github：https://github.com/swagger-api/swagger-core/wiki/Annotations"></a>Github：<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-core/wiki/Annotations</a></h2><h1 id="7：接收对象传参的例子"><a href="#7：接收对象传参的例子" class="headerlink" title="7：接收对象传参的例子"></a>7：接收对象传参的例子</h1><p>在POJO上增加<br>    package com.zhongying.api.model.base;</p><pre><code>import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * 医生对象模型，不要使用该类 * @author SUNF * */@ApiModel(value=&quot;医生对象模型&quot;)public class DemoDoctor{    @ApiModelProperty(value=&quot;id&quot; ,required=true)    private Integer id;    @ApiModelProperty(value=&quot;医生姓名&quot; ,required=true)    private String name;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public String toString() {        return &quot;DemoDoctor [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;    }}</code></pre><p>==注意： 在后台采用对象接收参数时，Swagger自带的工具采用的是JSON传参，    测试时需要在参数上加入@RequestBody,正常运行采用form或URL提交时候请删除。==   </p><pre><code>package com.zhongying.api.controller.app;import java.util.ArrayList;import java.util.List;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.github.pagehelper.PageInfo;import com.zhongying.api.exception.HttpStatus401Exception;import com.zhongying.api.model.base.DemoDoctor;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;/** * 医生类（模拟） * @author SUNF */@RequestMapping(&quot;/api/v1&quot;)@Controller@Api(value = &quot;DoctorTestController-医生信息接口模拟&quot;)public class DoctorTestController {    /**     * 添加医生     *      * 在使用对象封装参数进行传参时，需要在该对象添加注解，将其注册到swagger中     * @link com.zhongying.api.model.base.DemoDoctor     *      * 注意： 在后台采用对象接收参数时，Swagger自带的工具采用的是JSON传参，     *     测试时需要在参数上加入@RequestBody,正常运行采用form或URL提交时候请删除。     *          * @param doctor 医生类对象     * @return     * @throws Exception     */    @ResponseBody    @RequestMapping(value=&quot;/doctor&quot;,  method= RequestMethod.POST )    @ApiOperation(value=&quot;添加医生信息&quot;, notes=&quot;&quot;)    public String addDoctor(@RequestBody DemoDoctor doctor) throws Exception{        if(null == doctor || doctor.getId() == null){            throw new HttpStatus401Exception(&quot;添加医生失败&quot;,&quot;DT3388&quot;,&quot;未知原因&quot;,&quot;请联系管理员&quot;);        }        try {          System.out.println(&quot;成功-----------&gt;&quot;+doctor.getName());          } catch (Exception e) {            throw new HttpStatus401Exception(&quot;添加医生失败&quot;,&quot;DT3388&quot;,&quot;未知原因&quot;,&quot;请联系管理员&quot;);        }        return doctor.getId().toString();    }    /**     * 删除医生     * @param doctorId 医生ID     * @return     */    @ResponseBody    @RequestMapping(value=&quot;/doctor/{doctorId}&quot;,  method= RequestMethod.DELETE )    @ApiOperation(value=&quot;删除医生信息&quot;, notes=&quot;&quot;)    @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;doctorId&quot;, value = &quot;医生ID&quot;, required = true, dataType = &quot;Integer&quot;)    public String deleteDoctor(@RequestParam Integer doctorId){        if(doctorId &gt; 2){            return &quot;删除失败&quot;;        }        return &quot;删除成功&quot;;    }    /**     * 修改医生信息     * @param doctorId 医生ID     * @param doctor 医生信息     * @return     * @throws HttpStatus401Exception     */    @ResponseBody    @RequestMapping(value=&quot;/doctor/{doctorId}&quot;,  method= RequestMethod.POST )    @ApiOperation(value=&quot;修改医生信息&quot;, notes=&quot;&quot;)    @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;doctorId&quot;, value = &quot;医生ID&quot;, required = true, dataType = &quot;Integer&quot;)    public String updateDoctor(@RequestParam Integer doctorId, @RequestBody DemoDoctor doctor) throws HttpStatus401Exception{        if(null == doctorId || null == doctor){            throw new HttpStatus401Exception(&quot;修改医生信息失败&quot;,&quot;DT3391&quot;,&quot;id不能为空&quot;,&quot;请修改&quot;);        }        if(doctorId &gt; 5 ){            throw new HttpStatus401Exception(&quot;医生不存在&quot;,&quot;DT3392&quot;,&quot;错误的ID&quot;,&quot;请更换ID&quot;);        }        System.out.println(doctorId);        System.out.println(doctor);        return &quot;修改成功&quot;;    }    /**     * 获取医生详细信息     * @param doctorId 医生ID     * @return     * @throws HttpStatus401Exception     */    @ResponseBody    @RequestMapping(value=&quot;/doctor/{doctorId}&quot;,  method= RequestMethod.GET )    @ApiOperation(value=&quot;获取医生详细信息&quot;, notes=&quot;仅返回姓名..&quot;)    @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;doctorId&quot;, value = &quot;医生ID&quot;, required = true, dataType = &quot;Integer&quot;)    public DemoDoctor getDoctorDetail(@RequestParam Integer doctorId) throws HttpStatus401Exception{        System.out.println(doctorId);        if(null == doctorId){            throw new HttpStatus401Exception(&quot;查看医生信息失败&quot;,&quot;DT3390&quot;,&quot;未知原因&quot;,&quot;请联系管理员&quot;);        }        if(doctorId &gt; 3){            throw new HttpStatus401Exception(&quot;医生不存在&quot;,&quot;DT3392&quot;,&quot;错误的ID&quot;,&quot;请更换ID&quot;);        }        DemoDoctor doctor = new DemoDoctor();        doctor.setId(1);        doctor.setName(&quot;测试员&quot;);        return doctor;    }    /**     * 获取医生列表     * @param pageIndex 当前页数     * @param pageSize 每页记录数     * @param request     * @return     * @throws HttpStatus401Exception     */    @ResponseBody    @RequestMapping(value=&quot;/doctor&quot;,  method= RequestMethod.GET )    @ApiOperation(value=&quot;获取医生列表&quot;, notes=&quot;目前一次全部取，不分页&quot;)    @ApiImplicitParams({        @ApiImplicitParam(paramType=&quot;header&quot;, name = &quot;token&quot;, value = &quot;token&quot;, required = true, dataType = &quot;String&quot;),        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;pageIndex&quot;, value = &quot;当前页数&quot;, required = false, dataType = &quot;String&quot;),        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;pageSize&quot;, value = &quot;每页记录数&quot;, required = true, dataType = &quot;String&quot;),    })    public PageInfo&lt;DemoDoctor&gt; getDoctorList(@RequestParam(value = &quot;pageIndex&quot;, required = false, defaultValue = &quot;1&quot;) Integer pageIndex,            @RequestParam(value = &quot;pageSize&quot;, required = false) Integer pageSize,            HttpServletRequest request) throws HttpStatus401Exception{        String token = request.getHeader(&quot;token&quot;);        if(null == token){            throw new HttpStatus401Exception(&quot;没有权限&quot;,&quot;SS8888&quot;,&quot;没有权限&quot;,&quot;请查看操作文档&quot;);        }        if(null == pageSize){            throw new HttpStatus401Exception(&quot;每页记录数不粗安在&quot;,&quot;DT3399&quot;,&quot;不存在pageSize&quot;,&quot;请查看操作文档&quot;);        }        DemoDoctor doctor1 = new DemoDoctor();        doctor1.setId(1);        doctor1.setName(&quot;测试员1&quot;);        DemoDoctor doctor2 = new DemoDoctor();        doctor2.setId(2);        doctor2.setName(&quot;测试员2&quot;);        List&lt;DemoDoctor&gt; doctorList = new ArrayList&lt;DemoDoctor&gt;();        doctorList.add(doctor1);        doctorList.add(doctor2);        return new PageInfo&lt;DemoDoctor&gt;(doctorList);    }}</code></pre><p>增加header:<br>现在很多请求需要在header增加额外参数，可以参考getDoctorList()的做法，使用request接收。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://my.oschina.net/dlam/blog/808315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.oschina.net/dlam/blog/808315&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;1：认识Swagger&quot;&gt;&lt;a href=&quot;#1：认识Swagger&quot; class=&quot;headerlink&quot; title=&quot;1：认识Swagger&quot;&gt;&lt;/a&gt;1：认识Swagger&lt;/h1&gt;&lt;p&gt;Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。&lt;br&gt; 作用：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 接口的文档在线自动生成。  
2. 功能测试。  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Swagger是一组开源项目，其中主要要项目如下：  &lt;/p&gt;
    
    </summary>
    
      <category term="swagger" scheme="http://jiaxiaoxuan.top/categories/swagger/"/>
    
    
      <category term="swagger" scheme="http://jiaxiaoxuan.top/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>maven详细介绍</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/maven%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/maven详细介绍/</id>
    <published>2017-09-24T08:36:11.000Z</published>
    <updated>2018-01-02T15:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;maven的用途、核心概念(Pom、Repositories、Artifact、Build Lifecycle、Goal)节点介绍、用法（Archetype意义及创建各种项目）、maven常用参数和命令以及简单故障排除、maven扩展（eclipse、cobertura、findbugs、插件开发）、maven配置。  </p><p>本文较长，可根据个人需要有选择性的查看，比如先看用法再回过头来看核心概念。  </p><a id="more"></a><h1 id="1、maven的用途"><a href="#1、maven的用途" class="headerlink" title="1、maven的用途"></a>1、maven的用途</h1><pre><code>1.maven是一个项目构建和管理的工具，提供了帮助管理构建、文档、报告、依赖、scms、发布、分发的方法。    2.可以方便的编译代码、进行依赖管理、管理二进制库等等。  3.maven的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性  4.利用maven自身及其插件还可以获得代码检查报告、单元测试覆盖率、实现持续集成等等。</code></pre><h1 id="2、maven的核心概念介绍"><a href="#2、maven的核心概念介绍" class="headerlink" title="2、maven的核心概念介绍"></a>2、maven的核心概念介绍</h1><h2 id="2-1-Pom"><a href="#2-1-Pom" class="headerlink" title="2.1 Pom"></a>2.1 Pom</h2><p>1.pom是指project object&nbsp;Model(项目对象文档模型)。pom是一个xml，在maven2为pom.xml。是maven工作的基础，在执行task或者goal时，maven会去项目根目录下读取pom.xml获得需要的配置信息。 </p><p>2.pom文件中包含了项目的信息和mave&nbsp;build项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和goal、build选项等等pom是可以继承的，通常对于一个大型的项目或是多个module的情况，子模块的pom需要指定父模块的pom。</p><pre><code>pom文件中节点解释如下：1. project pom文件的顶级元素  2. modelVersion 所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。除非maven开发者升级模板，否则不需要修改    3. groupId 是项目创建团体或组织的唯一标志符，通常是域名倒写，如groupId  org.apache.maven.plugins就是为所有maven插件预留的  4. artifactId 是项目artifact唯一的基地址名  5. packaging artifact打包的方式，如jar、war、ear等等。默认为jar。这个不仅表示项目最终产生何种后缀的文件，也表示build过程使用什么样的.6. version artifact的版本，通常能看见为类似0.0.1-SNAPSHOT，其中SNAPSHOT表示项目开发中，为开发版本  7. name 表示项目的展现名，在maven生成的文档中使用  8. url表示项目的地址，在maven生成的文档中使用  9. description 表示项目的描述，在maven生成的文档中使用  10. dependencies表示依赖，在子节点dependencies中添加具体依赖的groupId artifactId和version  11. build 表示build配置  12. parent 表示父pom  </code></pre><p>==其中groupId:artifactId:version唯一确定了一个artifact==</p><h2 id="2-2-Artifact"><a href="#2-2-Artifact" class="headerlink" title="2.2 Artifact"></a>2.2 Artifact</h2><p>这个有点不好解释，大致说就是一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId:artifactId:version组成的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(见Repository)中   </p><h2 id="2-3-Repositories"><a href="#2-3-Repositories" class="headerlink" title="2.3 Repositories"></a>2.3 Repositories</h2><ol><li>Repositories是用来存储Artifact的。如果说我们的项目产生的Artifact是一个个小工具，那么Repositories就是一个仓库，里面有我们自己创建的工具，也可以储存别人创建的工具，我们在项目中需要使用某种工具时，在pom中声明dependency，编译代码时就会根据dependency去下载工具（Artifact），供自己使用。</li><li>对于自己的项目完成后可以通过mvn&nbsp;install命令将项目放到仓库（Repositories）中。  </li><li>仓库分为本地仓库和远程仓库，远程仓库是指远程服务器上用于存储Artifact的仓库，本地仓库是指本机存储Artifact的仓库，对于windows机器本地仓库地址为系统用户的.m2/repository下面。对于需要的依赖，在pom中添加dependency即可，可以在maven的仓库中搜索：<a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a><h2 id="2-4-Build-Lifecycle"><a href="#2-4-Build-Lifecycle" class="headerlink" title="2.4 Build Lifecycle"></a>2.4 Build Lifecycle</h2>是指一个项目build的过程。maven的Build&nbsp;Lifecycle分为三种，分别为default（处理项目的部署）、clean（处理项目的清理）、site（处理项目的文档生成）,Build Lifecycle是由phases构成的，下面重点介绍default Build Lifecycle几个重要的phase    </li></ol><pre><code>Xml代码1. validate 验证项目是否正确以及必须的信息是否可用  2. compile 编译源代码  3. test 测试编译后的代码，即执行单元测试代码  4. package 打包编译后的代码，在target目录下生成package文件  5. integration-test 处理package以便需要时可以部署到集成测试环境  6. verify 检验package是否有效并且达到质量标准  7. install 安装package到本地仓库，方便本地其它项目使用  8. deploy 部署，拷贝最终的package到远程仓库和替他开发这或项目共享，在集成或发布环境完成  </code></pre><p>以上的phase是有序的（注意实际两个相邻phase之间还有其他phase被省略，完整phase见lifecycle），下面一个phase的执行必须在上一个phase完成后<br>若直接以某一个phase为goal，将先执行完它之前的phase，如mvn install<br>将会先validate、compile、test、package、integration-test、verify最后再执行install phase</p><h2 id="2-5-Goal"><a href="#2-5-Goal" class="headerlink" title="2.5 Goal"></a>2.5 Goal</h2><p>goal代表一个特定任务<br>A goal represents a specific task (finer than a build phase) which contributes to the building and managing of a project.  </p><p>mvn package<br>&nbsp;&nbsp;&nbsp;表示打包的任务，通过上面的介绍我们知道，这个任务的执行会先执行package phase之前的phase<br>mvn deploy<br>&nbsp;&nbsp;&nbsp;表示部署的任务<br>mven clean install<br>&nbsp;&nbsp;&nbsp;则表示先执行clean的phase（包含其他子phase），再执行install的phase。</p><h1 id="3、maven用法"><a href="#3、maven用法" class="headerlink" title="3、maven用法"></a>3、maven用法</h1><p> 主要讲下Archetype（原型）以及几种常用项目的创建<br> maven创建项目是根据Archetype（原型）创建的。下面先介绍下Archetype</p><h2 id="3-1-Archetype"><a href="#3-1-Archetype" class="headerlink" title="3.1 Archetype"></a>3.1 Archetype</h2><ul><li><p>1.原型对于项目的作用就相当于模具对于工具的作用，我们想做一个锤子，将铁水倒入模具成型后，稍加修改就可以了。</p></li><li><p>2.类似我们可以根据项目类型的需要使用不同的Archetype创建项目。通过Archetype我们可以快速标准的创建项目。利用Archetype创建完项目后都有标准的文件夹目录结构。</p></li><li><p>3.既然Archetype相当于模具，那么当然可以自己再造模具了啊，创建Archetype。下面介绍利用maven自带的集中Archetype创建项目。创建项目的goal为mvn archetype:generate，并且指定archetypeArtifactId，其中archetypeArtifactId见maven自带的archetypeArtifactId</p></li></ul><h2 id="3-2-quick-start工程"><a href="#3-2-quick-start工程" class="headerlink" title="3.2 quick start工程"></a>3.2 quick start工程</h2><p>创建一个简单的quick start项目，指定 -DarchetypeArtifactId为maven-archetype-quickstart，如下命令</p><ol><li>mvn archetype:generate -DgroupId=com.trinea.maven.test -DartifactId=maven-quickstart -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false </li></ol><p>其中DgroupId指定groupId，DartifactId指定artifactId，DarchetypeArtifactId指定ArchetypeId，<br>DinteractiveMode表示是否使用交互模式，交互模式会让用户填写版本信息之类的，非交互模式采用默认值<br>这样我们便建好了一个简单的maven项目，目录结构如下：<br><img src="/images/maven1.jpeg" alt="image"><br>现在我们可以利用2.4的build Lifecycle进行一些操作，先命令行到工程根目录下<br>编译 mvn  compile<br>打包 mvn package，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件<br>打包并安装到本地仓库mvn  install，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。  </p><h2 id="3-3-web工程"><a href="#3-3-web工程" class="headerlink" title="3.3 web工程"></a>3.3 web工程</h2><p>创建一个简单的web项目，只需要修 -DarchetypeArtifactId为maven-archetype-webapp即可，如下命令</p><pre><code>Java代码 1. mvn archetype:generate -DgroupId=com.trinea.maven.web.test -DartifactId=maven-web -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false</code></pre><p><img src="/images/maven2.jpeg" alt="image"><br>其他：<br>src\main\resources文件夹是用来存放资源文件的，maven工程默认没有resources文件夹，如果我们需要用到类似log4j.properties这样的配置文件，就需要在src\main文件夹下新建resources文件夹，并将log4j.properties放入其中。<br>test需要用到资源文件，类似放到src\test下<br>对于apache的log4j没有log4j.properties文件或是目录错误，会报如下异常</p><pre><code>Xml代码 1. log4j:WARN No appenders could be found for logger (org.apache.commons.httpclient.HttpClient).  2. log4j:WARN Please initialize the log4j system properly.  </code></pre><h1 id="4、maven常用参数和命令"><a href="#4、maven常用参数和命令" class="headerlink" title="4、maven常用参数和命令"></a>4、maven常用参数和命令</h1><p>主要介绍maven常用参数和命令以及简单故障排除  </p><h2 id="4-1-mvn常用参数"><a href="#4-1-mvn常用参数" class="headerlink" title="4.1 mvn常用参数"></a>4.1 mvn常用参数</h2><p>mvn -e 显示详细错误<br>mvn -U 强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）<br>mvn -o 运行offline模式，不联网更新依赖<br>mvn -N仅在当前项目模块执行命令，关闭reactor<br>mvn -pl module_name在指定模块上执行命令<br>mvn -ff 在递归执行命令过程中，一旦发生错误就直接退出<br>mvn -Dxxx=yyy指定java全局属性<br>mvn -Pxxx引用profile xxx    </p><h2 id="4-2-首先是2-4-Build-Lifecycle中介绍的命令"><a href="#4-2-首先是2-4-Build-Lifecycle中介绍的命令" class="headerlink" title="4.2 首先是2.4 Build Lifecycle中介绍的命令"></a>4.2 首先是2.4 Build Lifecycle中介绍的命令</h2><p>mvn test-compile 编译测试代码<br>mvn test 运行程序中的单元测试<br>mvn  compile 编译项目<br>mvn package 打包，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件<br>mvn install 打包并安装到本地仓库，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。<br>每个phase都可以作为goal，也可以联合，如之前介绍的mvn clean install  </p><h2 id="4-3-maven-日用三板斧"><a href="#4-3-maven-日用三板斧" class="headerlink" title="4.3 maven 日用三板斧"></a>4.3 maven 日用三板斧</h2><p>mvn archetype:generate 创建maven项目<br>mvn package 打包，上面已经介绍过了<br>mvn package -Prelease打包，并生成部署用的包，比如deploy/*.tgz<br>mvn install 打包并安装到本地库<br>mvn eclipse:eclipse 生成eclipse项目文件<br>mvn eclipse:clean 清除eclipse项目文件<br>mvn site 生成项目相关信息的网站  </p><h2 id="4-4-maven插件常用参数"><a href="#4-4-maven插件常用参数" class="headerlink" title="4.4 maven插件常用参数"></a>4.4 maven插件常用参数</h2><p>mvn -Dwtpversion=2.0 指定maven版本<br>mvn -Dmaven.test.skip=true 如果命令包含了test phase，则忽略单元测试<br>mvn -DuserProp=filePath 指定用户自定义配置文件位置<br>mvn -DdownloadSources=true -Declipse.addVersionToProjectName=true   eclipse:eclipse 生成eclipse项目文件，尝试从仓库下载源代码，并且生成的项目包含模块版本（注意如果使用公用POM，上述的开关缺省已打开）  </p><h2 id="4-5-maven简单故障排除"><a href="#4-5-maven简单故障排除" class="headerlink" title="4.5 maven简单故障排除"></a>4.5 maven简单故障排除</h2><p>mvn -Dsurefire.useFile=false如果执行单元测试出错，用该命令可以在console输出失败的单元测试及相关信息<br>set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=256m   调大jvm内存和持久代，maven/jvm out of memory error<br>mvn -X maven log level设定为debug在运行<br>mvn debug 运行jpda允许remote debug<br>mvn –help 这个就不说了。。  </p><h1 id="5、maven扩展"><a href="#5、maven扩展" class="headerlink" title="5、maven扩展"></a>5、maven扩展</h1><p>maven常用插件配置和使用<br><img src="/images/maven3.png" alt="images"><br>参考资料：<br>Maven官方文档：<a href="http://maven.apache.org/guides/index.html" target="_blank" rel="noopener">http://maven.apache.org/guides/index.html</a><br>Maven权威指南：<a href="http://www.sonatype.com/books/maven-book/reference_zh/public-book.html" target="_blank" rel="noopener">http://www.sonatype.com/books/maven-book/reference_zh/public-book.html</a><br>maven安装：<a href="http://maven.apache.org/download.html" target="_blank" rel="noopener">http://maven.apache.org/download.html</a><br><a href="http://www.infoq.com/cn/search.action?queryString=maven%E5%AE%9E%E6%88%98&amp;searchOrder=relevance&amp;search=maven%E5%AE%9E%E6%88%98" target="_blank" rel="noopener">http://www.infoq.com/cn/search.action?queryString=maven%E5%AE%9E%E6%88%98&amp;searchOrder=relevance&amp;search=maven%E5%AE%9E%E6%88%98</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot; title=&quot;摘要：&quot;&gt;&lt;/a&gt;摘要：&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;maven的用途、核心概念(Pom、Repositories、Artifact、Build Lifecycle、Goal)节点介绍、用法（Archetype意义及创建各种项目）、maven常用参数和命令以及简单故障排除、maven扩展（eclipse、cobertura、findbugs、插件开发）、maven配置。  &lt;/p&gt;
&lt;p&gt;本文较长，可根据个人需要有选择性的查看，比如先看用法再回过头来看核心概念。  &lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="http://jiaxiaoxuan.top/categories/maven/"/>
    
    
      <category term="maven" scheme="http://jiaxiaoxuan.top/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>maven仓库的配置和意义</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/maven%E4%BB%93%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%84%8F%E4%B9%89/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/maven仓库的配置和意义/</id>
    <published>2017-09-24T08:03:38.000Z</published>
    <updated>2018-01-02T15:02:41.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Maven仓库"><a href="#什么是Maven仓库" class="headerlink" title="什么是Maven仓库"></a>什么是Maven仓库</h1><p>在不用Maven的时候，比如说以前我们用Ant构建项目，在项目目录下，往往会看到一个名为/lib的子目录，那里存放着各类第三方依赖jar文件，如log4j.jar，junit.jar等等。每建立一个项目，你都需要建立这样的一个/lib目录，然后复制一对jar文件，这是很明显的重复。重复永远是噩梦的起点，多个项目不共用相同的jar文件，不仅会造成磁盘资源的浪费，也使得版本的一致性管理变得困难。此外，如果你使用版本管理工具，如SVN（你没有使用版本管理工具？马上试试SVN吧，它能帮你解决很多头疼的问题），你需要将大量的jar文件提交到代码库里，可是版本管理工具在处理二进制文件方面并不出色。  </p><a id="more"></a><p>Maven仓库就是放置所有JAR文件（WAR，ZIP，POM等等）的地方，所有Maven项目可以从同一个Maven仓库中获取自己所需要的依赖JAR，这节省了磁盘资源。此外，由于Maven仓库中所有的JAR都有其自己的坐标，该坐标告诉Maven它的组ID，构件ID，版本，打包方式等等，因此Maven项目可以方便的进行依赖版本管理。你也不在需要提交JAR文件到SCM仓库中，你可以建立一个组织层次的Maven仓库，供所有成员使用。简言之，Maven仓库能帮助我们管理构件（主要是JAR）。   </p><h1 id="本地仓库-vs-远程仓库"><a href="#本地仓库-vs-远程仓库" class="headerlink" title="本地仓库 vs. 远程仓库"></a>本地仓库 vs. 远程仓库</h1><p>运行Maven的时候，Maven所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。<br>比如说，你的项目配置了junit-3.8的依赖，在你运行mvn test 的时候，Maven需要使用junit-3.8的jar文件，它首先根据坐标查找本地仓库，如果找到，就直接使用。如果没有，Maven会检查可用的远程仓库配置，然后逐个尝试这些远程仓库去下载junit-3.8的jar文件，如果远程仓库存在该文件，Maven会将其下载到本地仓库中，继而使用。如果尝试过所有远程仓库之后，Maven还是没能够下载到该文件，它就会报错。  </p><p>Maven缺省的本地仓库地址为${user.home}/.m2/repository。也就是说，一个用户会对应的拥有一个本地仓库。<br>你也可以自定义本地仓库的位置，修改${user.home}/.m2/settings.xml ：<br><strong>Xml代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. &lt;settings&gt;</div><div class="line">2.   ...   </div><div class="line">3. &lt;localRepository&gt;D:/java/repositorylocalRepository&gt;</div><div class="line">4.   ...   </div><div class="line">5. settings&gt;</div></pre></td></tr></table></figure></p><p>你还可以在运行时指定本地仓库位置： </p><pre><code>mvn clean install -Dmaven.repo.local=/home/juven/myrepo/  </code></pre><p>还有一点需要理解的是，当我们运行install的时候，Maven实际上是将项目生成的构件安装到了本地仓库，也就是说，只有install了之后，其它项目才能使用此项目生成的构件。   </p><p>了解了本地仓库，接着了解一下Maven缺省的远程仓库，即Maven中央仓库。   </p><p>安装好Maven之后，我们可以建立一个简单的项目，配置一些简单的依赖，然后运行mvn clean install，项目就构建好了。我们没有手工的去下载任何jar文件，这一切都是因为Maven中央仓库的存在，当Maven在本地仓库找不到需要的jar文件时，它会查找远程仓库，而一个原始的Maven安装就自带了一个远程仓库——Maven中央仓库。  </p><p>这个Maven中央仓库是在哪里定义的呢？在我的机器上，我安装了maven-2.0.10，我可以找到这个文件：${M2_HOME}/lib/maven-2.0.10-uber.jar，打开该文件，能找到超级POM：/org/apache/maven/project/pom-4.0.0.xml ，它是所有Maven POM的父POM，所有Maven项目继承该配置，你可以在这个POM中发现如下配置：<br><strong>Xml代码</strong></p><pre><code>1. &lt;repositories&gt;2. &lt;repository&gt;3. &lt;id&gt;centralid&gt;4. &lt;name&gt;Maven Repository Switchboardname&gt;5. &lt;layout&gt;defaultlayout&gt;6. &lt;url&gt;http://repo1.maven.org/maven2url&gt;7. &lt;snapshots&gt;8. &lt;enabled&gt;falseenabled&gt;9. snapshots&gt;10. repository&gt;11. repositories&gt;</code></pre><p>关于远程仓库的配置，下面的小节我会详细解释，这里我们只要知道，中央仓库的id为central，远程url地址为<a href="http://repo1.maven.org/maven2，它关闭了snapshot版本构件下载的支持。" target="_blank" rel="noopener">http://repo1.maven.org/maven2，它关闭了snapshot版本构件下载的支持。</a>  </p><h1 id="在POM中配置远程仓库"><a href="#在POM中配置远程仓库" class="headerlink" title="在POM中配置远程仓库"></a>在POM中配置远程仓库</h1><p>前面我们看到超级POM配置了ID为central的远程仓库，我们可以在POM中配置其它的远程仓库。这样做的原因有很多，比如你有一个局域网的远程仓库，使用该仓库能大大提高下载速度，继而提高构建速度，也有可能你依赖的一个jar在central中找不到，它只存在于某个特定的公共仓库，这样你也不得不添加那个远程仓库的配置。<br>这里我配置一个远程仓库指向中央仓库的中国镜像：  </p><pre><code>Xml代码1. &lt;project&gt;2. ...   3. &lt;repositories&gt;4. &lt;repository&gt;5.       &lt;id&gt;maven-net-cnid&gt;6.       &lt;name&gt;Maven China Mirrorname&gt;7.       &lt;url&gt;http://maven.net.cn/content/groups/public &lt;/url&gt;8.    &lt;releases&gt; 9.       &lt;enabled&gt;true&lt;/enabled&gt;10.   &lt;/releases&gt;11.   &lt;snapshots&gt;12.      &lt;enabled&gt;false&lt;/enabled&gt;13.   &lt;/snapshots&gt;14. &lt;/repository&gt;15. &lt;/repositories&gt;16. &lt;pluginRepositories&gt;17.   &lt;pluginRepository&gt;18.   &lt;id&gt;maven-net-cnid&gt;19.   &lt;name&gt;Maven China Mirror&lt;/name&gt;20.   &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt;21. &lt;releases&gt;22. &lt;enabled&gt;trueenabled&gt;23. &lt;/releases&gt;24. &lt;snapshots&gt;25. &lt;enabled&gt;falseenabled&gt;26. &lt;/snapshots&gt;27. &lt;/pluginRepository&gt;28. &lt;/pluginRepositories&gt;29.  ...   30. &lt;/project&gt;</code></pre><p>我们先看一下的配置，你可以在它下面添加多个，每个都有它唯一的ID，一个描述性的name，以及最重要的，远程仓库的url。此外，true告诉Maven可以从这个仓库下载releases版本的构件，而false告诉Maven不要从这个仓库下载snapshot版本的构件。禁止从公共仓库下载snapshot构件是推荐的做法，因为这些构件不稳定，且不受你控制，你应该避免使用。当然，如果你想使用局域网内组织内部的仓库，你可以激活snapshot的支持。<br>关于的更详细的配置及相关解释，请参考：<a href="http://www.sonatype.com/books/maven-book/reference_zh/apas02s08.html。" target="_blank" rel="noopener">http://www.sonatype.com/books/maven-book/reference_zh/apas02s08.html。</a><br>至于，这是配置Maven从什么地方下载插件构件（Maven的所有实际行为都由其插件完成）。该元素的内部配置和完全一样，不再解释。  </p><h1 id="在settings-xml中配置远程仓库"><a href="#在settings-xml中配置远程仓库" class="headerlink" title="在settings.xml中配置远程仓库"></a>在settings.xml中配置远程仓库</h1><p>我们知道了如何在POM中配置远程仓库，但考虑这样的情况：在一个公司内部，同时进行这3个项目，而且以后随着这几个项目的结束，越来越多的项目会开始；同时，公司内部建立一个Maven仓库。我们统一为所有这些项目配置该仓库，于是不得不为每个项目提供同样的配置。问题出现了，这是重复！其实我们可以做到只配置一次，在哪里配置呢？就是settings.xml,不过事情没有那么简单，不是简单的将POM中的及元素复制到settings.xml中就可以，setting.xml不直接支持这两个元素。但我们还是有一个并不复杂的解决方案，就是利用profile，如下：  </p><pre><code>Xml代码  1. &lt;settings&gt;  2.   ...     3. &lt;profiles&gt;  4. &lt;profile&gt;  5.    &lt;id&gt;dev&lt;/id&gt;  6. &lt;/profile&gt;  7. &lt;/profiles&gt;  8. &lt;activeProfiles&gt;  9.    &lt;activeProfile&gt;devactive&lt;/Profile&gt;  10. &lt;/activeProfiles&gt;  11.   ...     12. settings&gt;</code></pre><p>这里我们定义一个id为dev的profile，将所有repositories以及pluginRepositories元素放到这个profile中，然后，使用元素自动激活该profile。这样，你就不用再为每个POM重复配置仓库。    </p><p>使用profile为settings.xml添加仓库提供了一种用户全局范围的仓库配置。</p><h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p>如果你的地理位置附近有一个速度更快的central镜像，或者你想覆盖central仓库配置，或者你想为所有POM使用唯一的一个远程仓库（这个远程仓库代理的所有必要的其它仓库），你可以使用settings.xml中的mirror配置。<br>以下的mirror配置用maven.NET.cn覆盖了Maven自带的central：  </p><pre><code>Xml代码  1. &lt;settings&gt;  2. ...     3. &lt;mirrors&gt;  4. &lt;mirror&gt;  5. &lt;id&gt;maven-net-cnid&gt;  6. &lt;name&gt;Maven China Mirrorname&gt;  7. &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt;  8. &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  9. &lt;/mirror&gt;  10. &lt;/mirrors&gt;  11. ...     12. settings&gt;</code></pre><p>这里唯一需要解释的是，这里我们配置central的镜像，我们也可以配置一个所有仓库的镜像，以保证该镜像是Maven唯一使用的仓库：  </p><pre><code>Xml代码  1. &lt;settings&gt;  2. ...     3. &lt;mirrors&gt;  4.   &lt;mirror&gt;  5.    &lt;id&gt;my-org-repo&lt;/id&gt;  6.    &lt;name&gt;Repository in My Orgnization&lt;/name&gt;  7.    &lt;url&gt;http://192.168.1.100/maven2&lt;/url&gt;  8.    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;  9.   &lt;/mirror&gt;  10. &lt;/mirrors&gt;  11. ...     12. &lt;/settings&gt;</code></pre><p>关于更加高级的镜像配置，可以参考：<a href="http://maven.apache.org/guides/mini/guide-mirror-settings.html。" target="_blank" rel="noopener">http://maven.apache.org/guides/mini/guide-mirror-settings.html。</a> </p><h1 id="分发构件至远程仓库"><a href="#分发构件至远程仓库" class="headerlink" title="分发构件至远程仓库"></a>分发构件至远程仓库</h1><p><strong>mvn install</strong>会将项目生成的构件安装到本地Maven仓库，<strong>mvn deploy</strong> 用来将项目生成的构件分发到远程Maven仓库。本地Maven仓库的构件只能供当前用户使用，在分发到远程Maven仓库之后，所有能访问该仓库的用户都能使用你的构件。<br>我们需要配置POM的distributionManagement来指定Maven分发构件的位置，如下： </p><pre><code>Xml代码  1. &lt;project&gt;  2.   ...       3. &lt;distributionManagement&gt;  4. &lt;repository&gt;  5.    &lt;id&gt;nexus-releases&lt;/id&gt;  6.    &lt;name&gt;Nexus Release Repositoryname&gt;  7.    &lt;url&gt;http://127.0.0.1:8080/nexus/content/repositories/releases/&lt;/url&gt;  8. &lt;/repository&gt;  9. &lt;snapshotRepository&gt;  10.    &lt;id&gt;nexus-snapshotsid&gt;  11.    &lt;name&gt;Nexus Snapshot Repositoryname&gt;  12.    &lt;url&gt;http://127.0.0.1:8080/nexus/content/repositories/snapshots/&lt;/url&gt;  13. &lt;/snapshotRepository&gt;  14.&lt;/distributionManagement&gt;  15.   ...       16. &lt;/project&gt;</code></pre><p>Maven区别对待release版本的构件和snapshot版本的构件，snapshot为开发过程中的版本，实时，但不稳定，release版本则比较稳定。Maven会根据你项目的版本来判断将构件分发到哪个仓库。<br>一般来说，分发构件到远程仓库需要认证，如果你没有配置任何认证信息，你往往会得到401错误。这个时候，如下在settings.xml中配置认证信息： </p><pre><code>Xml代码  1. &lt;settings&gt;  2.   ...       3. &lt;servers&gt;  4.   &lt;server&gt;  5.     &lt;id&gt;nexus-releases&lt;/id&gt;  6.     &lt;username&gt;admin&lt;/username&gt;  7.     &lt;password&gt;admin123&lt;/password&gt;  8.   &lt;/server&gt;  9.   &lt;server&gt;  10.    &lt;id&gt;nexus-snapshots&lt;/id&gt;  11.    &lt;username&gt;admin&lt;/username&gt;  12.    &lt;password&gt;admin123&lt;/password&gt;  13.  &lt;/server&gt;  14. &lt;/servers&gt;  15.   ...       16. &lt;/settings&gt;</code></pre><p>==需要注意的是，settings.xml中server元素下id的值必须与POM中repository或snapshotRepository下id的值完全一致。将认证信息放到settings下而非POM中，是因为POM往往是它人可见的，而settings.xml是本地的。==  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了Maven仓库，它是什么？本地仓库，远程仓库，中央仓库具体是指什么？并介绍了如何在POM中配置项目层次的仓库，在settings中配置用户层次的仓库，以及mirror。本文还介绍了如何安装构件到本地仓库，如何分发构件至仓库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Maven仓库&quot;&gt;&lt;a href=&quot;#什么是Maven仓库&quot; class=&quot;headerlink&quot; title=&quot;什么是Maven仓库&quot;&gt;&lt;/a&gt;什么是Maven仓库&lt;/h1&gt;&lt;p&gt;在不用Maven的时候，比如说以前我们用Ant构建项目，在项目目录下，往往会看到一个名为/lib的子目录，那里存放着各类第三方依赖jar文件，如log4j.jar，junit.jar等等。每建立一个项目，你都需要建立这样的一个/lib目录，然后复制一对jar文件，这是很明显的重复。重复永远是噩梦的起点，多个项目不共用相同的jar文件，不仅会造成磁盘资源的浪费，也使得版本的一致性管理变得困难。此外，如果你使用版本管理工具，如SVN（你没有使用版本管理工具？马上试试SVN吧，它能帮你解决很多头疼的问题），你需要将大量的jar文件提交到代码库里，可是版本管理工具在处理二进制文件方面并不出色。  &lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="http://jiaxiaoxuan.top/categories/maven/"/>
    
    
      <category term="maven" scheme="http://jiaxiaoxuan.top/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>maven阿里云设置</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/maven%E9%98%BF%E9%87%8C%E4%BA%91%E8%AE%BE%E7%BD%AE/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/maven阿里云设置/</id>
    <published>2017-09-23T16:33:07.000Z</published>
    <updated>2018-01-02T15:02:41.981Z</updated>
    
    <content type="html"><![CDATA[<p>国内连接maven官方的仓库更新依赖库，网速一般很慢，收集一些国内快速的maven仓库镜像以备用。  用的时候直接复制到maven 的setting里，覆盖掉或者注释掉原来的配置。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line"></div><div class="line">&lt;!--</div><div class="line">Licensed to the Apache Software Foundation (ASF) under one</div><div class="line">or more contributor license agreements.  See the NOTICE file</div><div class="line">distributed with this work for additional information</div><div class="line">regarding copyright ownership.  The ASF licenses this file</div><div class="line">to you under the Apache License, Version 2.0 (the</div><div class="line">&quot;License&quot;); you may not use this file except in compliance</div><div class="line">with the License.  You may obtain a copy of the License at</div><div class="line">    http://www.apache.org/licenses/LICENSE-2.0</div><div class="line">Unless required by applicable law or agreed to in writing,</div><div class="line">software distributed under the License is distributed on an</div><div class="line">&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</div><div class="line">KIND, either express or implied.  See the License for the</div><div class="line">specific language governing permissions and limitations</div><div class="line">under the License.</div><div class="line">--&gt;</div><div class="line"></div><div class="line">&lt;!--</div><div class="line"> | This is the configuration file for Maven. It can be specified at two levels:</div><div class="line"> |</div><div class="line"> |  1. User Level. This settings.xml file provides configuration for a single user, </div><div class="line"> |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.</div><div class="line"> |</div><div class="line"> |                 NOTE: This location can be overridden with the CLI option:</div><div class="line"> |</div><div class="line"> |                 -s /path/to/user/settings.xml</div><div class="line"> |</div><div class="line"> |  2. Global Level. This settings.xml file provides configuration for all Maven</div><div class="line"> |                 users on a machine (assuming they&apos;re all using the same Maven</div><div class="line"> |                 installation). It&apos;s normally provided in </div><div class="line"> |                 $&#123;maven.home&#125;/conf/settings.xml.</div><div class="line"> |</div><div class="line"> |                 NOTE: This location can be overridden with the CLI option:</div><div class="line"> |</div><div class="line"> |                 -gs /path/to/global/settings.xml</div><div class="line"> |</div><div class="line"> | The sections in this sample file are intended to give you a running start at</div><div class="line"> | getting the most out of your Maven installation. Where appropriate, the default</div><div class="line"> | values (values used when the setting is not specified) are provided.</div><div class="line"> |</div><div class="line"> |--&gt;</div><div class="line">&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; </div><div class="line">          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line">          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;</div><div class="line">  &lt;!-- localRepository</div><div class="line">   | The path to the local repository maven will use to store artifacts.</div><div class="line">   |</div><div class="line">   | Default: $&#123;user.home&#125;/.m2/repository</div><div class="line">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</div><div class="line">  --&gt;</div><div class="line">  &lt;localRepository&gt;F:/data/repository&lt;/localRepository&gt;</div><div class="line"></div><div class="line">  &lt;!-- interactiveMode</div><div class="line">   | This will determine whether maven prompts you when it needs input. If set to false,</div><div class="line">   | maven will use a sensible default value, perhaps based on some other setting, for</div><div class="line">   | the parameter in question.</div><div class="line">   |</div><div class="line">   | Default: true</div><div class="line">  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</div><div class="line">  --&gt;</div><div class="line"></div><div class="line">  &lt;!-- offline</div><div class="line">   | Determines whether maven should attempt to connect to the network when executing a build.</div><div class="line">   | This will have an effect on artifact downloads, artifact deployment, and others.</div><div class="line">   |</div><div class="line">   | Default: false</div><div class="line">  &lt;offline&gt;false&lt;/offline&gt;</div><div class="line">  --&gt;</div><div class="line"></div><div class="line">  &lt;!-- pluginGroups</div><div class="line">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</div><div class="line">   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers</div><div class="line">   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.</div><div class="line">   |--&gt;</div><div class="line">  &lt;pluginGroups&gt;</div><div class="line">    &lt;!-- pluginGroup</div><div class="line">     | Specifies a further group identifier to use for plugin lookup.</div><div class="line">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</div><div class="line">    --&gt;</div><div class="line">&lt;pluginGroup&gt;org.mortbay.jetty&lt;/pluginGroup&gt;</div><div class="line">  &lt;/pluginGroups&gt;</div><div class="line"></div><div class="line">  &lt;!-- proxies</div><div class="line">   | This is a list of proxies which can be used on this machine to connect to the network.</div><div class="line">   | Unless otherwise specified (by system property or command-line switch), the first proxy</div><div class="line">   | specification in this list marked as active will be used.</div><div class="line">   |--&gt;</div><div class="line">  &lt;proxies&gt;</div><div class="line">    &lt;!-- proxy</div><div class="line">     | Specification for one proxy, to be used in connecting to the network.</div><div class="line">     |</div><div class="line">    &lt;proxy&gt;</div><div class="line">      &lt;id&gt;optional&lt;/id&gt;</div><div class="line">      &lt;active&gt;true&lt;/active&gt;</div><div class="line">      &lt;protocol&gt;http&lt;/protocol&gt;</div><div class="line">      &lt;username&gt;proxyuser&lt;/username&gt;</div><div class="line">      &lt;password&gt;proxypass&lt;/password&gt;</div><div class="line">      &lt;host&gt;proxy.host.net&lt;/host&gt;</div><div class="line">      &lt;port&gt;80&lt;/port&gt;</div><div class="line">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</div><div class="line">    &lt;/proxy&gt;</div><div class="line">    --&gt;</div><div class="line">  &lt;/proxies&gt;</div><div class="line"></div><div class="line">  &lt;!-- servers</div><div class="line">   | This is a list of authentication profiles, keyed by the server-id used within the system.</div><div class="line">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</div><div class="line">   |--&gt;</div><div class="line">  &lt;servers&gt;</div><div class="line">    &lt;!-- server</div><div class="line">     | Specifies the authentication information to use when connecting to a particular server, identified by</div><div class="line">     | a unique name within the system (referred to by the &apos;id&apos; attribute below).</div><div class="line">     | </div><div class="line">     | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are </div><div class="line">     |       used together.</div><div class="line">     |</div><div class="line">    &lt;server&gt;</div><div class="line">      &lt;id&gt;deploymentRepo&lt;/id&gt;</div><div class="line">      &lt;username&gt;repouser&lt;/username&gt;</div><div class="line">      &lt;password&gt;repopwd&lt;/password&gt;</div><div class="line">    &lt;/server&gt;</div><div class="line">    --&gt;</div><div class="line">    </div><div class="line">    &lt;!-- Another sample, using keys to authenticate.</div><div class="line">    &lt;server&gt;</div><div class="line">      &lt;id&gt;siteServer&lt;/id&gt;</div><div class="line">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</div><div class="line">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</div><div class="line">    &lt;/server&gt;</div><div class="line">    --&gt;</div><div class="line">&lt;server&gt;</div><div class="line">&lt;id&gt;releases&lt;/id&gt;</div><div class="line">&lt;username&gt;ali&lt;/username&gt;</div><div class="line">&lt;password&gt;ali&lt;/password&gt;</div><div class="line">  &lt;/server&gt;</div><div class="line">  &lt;server&gt;</div><div class="line">&lt;id&gt;Snapshots&lt;/id&gt;</div><div class="line">&lt;username&gt;ali&lt;/username&gt;</div><div class="line">&lt;password&gt;ali&lt;/password&gt;</div><div class="line">  &lt;/server&gt;</div><div class="line">  &lt;/servers&gt;</div><div class="line"></div><div class="line">  &lt;!-- mirrors</div><div class="line">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</div><div class="line">   | </div><div class="line">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</div><div class="line">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</div><div class="line">   | it to several places.</div><div class="line">   |</div><div class="line">   | That repository definition will have a unique id, so we can create a mirror reference for that</div><div class="line">   | repository, to be used as an alternate download site. The mirror site will be the preferred </div><div class="line">   | server for that repository.</div><div class="line">   |--&gt;</div><div class="line">  &lt;mirrors&gt;</div><div class="line">    &lt;!-- mirror</div><div class="line">     | Specifies a repository mirror site to use instead of a given repository. The repository that</div><div class="line">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</div><div class="line">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</div><div class="line">     |</div><div class="line">    &lt;mirror&gt;</div><div class="line">      &lt;id&gt;mirrorId&lt;/id&gt;</div><div class="line">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</div><div class="line">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</div><div class="line">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</div><div class="line">    &lt;/mirror&gt;</div><div class="line">     --&gt;</div><div class="line">&lt;mirror&gt;</div><div class="line">      &lt;!--This sends everything else to /public --&gt;</div><div class="line">      &lt;id&gt;nexus&lt;/id&gt;</div><div class="line">      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; </div><div class="line">      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</div><div class="line">    &lt;/mirror&gt;</div><div class="line">&lt;mirror&gt;</div><div class="line">      &lt;!--This is used to direct the public snapshots repo in the </div><div class="line">          profile below over to a different nexus group --&gt;</div><div class="line">      &lt;id&gt;nexus-public-snapshots&lt;/id&gt;</div><div class="line">      &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt; </div><div class="line">      &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt;</div><div class="line">    &lt;/mirror&gt;</div><div class="line">  &lt;/mirrors&gt;</div><div class="line">  </div><div class="line">  &lt;!-- profiles</div><div class="line">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</div><div class="line">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</div><div class="line">   | specific paths and repository locations which allow the build to work in the local environment.</div><div class="line">   |</div><div class="line">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</div><div class="line">   | your Tomcat instance is installed, you can provide a variable here such that the variable is </div><div class="line">   | dereferenced during the build process to configure the cactus plugin.</div><div class="line">   |</div><div class="line">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</div><div class="line">   | section of this document (settings.xml) - will be discussed later. Another way essentially</div><div class="line">   | relies on the detection of a system property, either matching a particular value for the property,</div><div class="line">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a </div><div class="line">   | value of &apos;1.4&apos; might activate a profile when the build is executed on a JDK version of &apos;1.4.2_07&apos;.</div><div class="line">   | Finally, the list of active profiles can be specified directly from the command line.</div><div class="line">   |</div><div class="line">   | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact</div><div class="line">   |       repositories, plugin repositories, and free-form properties to be used as configuration</div><div class="line">   |       variables for plugins in the POM.</div><div class="line">   |</div><div class="line">   |--&gt;</div><div class="line">  &lt;profiles&gt; </div><div class="line">&lt;profile&gt;</div><div class="line">      &lt;id&gt;development&lt;/id&gt;</div><div class="line">      &lt;repositories&gt;</div><div class="line">        &lt;repository&gt;</div><div class="line">          &lt;id&gt;central&lt;/id&gt;</div><div class="line">          &lt;url&gt;http://central&lt;/url&gt;</div><div class="line">          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/releases&gt;</div><div class="line">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt;</div><div class="line">        &lt;/repository&gt;</div><div class="line">      &lt;/repositories&gt;</div><div class="line">     &lt;pluginRepositories&gt;</div><div class="line">        &lt;pluginRepository&gt;</div><div class="line">          &lt;id&gt;central&lt;/id&gt;</div><div class="line">          &lt;url&gt;http://central&lt;/url&gt;</div><div class="line">          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/releases&gt;</div><div class="line">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt;</div><div class="line">        &lt;/pluginRepository&gt;</div><div class="line">      &lt;/pluginRepositories&gt;</div><div class="line">    &lt;/profile&gt;</div><div class="line">    &lt;profile&gt;</div><div class="line">      &lt;!--this profile will allow snapshots to be searched when activated--&gt;</div><div class="line">      &lt;id&gt;public-snapshots&lt;/id&gt;</div><div class="line">      &lt;repositories&gt;</div><div class="line">        &lt;repository&gt;</div><div class="line">          &lt;id&gt;public-snapshots&lt;/id&gt;</div><div class="line">          &lt;url&gt;http://public-snapshots&lt;/url&gt;</div><div class="line">          &lt;releases&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/releases&gt;</div><div class="line">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt;</div><div class="line">        &lt;/repository&gt;</div><div class="line">      &lt;/repositories&gt;</div><div class="line">     &lt;pluginRepositories&gt;</div><div class="line">        &lt;pluginRepository&gt;</div><div class="line">          &lt;id&gt;public-snapshots&lt;/id&gt;</div><div class="line">          &lt;url&gt;http://public-snapshots&lt;/url&gt;</div><div class="line">          &lt;releases&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/releases&gt;</div><div class="line">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt;</div><div class="line">        &lt;/pluginRepository&gt;</div><div class="line">      &lt;/pluginRepositories&gt;</div><div class="line">    &lt;/profile&gt;</div><div class="line">  &lt;/profiles&gt;</div><div class="line"> </div><div class="line">   &lt;activeProfiles&gt;</div><div class="line">    &lt;activeProfile&gt;development&lt;/activeProfile&gt;</div><div class="line">    &lt;activeProfile&gt;public-snapshots&lt;/activeProfile&gt;</div><div class="line">   &lt;/activeProfiles&gt;</div><div class="line">&lt;/settings&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国内连接maven官方的仓库更新依赖库，网速一般很慢，收集一些国内快速的maven仓库镜像以备用。  用的时候直接复制到maven 的setting里，覆盖掉或者注释掉原来的配置。&lt;br&gt;
    
    </summary>
    
      <category term="maven" scheme="http://jiaxiaoxuan.top/categories/maven/"/>
    
    
      <category term="maven" scheme="http://jiaxiaoxuan.top/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>jvm调优</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/jvm%E8%B0%83%E4%BC%98/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/jvm调优/</id>
    <published>2017-09-23T16:24:31.000Z</published>
    <updated>2018-01-02T15:02:41.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆/Heap"></a>堆/Heap</h2><p>JVM管理的内存叫堆；在32Bit操作系统上有4G的限制，一般来说Windows下为2G，而Linux 下为3G；64Bit的就没有这个限制。<br>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64但小于1G。<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4但小于1G。<br>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以由 -XX:MinHeapFreeRatio=指定。<br>默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以由 -XX:MaxHeapFreeRatio=指定。<br>服务器一般设置-Xms、-Xmx相等以避免在每次GC后调整堆的大小，所以上面的两个参数没啥用。  </p><a id="more"></a><h2 id="分代-堆模型"><a href="#分代-堆模型" class="headerlink" title="分代/堆模型"></a>分代/堆模型</h2><p>分代是Java垃圾收集的一大亮点，根据对象的生命周期长短，把堆分为3个代：Young，Old和Permanent，根据不同代的特点采用不同的收集算法，可以扬长避短。可参考如下的模型图：</p><p><strong><em>Young(Nursery)：</em></strong> 年轻代<br>研究表明大部分对象都是朝生暮死，随生随灭的。所以对于年轻代在GC时都采取复制收集算法，具体算法参考下面的描述；<br>Young的默认值为4M，随堆内存增大，约为1/15，JVM会根据情况动态管理其大小变化。<br>Young里面又分为3 个区域，一个Eden，所有新建对象都会存在于该区，两个Survivor区，用来实施复制算法。<br>-XX:NewRatio= 参数可以设置Young与Old的大小比例，-server时默认为1:2，但实际上young启动时远低于这个比率？如果信不过JVM，也可以用 -Xmn硬性规定其大小，有文档推荐设为Heap总大小的1/4。<br>-XX:SurvivorRatio= 参数可以设置Eden与Survivor的比例，默认为32。Survivio大了会浪费，小了的话，会使一些年轻对象潜逃到老人区，引起老人区的不安，但这个参数对性能并不太重要。</p><p><strong><em>Old(Tenured)：</em></strong> 年老代<br>年轻代的对象如果能够挺过数次收集，就会进入老人区。老人区使用标记整理算法。因为老人区的对象都没那么容易死的，采用复制算法就要反复的复制对象，很不合算，只好采用标记清理算法，但标记清理算法其实也不轻松，每次都要遍历区域内所有对象，所以还是没有免费的午餐啊。<br>-XX:MaxTenuringThreshold= 设置熬过年轻代多少次收集后移入老人区，CMS中默认为0，熬过第一次GC就转入，可以用-XX:+PrintTenuringDistribution 查看。</p><p><strong><em>Permanent：</em></strong> 持久代<br>装载Class信息等基础数据，默认64M，如果是类很多很多的服务程序，需要加大其设置 -XX:MaxPermSize=，否则它满了之后会引起fullgc()或Out of Memory。  ==注意Spring，Hibernate这类喜欢AOP动态生成类的框架需要更多的持久代内存。== 一般情况下，持久代是不会进行GC的，除非通过 -XX:+CMSClassUnloadingEnabled-XX:+CMSPermGenSweepingEnabled进行强制设置。</p><p><strong><em>GC的类型</em></strong><br>当每个代满了之后都会自动促发collection，各收集器触发的条件不一样，当然也可以通过一些参数进行强制设定。主要分为两种类型：<br>Minor Collection：GC用较高的频率对young进行扫描和回收，采用复制算法。<br>Major Collection：同时对Young和Old进行内存收集，也叫Full GC；因为成本关系对Old的检查回收频率要比Young低很多，采用标记清除/标记整理算法。可以通过调用代码System.gc()引发major collection，使用-XX:+DisableExplicitGC禁止它，或设为CMS并发 -XX:+ExplicitGCInvokesConcurrent。<br>更为具体的阐述如下：<br>&nbsp;&nbsp;由于年轻代进进出出的人多而频繁，所以年轻代的GC也就频繁一点，但涉及范围也就年轻代这点弹丸之地内的对象，其特点就是少量，多次，但快速，称之为 Minor Collection。当年轻代的内存使用达到一定的阀值时，Minor Collection就被触发，Eden及某一Survior space（from space）之内存活的的对象被移到另一个空的Survior space（to space）中，然后from space和to space角色对调。当一个对象在两个survivor space之间移动过一定次数（达到预设的阀值）时，它就足够old了，够资格呆在年老代了。当然，如果survivor space比较小不足以容下所有live objects时，部分live objects也会直接晋升到年老代。</p><p>&nbsp;&nbsp;Survior spaces可以看作是Eden和年老代之间的缓冲，通过该缓冲可以检验一个对象生命周期是否足够的长，因为某些对象虽然逃过了一次Minor Collection，并不能说明其生命周期足够长，说不定在下一次Minor Collection之前就挂了。这样一定程度上确保了进入年老代的对象是货真价实的，减少了年老代空间使用的增长速度，也就降低年老代GC的频率。<br>当年老代或者永久代的内存使用达到一定阀值时，一次基于所有代的GC就触发了，其特定是涉及范围广（量大），耗费的时间相对较长（较慢），但是频率比较低（次数少），称之为Major Collection(Full Collection)。通常，首先使用针对年轻代的GC算法进行年轻代的GC，然后使用针对年老代的GC算法对年老代和永久代进行GC。  </p><h2 id="基本GC收集算法"><a href="#基本GC收集算法" class="headerlink" title="基本GC收集算法"></a>基本GC收集算法</h2><p><strong><em>复制(copying)：</em></strong> 将堆内分成两个相同空间，从根(ThreadLocal的对象，静态对象）开始访问每一个关联的活跃对象，将空间A的活跃对象全部复制到空间B，然后一次性回收整个空间A。<br>因为只访问活跃对象，将所有活动对象复制走之后就清空整个空间，不用去访问死对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。</p><p><strong><em>标记清除(mark-sweep)：</em></strong> 收集器先从根开始访问所有活跃对象，标记为活跃对象。然后再遍历一次整个内存区域，把所有没有标记活跃的对象进行回收处理。该算法遍历整个空间的成本较大暂停时间随空间大小线性增大，而且整理后堆里的碎片很多。</p><p><strong><em>标记整理(mark-sweep-compact)：</em></strong> 综合了上述两者的做法和优点，先标记活跃对象，然后将其合并成较大的内存块。</p><h2 id="GC收集器类型"><a href="#GC收集器类型" class="headerlink" title="GC收集器类型"></a>GC收集器类型</h2><p><strong><em>古老的串行收集器(Serial Collector)</em></strong><br>-XX:+UseSerialGC：<br>策略为年轻代串行复制，年老代串行标记整理。吞吐量优先的并行收集器(Throughput Collector)-XX:+UseParallelGC：这是JDK5 -server的默认值。  </p><p>策略为：<br>年轻代：暂停应用程序，多个垃圾收集线程并行的复制收集，线程数默认为CPU个数，CPU很多时，可用 -XX:ParallelGCThreads= 设定线程数。<br>年老代：暂停应用程序，与串行收集器一样，单垃圾收集线程标记整理。</p><p>如上可知该收集器需要2+的CPU时才会优于串行收集器，适用于后台处理，科学计算。<br>可以使用-XX:MaxGCPauseMillis= 和 -XX:GCTimeRatio 来调整GC的时间。</p><p><strong><em>暂停时间优先的并发收集器(Concurrent Low Pause Collector-CMS)</em></strong><br>-XX:+UseConcMarkSweepGC：<br>这是以上两种策略的升级版，策略为：<br>年轻代：同样是暂停应用程序，多个垃圾收集线程并行的复制收集。<br>年老代：则只有两次短暂停，其他时间应用程序与收集线程并发的清除。<br>若要采用标记整理算法，则可以通过设置参数实现;<br><strong><em>增量并发收集器(IncrementalConcurrent-Mark-Sweep/i-CMS)</em></strong><br>虽然CMS收集算法在最为耗时的内存区域遍历时采用多线程并发操作，但对于服务器CPU资源不够的情况下，其实对性能是没有提升的，反而会导致系统吞吐量的下降，为了尽量避免这种情况的出现，就有了增量CMS收集算法，就是在并发标记、清理的时候让GC线程、用户线程交叉运行，尽量减少GC线程的全程独占式执行；  </p><p>对于以上的GC收集器的详细设置参数，可以参考 JVM选项的超完整收集《A Collection of JVM Options》，这里就不一一详述了。</p><h2 id="并行、并发的区别"><a href="#并行、并发的区别" class="headerlink" title="并行、并发的区别"></a>并行、并发的区别</h2><p>并行(Parallel)与并发(Concurrent)仅一字之差，但体现的意思却完全不同，这可能也是很多同学非常困惑的地方，要想深刻体会这其中的差别，可以多揣摩下上面关于GC收集器的示例图；</p><p>并行：指多条垃圾收集线程并行，此时用户线程是没有运行的；<br>并发：指用户线程与垃圾收集线程并发执行，程序在继续运行，而垃圾收集程序运行于另一个个CPU上。</p><p>并发收集一开始会很短暂的停止一次所有线程来开始初始标记根对象，然后标记线程与应用线程一起并发运行，最后又很短的暂停一次，多线程并行的重新标记之前可能因为并发而漏掉的对象，然后就开始与应用程序并发的清除过程。可见，最长的两个遍历过程都是与应用程序并发执行的，比以前的串行算法改进太多太多了！！！  </p><p>串行标记清除是等年老代满了再开始收集的，而并发收集因为要与应用程序一起运行，如果满了才收集，应用程序就无内存可用，所以系统默认68%满的时候就开始收集。内存已设得较大，吃内存又没有这么快的时候，可以用 -XX:CMSInitiatingOccupancyFraction=恰当增大该比率。</p><p><strong><em>年轻代的痛</em></strong><br>由于对年轻代的复制收集，依然必须停止所有应用程序线程，原理如此，只能靠多CPU，多收集线程并发来提高收集速度，但除非你的 Server独占整台服务器，否则如果服务器上本身还有很多其他线程时，切换起来速度就….. 所以，搞到最后，暂停时间的瓶颈就落在了年轻代的复制算法上。<br>因此Young的大小设置挺重要的，大点就不用频繁GC，而且增大GC的间隔后，可以让多点对象自己死掉而不用复制了。但Young增大时，GC 造成的停顿时间攀升得非常恐怖，据某人的测试结果显示：默认8M的Young，只需要几毫秒的时间，64M就升到90毫秒，而升到256M时，就要到 300毫秒了，峰值还会攀到恐怖的800ms。谁叫复制算法，要等Young满了才开始收集，开始收集就要停止所有线程呢。   </p><p>参考资料<br>主要参考：JDK5.0垃圾收集优化之–Don’t Pause<br>官方指南：Tuning Garbage Collection with the 5.0 Java Virtual Machine</p><h1 id="Sun-HotSpot-1-4-1-JVM堆大小的调整"><a href="#Sun-HotSpot-1-4-1-JVM堆大小的调整" class="headerlink" title="Sun HotSpot 1.4.1 JVM堆大小的调整"></a>Sun HotSpot 1.4.1 JVM堆大小的调整</h1><p>Sun HotSpot 1.4.1使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域。Jvm生成的所有新对象放在新域中。一旦对象经历了一定数量的垃圾收集循环后，便获得使用期并进入旧域。在永久域中jvm则存储class和method对象。就配置而言，永久域是一个独立域并且不认为是堆的一部分。</p><p>下面介绍如何控制这些域的大小。可使用-Xms和-Xmx控制整个堆的原始大小或最大值。  </p><p>下面的命令是把初始大小设置为128M：</p><p>java –Xms128m</p><p>–Xmx256m为控制新域的大小，可使用 -XX:NewRatio设置新域在堆中所占的比例。</p><p>下面的命令把整个堆设置成128m，新域比率设置成3，即新域与旧域比例为 1：3，新域为堆的1/4或32M：</p><p>java –Xms128m –Xmx128m</p><p>–XX:NewRatio =3可使用-XX:NewSize和-XX:MaxNewsize设置新域的初始值和最大值。</p><p>下面的命令把新域的初始值和最大值设置成64m:</p><p>java –Xms256m –Xmx256m –Xmn64m</p><p>永久域默认大小为4m。运行程序时，jvm会调整永久域的大小以满足需要。每次调整时，jvm会对堆进行一次完全的垃圾收集。</p><p>使用-XX:MaXPerSize标志来增加永久域搭大小。在WebLogic Server应用程序加载较多类时，经常需要增加永久域的最大值。当jvm加载类时，永久域中的对象急剧增加，从而使jvm不断调整永久域大小。为了避免调整，可使用-XX:PerSize标志设置初始值。</p><p>下面把永久域初始值设置成32m，最大值设置成64m。</p><p>java -Xms512m -Xmx512m -Xmn128m -XX:PermSize=32m -XX:MaxPermSize=64m</p><p>默认状态下，HotSpot在新域中使用复制收集器。该域一般分为三个部分。第一部分为Eden，用于生成新的对象。另两部分称为救助空间，当 Eden布满时，收集器停止应用程序，把所有可到达对象复制到当前的from救助空间，一旦当前的from救助空间布满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们获得使用期并转入旧域。使用 -XX:SurvivorRatio可控制新域子空间的大小。</p><p>同NewRation一样，SurvivorRation规定某救助域与Eden空间的比值。比如，以下命令把新域设置成64m，Eden占32m，每个救助域各占16m：</p><p>java -Xms256m -Xmx256m -Xmn64m -XX:SurvivorRation =2</p><p>如前所述，默认状态下 HotSpot对新域使用复制收集器，对旧域使用标记－清除－压缩收集器。在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。假如能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价。为控制新域中对象的复制，可用-XX:TargetSurvivorRatio控制救助空间的比例（该值是设置救助空间的使用比例。如救助空间位1M，该值50表示可用500K）。该值是一个百分比，默认值是50。当较大的堆栈使用较低的sruvivorratio时，应增加该值到80至90，以更好利用救助空间。用-XX:maxtenuring threshold可控制上限。</p><p>为放置所有的复制全部发生以及希望对象从eden扩展到旧域，可以把MaxTenuring Threshold设置成0。设置完成后，实际上就不再使用救助空间了，因此应把SurvivorRatio设成最大值以最大化Eden空间，设置如下：</p><p>java … -XX:MaxTenuringThreshold=0 –XX:SurvivorRatio＝50000 …</p><pre><code>-Xmx4000M-Xms4000M-Xmn600M-XX:PermSize=64M-XX:MaxPermSize=128M-Xss256K-XX:+DisableExplicitGC-XX:SurvivorRatio=1  -XX:+UseConcMarkSweepGC-XX:+UseParNewGC    -XX:+CMSParallelRemarkEnabled-XX:+UseCMSCompactAtFullCollection-XX:CMSFullGCsBeforeCompaction=0-XX:+CMSClassUnloadingEnabled-XX:LargePageSizeInBytes=128M-XX:+UseFastAccessorMethods-XX:+UseCMSInitiatingOccupancyOnly-XX:CMSInitiatingOccupancyFraction=80-XX:SoftRefLRUPolicyMSPerMB=0-XX:+PrintClassHistogram-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintHeapAtGC-Xloggc:log/gc.log   </code></pre><p>jdk1.4.2 JVM官方地址：<a href="http://java.sun.com/j2se/1.4.2/docs/guide/vm/index.html" target="_blank" rel="noopener">http://java.sun.com/j2se/1.4.2/docs/guide/vm/index.html</a><br>标准和非标注参数(for windows)：<a href="http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/java.html" target="_blank" rel="noopener">http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/java.html</a><br>非 stable参数：<a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" target="_blank" rel="noopener">http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp</a></p><p>中文地址：<br><a href="http://blog.csdn.net/sfdev/archive/2008/01/23/2062042.aspx" target="_blank" rel="noopener">http://blog.csdn.net/sfdev/archive/2008/01/23/2062042.aspx</a>                           </p><p>前面我们提到用-XX作为前缀的参数列表在jvm中可能是不健壮的，SUN也不推荐使用，后续可能会在没有通知的情况下就直接取消了；但是由于这些参数中的确有很多是对我们很有用的，比如我们经常会见到的-XX:PermSize、-XX:MaxPermSize等等；<br>下面我们将就 Java HotSpot VM中-XX:的可配置参数列表进行描述；</p><p>这些参数可以被松散的聚合成三类：<br><strong><em>行为参数（Behavioral Options）</em></strong>：用于改变jvm的一些基础行为；<br><strong><em>性能调优（Performance Tuning）</em></strong>：用于jvm的性能调优；<br><strong><em>调试参数（DebuggingOptions）</em></strong>：一般用于打开跟踪、打印、输出等jvm参数，用于显示jvm更加详细的信息；</p><p>由于sun官方文档中对各参数的描述也都非常少（大多只有一句话），而且大多涉及OS层面的东西，很难描述清楚，所以以下是挑选了一些我们开发中可能会用得比较多的配置项，若需要查看所有参数列表，可以点击HotSpot VM Specific Options.查看原文；</p><h3 id="首先来介绍行为参数："><a href="#首先来介绍行为参数：" class="headerlink" title="首先来介绍行为参数："></a>首先来介绍行为参数：</h3><table><thead><tr><th>参数及其默认值</th><th>描述</th></tr></thead><tbody><tr><td>-XX:-DisableExplicitGC</td><td>禁止调用System.gc()；但jvm的gc仍然有效</td></tr><tr><td>-XX:+MaxFDLimit</td><td>最大化文件描述符的数量限制</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>新生代GC优先于Full GC执行</td></tr><tr><td>-XX:+UseGCOverheadLimit</td><td>在抛出OOM之前限制jvm耗费在GC上的时间比例</td></tr><tr><td><strong>-XX:-UseConcMarkSweepGC</strong></td><td>对老生代采用并发标记交换算法进行GC</td></tr><tr><td><strong>-XX:-UseParallelGC</strong></td><td>启用并行GC</td></tr><tr><td>-XX:-UseParallelOldGC</td><td>对Full GC启用并行，当-XX:-UseParallelGC启用时该项自动启用</td></tr><tr><td><strong>-XX:-UseSerialGC</strong></td><td>启用串行GC</td></tr><tr><td>-XX:+UseThreadPriorities</td><td>启用本地线程优先级</td></tr></tbody></table><p>上面表格中黑体的三个参数代表着jvm中GC执行的三种方式，即串行、并行、并发；<br>串行（SerialGC）是jvm的默认GC方式，一般适用于小型应用和单处理器，算法比较简单，GC效率也较高，但可能会给应用带来停顿；  </p><p>并行（ParallelGC）是指GC运行时，对应用程序运行没有影响，GC和app两者的线程在并发执行，这样可以最大限度不影响app的运行；</p><p>并发（ConcMarkSweepGC）是指多个线程并发执行GC，一般适用于多处理器系统中，可以提高GC的效率，但算法复杂，系统消耗较大；  </p><h3 id="性能调优参数列表："><a href="#性能调优参数列表：" class="headerlink" title="性能调优参数列表："></a>性能调优参数列表：</h3><table><thead><tr><th>参数及其默认值</th><th>描述</th></tr></thead><tbody><tr><td>-XX:LargePageSizeInBytes=4m</td><td>设置用于Java堆的大页面尺寸</td></tr><tr><td>-XX:MaxHeapFreeRatio=70</td><td>GC后java堆中空闲量占的最大比例</td></tr><tr><td>-XX:MaxNewSize=size</td><td>新生成对象能占用内存的最大值</td></tr><tr><td>-XX:MaxPermSize=64m</td><td>老生代对象能占用内存的最大值</td></tr><tr><td>-XX:MinHeapFreeRatio=40</td><td>GC后java堆中空闲量占的最小比例</td></tr><tr><td>-XX:NewRatio=2</td><td>新生代内存容量与老生代内存容量的比例</td></tr><tr><td>-XX:NewSize=2.125m</td><td>新生代对象生成时占用内存的默认值</td></tr><tr><td>-XX:ReservedCodeCacheSize=32m</td><td>保留代码占用的内存容量</td></tr><tr><td>-XX:ThreadStackSize=512</td><td>设置线程栈大小，若为0则使用系统默认值</td></tr><tr><td>-XX:+UseLargePages</td><td>使用大页面内存</td></tr></tbody></table><p>我们在日常性能调优中基本上都会用到以上这几个属性；</p><h3 id="调试参数列表："><a href="#调试参数列表：" class="headerlink" title="调试参数列表："></a>调试参数列表：</h3><table><thead><tr><th>参数及其默认值</th><th>描述</th></tr></thead><tbody><tr><td>–XX:-CITime</td><td>打印消耗在JIT编译的时间</td></tr><tr><td>-XX:ErrorFile=./hs_err_pid.log</td><td>保存错误日志或者数据到文件中</td></tr><tr><td>-XX:-ExtendedDTraceProbes</td><td>开启solaris特有的dtrace探针</td></tr><tr><td>-XX:HeapDumpPath=./java_pid.hprof</td><td>指定导出堆信息时的路径或文件名</td></tr><tr><td>-XX:-HeapDumpOnOutOfMemoryError</td><td>当首次遭遇OOM时导出此时堆中相关信息</td></tr><tr><td>-XX:OnError=”;”</td><td>出现致命ERROR之后运行自定义命令</td></tr><tr><td>-XX:OnOutOfMemoryError=”;”</td><td>当首次遭遇OOM时执行自定义命令</td></tr><tr><td>-XX:-PrintClassHistogram</td><td>遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同</td></tr><tr><td>-XX:-PrintConcurrentLocks</td><td>遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同</td></tr><tr><td>-XX:-PrintCommandLineFlags</td><td>打印在命令行中出现过的标记</td></tr><tr><td>-XX:-PrintCompilation</td><td>当一个方法被编译时打印相关信息</td></tr><tr><td>-XX:-PrintGC</td><td>每次GC时打印相关信息</td></tr><tr><td>-XX:-PrintGC Details</td><td>每次GC时打印详细信息</td></tr><tr><td>-XX:-PrintGCTimeStamps</td><td>打印每次GC的时间戳</td></tr><tr><td>-XX:-TraceClassLoading</td><td>跟踪类的加载信息</td></tr><tr><td>-XX:-TraceClassLoadingPreorder</td><td>跟踪被引用到的所有类的加载信息</td></tr><tr><td>-XX:-TraceClassResolution</td><td>跟踪常量池</td></tr><tr><td>-XX:-TraceClassUnloading</td><td>跟踪类的卸载信息</td></tr><tr><td>-XX:-TraceLoaderConstraints</td><td>跟踪类加载器约束的相关信息</td></tr></tbody></table><p>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p><p>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/usr/local/jdk/bin/java</div><div class="line">-Dresin.home=/usr/local/resin -server -Xms1800M -Xmx1800M -Xmn300M</div><div class="line">-Xss512K -XX:PermSize=300M -XX:MaxPermSize=300M -XX:SurvivorRatio=8</div><div class="line">-XX:MaxTenuringThreshold=5 -XX:GCTimeRatio=19 -Xnoclassgc</div><div class="line">-XX:+DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC</div><div class="line">-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0</div><div class="line">-XX:-CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction=70</div><div class="line">-XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram</div><div class="line">-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC</div><div class="line">-Xloggc:log/gc.log</div></pre></td></tr></table></figure><h2 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h2><p>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。</p><p><strong>典型JVM参数设置：</strong></p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</p><p>-Xmx3550m：设置JVM最大可用内存为3550M。</p><p>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><p>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p><p>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。</p><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p><p>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p><p>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个 Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p><p>-XX:MaxPermSize=16m:设置持久代大小为16m。</p><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p><h2 id="回收器选择"><a href="#回收器选择" class="headerlink" title="回收器选择"></a>回收器选择</h2><p>JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p><h3 id="吞吐量优先的并行收集器"><a href="#吞吐量优先的并行收集器" class="headerlink" title="吞吐量优先的并行收集器"></a>吞吐量优先的并行收集器</h3><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p><p>典型JVM参数配置：</p><p>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</p><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</p><p>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</p><p>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</p><p>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</p><p>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p><h3 id="响应时间优先的并发收集器"><a href="#响应时间优先的并发收集器" class="headerlink" title="响应时间优先的并发收集器"></a>响应时间优先的并发收集器</h3><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。</p><p>典型JVM参数配置：</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</p><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</p><p>-XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</p><p>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p><p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p><p>辅助信息</p><p>JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：</p><p>-XX:+PrintGC</p><p>输出形式：</p><p>[GC 118250K-&gt;113543K(130112K), 0.0094143 secs]<br>[Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]<br>-XX:+PrintGCDetails<br>输出形式：</p><p>[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs]  118250K-&gt;113543K(130112K), 0.0124633 secs]<br>[GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured:  112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K),  0.0436268 secs]<br>-XX:+PrintGCTimeStamps   -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用  </p><p>输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]  </p><p>-XX:+PrintGCApplicationConcurrentTime:打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用</p><p>输出形式：Application time: 0.5291524 seconds</p><p>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用</p><p>输出形式：Total time for which application threads were stopped: 0.0468229 seconds</p><p>-XX:PrintHeapAtGC:打印GC前后的详细堆栈信息</p><p>输出形式：   </p><p>34.702: [GC {Heap before gc invocations=7:<br>def new generation   total 55296K, used 52568K [0x1ebd0000, 0x227d0000, 0x227d0000)<br>eden space 49152K, 99% used [0x1ebd0000, 0x21bce430, 0x21bd0000)<br>from space 6144K, 55% used [0x221d0000, 0x22527e10, 0x227d0000)<br>to   space 6144K,   0% used [0x21bd0000, 0x21bd0000, 0x221d0000)<br>tenured generation   total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)<br>the space 69632K,   3% used [0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000)<br>compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)<br>the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)<br>ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)<br>rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)<br>34.735: [DefNew: 52568K-&gt;3433K(55296K), 0.0072126 secs] 55264K-&gt;6615K(124928K)Heap after gc invocations=8:<br>def new generation   total 55296K, used 3433K [0x1ebd0000, 0x227d0000, 0x227d0000)<br>eden space 49152K,   0% used [0x1ebd0000, 0x1ebd0000, 0x21bd0000)<br>from space 6144K, 55% used [0x21bd0000, 0x21f2a5e8, 0x221d0000)<br>to   space 6144K,   0% used [0x221d0000, 0x221d0000, 0x227d0000)<br>tenured generation   total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)<br>the space 69632K,   4% used [0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000)<br>compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)<br>the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)<br>ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)<br>rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)<br>}<br>, 0.0757599 secs]<br>-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析。</p><h1 id="常见JVM参数配置汇总"><a href="#常见JVM参数配置汇总" class="headerlink" title="常见JVM参数配置汇总"></a>常见JVM参数配置汇总</h1><p>堆设置</p><p>-Xms:初始堆大小</p><p>-Xmx:最大堆大小</p><p>-XX:NewSize=n:设置年轻代大小</p><p>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</p><p>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示 Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</p><p>-XX:MaxPermSize=n:设置持久代大小</p><p>收集器设置</p><p>-XX:+UseSerialGC:设置串行收集器</p><p>-XX:+UseParallelGC:设置并行收集器</p><p>-XX:+UseParalledlOldGC:设置并行年老代收集器</p><p>-XX:+UseConcMarkSweepGC:设置并发收集器</p><p>垃圾回收统计信息</p><p>-XX:+PrintGC</p><p>-XX:+PrintGCDetails</p><p>-XX:+PrintGCTimeStamps</p><p>-Xloggc:filename</p><p>并行收集器设置</p><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</p><p>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</p><p>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p><p>并发收集器设置</p><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p><p>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p><h1 id="四、调优总结"><a href="#四、调优总结" class="headerlink" title="四、调优总结"></a>四、调优总结</h1><p>年轻代大小选择</p><p>响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</p><p>吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</p><p>年老代大小选择</p><p>响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p><p>并发垃圾收集信息</p><p>持久代并发收集次数</p><p>传统GC信息</p><p>花在年轻代和年老代回收上的时间比例</p><p>减少年轻代和年老代花费的时间，一般会提高应用的效率</p><p>吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</p><p>较小堆引起的碎片问题</p><p>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下JVM参数配置：</p><p>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。</p><p>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</p><p>1: heap size</p><p>a: -Xmx                     </p><p>指定 jvm 的最大 heap 大小 , 如 :-Xmx=2g</p><p>b: -Xms                     </p><p>指定 jvm 的最小 heap 大小 , 如 :-Xms=2g ， 高并发应用， 建议和-Xmx一样， 防止因为内存收缩／突然增大带来的性能影响。</p><p>c: -Xmn                     </p><p>指定 jvm 中 New Generation 的大小 , 如 :-Xmn256m。 这个参数很影响性能， 如果你的程序需要比较多的临时内存， 建议设置到512M， 如果用的少， 尽量降低这个数值， 一般来说128／256足以使用了。</p><p>d: -XX:PermSize=</p><p>指定 jvm 中 Perm Generation 的最小值 , 如 :-XX:PermSize=32m。 这个参数需要看你的实际情况，。 可以通过jmap 命令看看到底需要多少。</p><p>e: -XX:MaxPermSize=         </p><p>指定 Perm Generation 的最大值 , 如 :-XX:MaxPermSize=64m</p><p>f: -Xss                     </p><p>指定线程桟大小 , 如 :-Xss128k， 一般来说，webx框架下的应用需要256K。 如果你的程序有大规模的递归行为， 请考虑设置到512K／1M。 这个需要全面的测试才能知道。 不过， 256K已经很大了。 这个参数对性能的影响比较大的。</p><p>g: -XX:NewRatio=</p><p>指定 jvm 中 Old Generation heap size 与 New Generation 的比例 , 在使用 CMS GC 的情况下此参数失效 , 如 :-XX:NewRatio=2</p><p>h: -XX:SurvivorRatio=</p><p>指定 New Generation 中 Eden Space 与一个 Survivor Space 的 heap size 比例 ,-XX:SurvivorRatio=8, 那么在总共 New Generation 为 10m 的情况下 ,Eden Space 为 8m</p><p>i: -XX:MinHeapFreeRatio=</p><p>指定 jvm heap 在使用率小于 n 的情况下 ,heap 进行收缩 ,Xmx==Xms 的情况下无效 , 如 :-XX:MinHeapFreeRatio=30</p><p>j: -XX:MaxHeapFreeRatio=</p><p>指定 jvm heap 在使用率大于 n 的情况下 ,heap 进行扩张 ,Xmx==Xms 的情况下无效 , 如 :-XX:MaxHeapFreeRatio=70</p><p>k: -XX:LargePageSizeInBytes=</p><p>指定 Java heap 的分页页面大小 , 如 :-XX:LargePageSizeInBytes=128m</p><p>2: garbage collector</p><p>a: -XX:+UseParallelGC</p><p>指定在 New Generation 使用 parallel collector, 并行收集 , 暂停 app threads, 同时启动多个垃圾回收 thread, 不能和 CMS gc 一起使用 . 系统吨吐量优先 , 但是会有较长长时间的 app pause, 后台系统任务可以使用此 gc</p><p>b: -XX:ParallelGCThreads=</p><p>指定 parallel collection 时启动的 thread 个数 , 默认是物理 processor 的个数 ,</p><p>c: -XX:+UseParallelOldGC</p><p>指定在 Old Generation 使用 parallel collector</p><p>d: -XX:+UseParNewGC</p><p>指定在 New Generation 使用 parallel collector, 是 UseParallelGC 的 gc 的升级版本 , 有更好的性能或者优点 , 可以和 CMS gc 一起使用</p><p>e: -XX:+CMSParallelRemarkEnabled</p><p>在使用 UseParNewGC 的情况下 , 尽量减少 mark 的时间</p><p>f: -XX:+UseConcMarkSweepGC</p><p>指定在 Old Generation 使用 concurrent cmark sweep gc,gc thread 和 app thread 并行 ( 在 init-mark 和 remark 时 pause app thread). app pause 时间较短 , 适合交互性强的系统 , 如 web server</p><p>g: -XX:+UseCMSCompactAtFullCollection</p><p>在使用 concurrent gc 的情况下 , 防止 memory fragmention, 对 live object 进行整理 , 使 memory 碎片减少</p><p>h: -XX:CMSInitiatingOccupancyFraction=</p><p>指示在 old generation 在使用了 n% 的比例后 , 启动 concurrent collector, 默认值是 68, 如 :-XX:CMSInitiatingOccupancyFraction=70</p><p>有个 bug, 在低版本(1.5.09 and early)的 jvm 上出现 , <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6486089" target="_blank" rel="noopener">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6486089</a></p><p>i: -XX:+UseCMSInitiatingOccupancyOnly</p><p>指示只有在 old generation 在使用了初始化的比例后 concurrent collector 启动收集</p><p>3:others</p><p>a: -XX:MaxTenuringThreshold=</p><p>指定一个 object 在经历了 n 次 young gc 后转移到 old generation 区 , 在 linux64 的 java6 下默认值是 15, 此参数对于 throughput collector 无效 , 如 :-XX:MaxTenuringThreshold=31</p><p>b: -XX:+DisableExplicitGC</p><p>禁止 java 程序中的 full gc, 如 System.gc() 的调用. 最好加上么， 防止程序在代码里误用了。对性能造成冲击。</p><p>c: -XX:+UseFastAccessorMethods</p><p>get,set 方法转成本地代码</p><p>d: -XX:+PrintGCDetails</p><p>打应垃圾收集的情况如 :</p><p>[GC 15610.466: [ParNew: 229689K-&gt;20221K(235968K), 0.0194460 secs] 1159829K-&gt;953935K(2070976K), 0.0196420 secs]</p><p>e: -XX:+PrintGCTimeStamps</p><p>打应垃圾收集的时间情况 , 如 :</p><p>[Times: user=0.09 sys=0.00, real=0.02 secs]</p><p>f: -XX:+PrintGCApplicationStoppedTime</p><p>打应垃圾收集时 , 系统的停顿时间 , 如 :</p><p>Total time for which application threads were stopped: 0.0225920 seconds</p><p>4: a web server product sample and process</p><p>JAVA_OPTS=” -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 “</p><p>最初的时候我们用 UseParallelGC 和 UseParallelOldGC,heap 开了 3G,NewRatio 设成 1. 这样的配置下 young gc 发生频率约 12,3 妙一次 , 平均每次花费 80ms 左右 ,full gc 发生的频率极低 , 每次消耗 1s 左右 . 从所有 gc 消耗系统时间看 , 系统使用率还是满高的 , 但是不论是 young gc 还是 old gc,applicaton thread pause 的时间比较长 , 不合适 web 应用 . 我们也调小 New Generation 的 , 但是这样会使 full gc 时间加长 .</p><p>后来我们就用 CMS gc(-XX:+UseConcMarkSweepGC), 当时的总 heap 还是 3g, 新生代 1.5g 后 , 观察不是很理想 , 改为 jvm heap 为 2g 新生代设置 -Xmn1g, 在这样的情况下 young gc 发生的频率变成 ,7,8 妙一次 , 平均每次时间 40~50 毫秒左右 ,CMS gc 很少发生 , 每次时间在 init-mark 和 remark(two steps stop all app thread) 总共平均花费 80~90ms 左右 .</p><p>在这里我们曾经 New Generation 调大到 1400m, 总共 2g 的 jvm heap, 平均每次 ygc 花费时间 60~70ms 左右 ,CMS gc 的 init-mark 和 remark 之和平均在 50ms 左右 , 这里我们意识到错误的方向 , 或者说 CMS 的作用 , 所以进行了修改</p><p>最后我们调小 New Generation 为 256m,young gc 2,3 秒发生一次 , 平均停顿时间在 25 毫秒左右 ,CMS gc 的 init-mark 和 remark 之和平均在 50ms 左右 , 这样使系统比较平滑 , 经压力测试 , 这个配置下系统性能是比较高的</p><p>在使用 CMS gc 的时候他有两种触发 gc 的方式 :gc 估算触发和 heap 占用触发 . 我们的 1.5.0.09 环境下有次 old 区 heap 占用再 30% 左右 , 她就频繁 gc, 个人感觉系统估算触发这种方式不靠谱 , 还是用 heap 使用比率触发比较稳妥 .</p><p>这些数据都来自 64 位测试机 , 过程中的数据都是我在 jboss log 找的 , 当时没有记下来 , 可能存在一点点偏差 , 但不会很大 , 基本过程就是这样 .</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5: 总结"></a>5: 总结</h1><p>web server 作为交互性要求较高的应用 , 我们应该使用 Parallel+CMS,UseParNewGC 这个在 jdk6 -server 上是默认的 ,new generation gc, 新生代不能太大 , 这样每次 pause 会短一些 .CMS mark-sweep generation 可以大一些 , 可以根据 pause time 实际情况控制。</p><p>原文地址： <a href="http://vanadiumlin.iteye.com/blog/1267857" target="_blank" rel="noopener">http://vanadiumlin.iteye.com/blog/1267857</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;堆-Heap&quot;&gt;&lt;a href=&quot;#堆-Heap&quot; class=&quot;headerlink&quot; title=&quot;堆/Heap&quot;&gt;&lt;/a&gt;堆/Heap&lt;/h2&gt;&lt;p&gt;JVM管理的内存叫堆；在32Bit操作系统上有4G的限制，一般来说Windows下为2G，而Linux 下为3G；64Bit的就没有这个限制。&lt;br&gt;JVM初始分配的内存由-Xms指定，默认是物理内存的1/64但小于1G。&lt;br&gt;JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4但小于1G。&lt;br&gt;默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以由 -XX:MinHeapFreeRatio=指定。&lt;br&gt;默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以由 -XX:MaxHeapFreeRatio=指定。&lt;br&gt;服务器一般设置-Xms、-Xmx相等以避免在每次GC后调整堆的大小，所以上面的两个参数没啥用。  &lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jiaxiaoxuan.top/categories/java/"/>
    
    
      <category term="jvm" scheme="http://jiaxiaoxuan.top/tags/jvm/"/>
    
      <category term="java" scheme="http://jiaxiaoxuan.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>javaEE概念介绍</title>
    <link href="http://jiaxiaoxuan.top/2017/09/23/javaEE%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jiaxiaoxuan.top/2017/09/23/javaEE概念介绍/</id>
    <published>2017-09-23T15:09:25.000Z</published>
    <updated>2018-01-02T15:02:41.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这篇文章主要介绍在J2EE范例中使用的缩写词和概念。J2EE（Java2 Platform,EntrepriseEdition）代表Java企业版平台。它使得模块化的Java程序可以在服务器上部署。 JavaSE是一组Java核心库，Java应用程序在其上得以执行，而J2EE是基于Java SE的。</p><h3 id="概念综述"><a href="#概念综述" class="headerlink" title="概念综述"></a>概念综述</h3><p>  在我们深入J2EE之前，先看一下综述：</p><ol><li><em>多层式应用（Multitier Application）</em><br> 多层式应用（或者多层式架构）分成多个逻辑部分，大多在多层服务器上实现。<br> 在多层服务器上实现。例如，三层应用模型：用户和浏览器，应用服务器，数据库服务器。其中应用服务器和数据库服务器就是分别在不同的服务器上来处理应<br> 用的请求。</li><li><em>多层式服务（Multitier Service）</em><br>以三层架构模型的服务为例，应用服务器响应用户的请求。数据库服务器响应应用服务器的查询求情。</li><li><em>Java Bean</em><br>由一些包含私有属性的Java类组成，对外提供get和set方法。从技术上讲，这些类必须保证有一个不含参数的构造器并且实现Serializable接口。  </li></ol><a id="more"></a><h3 id="J2EE-5的概念"><a href="#J2EE-5的概念" class="headerlink" title="J2EE 5的概念"></a>J2EE 5的概念</h3><p><img src="/images/javaEE.jpeg" alt="image">     </p><ul><li><strong>Java EE应用程序模型</strong>——这个模型描述了一个实现服务的多层架构。“什么是服务”没有明确的界限。事实上，服务只是一个逻辑上的概念，它的对应实体取决于应用实现的概念。例如，客户端/服务器模型就是一种服务。  </li><li><strong>Java EE 服务</strong>——这是一个J2EE中三层架构的应用服务范例。它是由网页层（服务JSP页面）和事务层（管理企业的数据层）组成的。  </li><li><strong>Java EE 组件</strong>——“组件”是指独立的软件单元，可以和其他的组件组合来建立一个应用。</li></ul><hr><pre><code>1、Web组件（Web Component）——web端生成的页面或者对用户请求的返回。代表性的有： Java Servlets, JavaServer Faces 和 Java Server Pages.   2、小程序（Applet）——一个小型的Java应用程序可以作为响应的一部分返回给用户，用户可以在他们的浏览器上运行此程序。这种小型的程序是Javascript的竞争对手。    3、户端程序（Application Client）——例如，一个用Java写的桌面应用程序。  4、EJB（Enterprise Java Beans）——见下文。</code></pre><hr><ul><li><strong>Java EE 客户端</strong>——这个概念中包含三个其他的概念：</li></ul><hr><pre><code>○ 网页客户端（Web Client）或小型客户端（thin client）——以前（也不是非常久以前），客户端的请求返回的网页会包含脚本代码，这些代码会在应用服务器上执行了再将运行结果返回给客户端。这就是EE客户端。比如，用户可以查询员工的信息，并且对不同的结果按照他们喜欢的方式排列。现在，大多数开发者都不是在网页中使用脚本了，因为这不是个好习惯。他们更喜欢使用MVC设计原则，即禁止在网页中使用脚本。   ○ 小程序（Applet）   ○ 应用客户端（Application Client）  </code></pre><hr><ul><li><strong>Java EE 服务器通信（Java EE Server Communication）</strong>——这是指发生在小型客户端和应用客户端之间在服务器上的通信。具有代表性的是，小型客户端和小程序在Web层通信，但是应用客户端在EJB通信。 你觉得这不够清晰是吗？你觉得这很麻烦是吗？这就对了！这就是REST以及MVC设计原理现在在开发中流行的缘故。  </li><li><strong>EJB (企业级Java Beans，Enterprise Java Beans)</strong>——这是一个逻辑概念，与传统的Java Beans无关。它主要试图从多重应用的后端（也就是服务器端）来压缩事务逻辑。其中一个它试图解决的问题是确保数据库中事务处理的完整性。警告：EJB有多个版本，并且3.0版本已经从早期的版本分离出来。</li><li><strong>JavaBean Component</strong>——Java Bean 的同义词，主要用在JSP范例中。  </li><li><strong>Java EE容器（Java EE Container）</strong>——这是部署组装Java EE组件的地方（也就是应用程序服务器）。它定义了Web容器（包含servlets和JSP），还定义了EJB容器（包含的企业级Java Bean）以及应用客户端容器（运行独立的应用程序）和在浏览器上运行的小程序容器。</li><li><strong>部署描述符（Deployment Descriptor ）</strong>——这是一个为打包好的应用提供部署信息的XML文件。  </li><li><strong>SOAP(简单对象访问协议，Simple Object Access Protocol)</strong>——这是一个通过网络提供的服务传输信息的协议。信息是通过XML构建的，能够通过多个传输交换层，多数情况下是HTTP。SOAP是JSON和REST-like服务的竞争对手。  </li><li><strong>WSLD（网络服务描述语言，Web Service Description Language）</strong>——它用XML文件来描述了网络服务（名字，地点，通信模式）。  </li><li><strong>UDDI（通用描述、发现与集成服务，Universal Description, Discovery and Integration）</strong>——一种ebXML规范，可以在线发布有关产品和服务的信息。  </li><li><strong>Java Servlet</strong>——是用Java写的一个服务器端小程序，可以处理用户的HTTP请求，返回结果。  </li><li><strong>JSP (JavaServer Page)</strong>——一种基于HTML文件（就是一个模板）处理之后能够生成静态内容。可以包含脚本代码的片段，以在最终生成的脚本静态文件中生成。</li><li><strong>JSTL (JSP标准标签库，JavaServer Page Standard Tag Library)</strong>——一组可以模仿脚本代码功能的用在JSP的标准标签。例如，遍历客户端并显示他们对应的信息。现在，在JSP中，这样的标签已经已经取代了脚本代码。一般用于生成需要填充信息的页面。</li><li><strong>JSF (Java Server Face)</strong>——包含JSF标签（类似于LSTL标签）的JSP页面。此外，JSF允许在页面中定义导航模块（类似于Spring web flow），包括Facelets。</li><li><strong>Facelets</strong>——Facelets是JSF的MVC视图部分。它的主要功能是利用提供的数据（例如客户端列表）将模板转换成HTML文件。它也可以将生成的文件（例如HTML主体）提取出来一部分并到另一个模板中，相当于Sitemesh。</li><li><strong>The Java API for XML-based Web Services (Java中用来创建基于XML的Web的API，JAX-WS)</strong>——对于使用XML通信的Web服务来说至关重要。</li><li><strong>The Java API for XML Binding (序列化为XML的API，JAXB)</strong>——一种可以在JavaBeans和XML文件之间相互转化的方式。</li><li><strong>JTA (Java事务处理API，Java Transaction API)</strong> ——划清数据库中上行和下行的通信界限。</li><li><strong>JMS（Java信息服务，Java Message Service）</strong>——这个API保证服务器和应用在网络上的通信可靠、异步。ActiveMQ实现了JMS。</li><li><strong>JavaMail API</strong>——提供通过应用程序发送邮件方式。</li><li><strong>JAXP（加工XML文件的API，Java API for XML Processing）</strong>——提供了处理XML文件的方式。</li><li><strong>JAXR（提供XML注册的API，Java API for XML Registries)</strong>——一个可以注册包含了元数据的XML的API。</li><li><strong>JDBC（Java数据库连接，Java Database Connectivity）</strong>——这个API可以使应用程序直接通过SQL通信来访问数据库。</li><li><strong>JCA（J2EE连接器架构，Java EE Connector Architecture)</strong>——使应用程序能和信息系统（通常是数据库）通信。</li><li><strong>JPA(Java持久化API，Java Persistence API)</strong>——这是一个在数据库中存储对象的ORM（对象关系表，Object/relational mapping)定义。</li><li><strong>JNDI（Java命名和目录接口）</strong>——一种能存储和检索资源或者通过名字查找信息的方式，</li><li><strong>JAAS（Java鉴别与授权服务，Java Authentication and Authorization Service)</strong>——识别并控制服务权限的一张方式。<h3 id="J2EE-6的概念"><a href="#J2EE-6的概念" class="headerlink" title="J2EE 6的概念"></a>J2EE 6的概念</h3>在J2EE6中，大量的配置可以在源代码中执行。  </li><li><strong>JAX-RS</strong>——定义REST（含状态传输）之类的服务的API。</li><li><strong>Managed Beans</strong>——一个可以执行嵌入代码的Java对象。在Sping框架中，这是一些添加了@Autowired注释的对象。</li><li><strong>CDI（上下文和依赖注入，Contexts and Dependency Injection for Java EE）</strong>——CDI是Java EE整个下一代类型安全的依赖注入的事实上的API。在Sping框架中，应用程序可以设计应用的上下文，控制反转（IoC）和依赖注入功能（DI）。Bean确认——通过设定好的规则判断Java Beans的状态是有效的。</li><li><strong>JACC（Java Authorization Contract for Containers）</strong>——在J2EE应用服务器和特定的授权认证服务器之间定义的一个连接的协约。</li><li><strong>JASPIC（Java认证服务提供者接口，Java Authentication Service Provider Interface）</strong>——这是与JACC互补认证的SPI（也就是服务API，Service API）。它定义了应用程序如何通过传统的认证服务。</li></ul><hr><p>总体上说，J2EE和Spring框架慢慢的朝着一个相同的方向发展。</p><hr><p>原文链接：<a href="https://www.javaworld.com/article/2366964/learn-java/article.html" target="_blank" rel="noopener">javacodegeeks</a>  翻译：<a href="http://www.importnew.com/author/laixintao" target="_blank" rel="noopener">赖 信涛</a><br>译文链接：<a href="http://www.importnew.com/10716.html" target="_blank" rel="noopener">http://www.importnew.com/10716.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;这篇文章主要介绍在J2EE范例中使用的缩写词和概念。J2EE（Java2 Platform,EntrepriseEdition）代表Java企业版平台。它使得模块化的Java程序可以在服务器上部署。 JavaSE是一组Java核心库，Java应用程序在其上得以执行，而J2EE是基于Java SE的。&lt;/p&gt;
&lt;h3 id=&quot;概念综述&quot;&gt;&lt;a href=&quot;#概念综述&quot; class=&quot;headerlink&quot; title=&quot;概念综述&quot;&gt;&lt;/a&gt;概念综述&lt;/h3&gt;&lt;p&gt;  在我们深入J2EE之前，先看一下综述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;多层式应用（Multitier Application）&lt;/em&gt;&lt;br&gt; 多层式应用（或者多层式架构）分成多个逻辑部分，大多在多层服务器上实现。&lt;br&gt; 在多层服务器上实现。例如，三层应用模型：用户和浏览器，应用服务器，数据库服务器。其中应用服务器和数据库服务器就是分别在不同的服务器上来处理应&lt;br&gt; 用的请求。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;多层式服务（Multitier Service）&lt;/em&gt;&lt;br&gt;以三层架构模型的服务为例，应用服务器响应用户的请求。数据库服务器响应应用服务器的查询求情。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Java Bean&lt;/em&gt;&lt;br&gt;由一些包含私有属性的Java类组成，对外提供get和set方法。从技术上讲，这些类必须保证有一个不含参数的构造器并且实现Serializable接口。  &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://jiaxiaoxuan.top/categories/java/"/>
    
    
      <category term="JavaEE" scheme="http://jiaxiaoxuan.top/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>hexo2 新建文章</title>
    <link href="http://jiaxiaoxuan.top/2017/09/16/hexo2-%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/"/>
    <id>http://jiaxiaoxuan.top/2017/09/16/hexo2-新建文章/</id>
    <published>2017-09-16T15:35:09.000Z</published>
    <updated>2017-11-15T10:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>或许您已经通Git + Hexo 搭建个人博客网站了解到如何通过HEXO + GIT 实现个人博客网站的建立。但是尽管您已经成功建立博客网站，但是你需要对网站做合适的配置和调整才能迎合你的网站要求。本文主要介绍HEXO的基本操作命令和网站的基本配置方法。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要围绕两部分进行介绍：</p><blockquote><p>1、HEXO的基本命令与基本目录结构<br>2、HEXO网站的配置文件与基本配置</p></blockquote><a id="more"></a><h3 id="HEXO的基本命令与基本目录结构"><a href="#HEXO的基本命令与基本目录结构" class="headerlink" title="HEXO的基本命令与基本目录结构"></a>HEXO的基本命令与基本目录结构</h3><h4 id="基本目录结构"><a href="#基本目录结构" class="headerlink" title="基本目录结构"></a>基本目录结构</h4><p>主目录 </p><hr><pre><code> 主目录├── .deploy       #需要部署的文件├── node_modules  #Hexo插件├── public        #生成的静态网页文件├── scaffolds     #模板├── source        #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里|   ├── _drafts   #草稿|   └── _posts    #文章├── themes        #主题├── _config.yml   #全局配置文件└── package.json</code></pre><hr><p>  主题目录</p><hr><pre><code>主目录├── languages          #国际化|   ├── default.yml    #默认|   └── zh-CN.yml      #中文├── layout             #布局|   ├── _partial       #局部的布局|   └── _widget        #小挂件的布局├── script             #js脚本├── source             #源代码文件|   ├── css            #CSS|   |   ├── _base      #基础CSS|   |   ├── _partial   #局部CSS|   |   ├── fonts      #字体|   |   ├── images     #图片|   |   └── style.styl #style.css|   ├── fancybox       #fancybox|   └── js             #js├── _config.yml        #主题配置文件└── README.md          #主题介绍</code></pre><p>以上目录，并不一一介绍，我们主要了解其中主要的部分：<br>主目录常用部分：<br>scaffolds<br>source<br>themes<br>config.yml<br>主题目录：<br>看需要，日常操作都会涉及到：但主要的还是config.yml、languages等。<br>接下来，我们继续根据目录介绍涉及的部分，站点配置部分更多涉及主题目录的配置。   </p><h4 id="HEXO的基本命令"><a href="#HEXO的基本命令" class="headerlink" title="HEXO的基本命令"></a>HEXO的基本命令</h4><p>每次部署的步骤，可按以下三步来进行。 </p><hr><pre><code>hexo clean      #清除PUBLIC和编译文件hexo generate   #编译网站目录hexo deploy     #同步到GIT 或者CODINGnpm install &lt;plugin-name&gt; --save #安装npm update #升级npm uninstall &lt;plugin-name&gt; #卸载</code></pre><hr><p>一些常用命令：</p><p>hexo new”postName” #新建文章 #存放在主目录的source下的POST目录下 </p><p>hexo new page”pageName” #新建页面 </p><p>hexo generate #生成静态页面至public目录 </p><p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） </p><p>hexo deploy #将.deploy目录部署到GitHub </p><p>hexo help # 查看帮助 </p><p>hexo version #查看Hexo的版本 </p><h3 id="HEXO网站的配置文件与基本配置"><a href="#HEXO网站的配置文件与基本配置" class="headerlink" title="HEXO网站的配置文件与基本配置"></a>HEXO网站的配置文件与基本配置</h3><h4 id="HEXO网站的配置文件"><a href="#HEXO网站的配置文件" class="headerlink" title="HEXO网站的配置文件"></a>HEXO网站的配置文件</h4><blockquote><p>在根目录下的_config.yml主要是对网站的总属性进行设置<br> 如：网站标题，网站logo,网站插件使用等全局的属性<br>主题目录下的_config.yml主要是针对网站的布局，导航等特性设置进行设置</p></blockquote><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>主配置文件介绍</p><pre><code>--- 主配置文件 # Site #站点信息 title: lmintlcx #标题 subtitle: 做人不卖萌跟咸鱼有什么区别 #副标题 description: lmintlcx lm lcx blog #描述 author: lmintlcx #作者 language: zh-Hans #语言 timezone: Asia/Shanghai #时区 # URL #链接格式 url: http://joryhe.coding.me/ #网址 root: / #根目录 permalink: post/:title.html #文章的链接格式 permalink_defaults: # Directory #目录 source_dir: source #源文件 public_dir: public #生成的网页文件 tag_dir: tags #标签 archive_dir: archives #归档 category_dir: categories #分类 code_dir: downloads/code i18n_dir: :lang #国际化 skip_render: # Writing #写作 new_post_name: :title.md #新文章标题 default_layout: post #默认模板 titlecase: false #标题转换成大写 external_link: true #新标签页里打开连接 filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: #语法高亮   enable: true   line_number: false #显示行号   auto_detect: true   tab_replace: # Category &amp; Tag #分类和标签 default_category: uncategorized #默认分类 category_map: tag_map: # Date / Time format #日期时间格式 date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination #分页 per_page: 20 #每页文章数, 设置成 0 禁用分页 pagination_dir: page # Extensions #插件和主题 ## 插件: http://hexo.io/plugins/ ## 主题: http://hexo.io/themes/ theme: next # Deployment #部署, joryhe是我的用户名, 同时发布GitHub  deploy:   type: git   repo:      github: github: git@github.com:joryhe/joryhe.github.io.git,master # Disqus #Disqus评论系统 disqus_shortname:  plugins: #插件，例如生成 RSS 和站点地图的 - hexo-generator-feed - hexo-generator-sitemap---</code></pre><h4 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h4><pre><code>---   主题配置文件   menu: #菜单     home: / #首页     archives: /archives #归档     about: /about #关于     #commonweal: /404.html #公益404     #tags: /tags #标签     #categories: /categories #分类   ## 经典介绍配置   # 小图标   favicon: /favicon.ico   # 默认关键词   keywords:    # 留空使用默认的, false 禁用, 也可以写指定的地址   rss:   # Icon fonts   # default | linecons | fifty-shades | feather   icon_font: default   # 代码高亮主题 https://github.com/chriskempson/tomorrow-theme   # normal | night | night eighties | night blue | night bright   highlight_theme: normal   # MathJax Support #数学公式   mathjax: true   # Schemes #启用主题中的主题Mist   scheme: Mist   # 侧边栏   #  - post    只在文章页面显示   #  - always  所有页面显示   #  - hide    隐藏   sidebar: always   # 自动滚动到&quot;阅读更多&quot;标记的下面   scroll_to_more: true   # 自动给目录添加序号   toc_list_number: true   # 自动截取摘要   auto_excerpt:     enable: false     length: 150   # Lato 字体   use_font_lato: true   # Make duoshuo show UA   # user_id must NOT be null when admin_enable is true!   # you can visit http://dev.duoshuo.com get duoshuo user id.   duoshuo_info:     ua_enable: true     admin_enable: false     user_id: 0     #admin_nickname: ROOT   ## DO NOT EDIT THE FOLLOWING SETTINGS   ## UNLESS YOU KNOW WHAT YOU ARE DOING   # 动画   use_motion: true   # Fancybox 看图插件   fancybox: true   # Static files   vendors: vendors   css: css   js: js   images: images   # Theme version   version: 0.4.5.1---    </code></pre><h5 id="添加小图标"><a href="#添加小图标" class="headerlink" title="添加小图标"></a>添加小图标</h5><p>将 favicon.ico 文件放在 source 目录下, 修改主题配置文件</p><hr><pre><code>codefavicon: /favicon.ico</code></pre><hr><p>####语言设置 <strong>主要语言代码：</strong> English (en) 中文简体 (zh-Hans) French (fr-FR) 正体中文 (zh-hk/zh-tw) Russian (ru) German (de) <strong>站点配置文件下定义语言：</strong></p><pre><code>code   language: zh-hk </code></pre><p>菜单导航栏设置<br>配置在主题配置文件下</p><pre><code>code    menu:      home: /      archives: /archives      categories: /categories      tags: /tags      commonweal: /404.html      about: /about</code></pre><p>新增标签页<br>使用命令hexp new page “tags” 并将页面类型设置为tags</p><pre><code>code   title: tags   date: 2016-04-19 22:37:08   type: &quot;tags&quot;</code></pre><p>通常情况下你的标签页并不需要评论框，取消评论代码</p><pre><code>code   title: tags   date: 2016-04-19 22:37:08   type: &quot;tags&quot;   comments: false</code></pre><p>在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到标签导航栏</p><pre><code>code   menu:        tags: /tags</code></pre><p>新增分类页</p><p>使用命令hexp new page categories 并将页面类型设置为categories</p><pre><code>code   title: categories   date: 2016-04-19 22:38:00   type: &quot;categories&quot;</code></pre><p>通常情况下你的标签页并不需要评论框，取消评论代码</p><pre><code>code    title: categories    date: 2016-04-19 22:38:00    type: &quot;categories&quot;    comments: false</code></pre><p>在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到分类导航栏</p><pre><code>code     menu:        categories: /categories</code></pre><p>关于自己颜面about</p><pre><code>hexo new page “about”新增about页面</code></pre><p>编辑source/about/index.md:<br>添加菜单导航，在主题配置文件</p><pre><code>code    menu:     about: /about</code></pre><p>RSS设置<br>NPM install hexo-generator-feed安装RSS插件<br>编辑主题配置文件 rss 字段</p><pre><code>code    rss: true</code></pre><p>正常情况下，会在你的网站根目录下生成atom.xml<br>侧栏设置<br>post - 默认行为, 在文章页面(拥有目录列表)时显示<br>always - 在所有页面中都显示<br>hide - 在所有页面中都隐藏(可以手动展开)。</p><pre><code>code    sidebar: post</code></pre><p>####头像设置 编辑站点配置文件, 新增字段 avatar</p><pre><code>code    avatar: /images/xxx.jpg</code></pre><p>作者名称</p><p>编辑站点配置文件的author<br>站点描述设置</p><p>编辑站点配置文件的description<br>侧边栏社交链接</p><p>站点配置文件新增字段 social, 然后添加社交站点名称与地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">code</div><div class="line">    # Social links</div><div class="line">        social:</div><div class="line">          GitHub: https://github.com/lmintlcx</div><div class="line">          Twitter: https://twitter.com/lmintlcx</div><div class="line">          Zhihu: http://www.zhihu.com/people/lmintlcx</div><div class="line">          Douban: http://www.douban.com/people/lmintlcx</div><div class="line">          #Weibo: http://weibo.com/lmlcx</div></pre></td></tr></table></figure></p><p>腾讯公益 404 页面<br>source 目录下新建 404.html 页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">code</div><div class="line">    &lt;!DOCTYPE HTML&gt;</div><div class="line">    &lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">      &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</div><div class="line">      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</div><div class="line">      &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</div><div class="line">      &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;your-site-url&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;/html&gt;</div></pre></td></tr></table></figure></p><p>文章摘录<br>NexT 支持三种方式来控制首页文章的显示方式</p><blockquote><p>1.在文章中使用 手动进行截断<br>2.在文章的 front-matter 中添加 description, 内容为文章摘要<br>3.自动形成摘要, 在主题配置文件中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">code</div><div class="line">    auto_excerpt:</div><div class="line">      enable: true</div><div class="line">      length: 150 #默认截取的长度为 150 字符</div></pre></td></tr></table></figure></p></blockquote><p>设定首页/归档/标签页面文章的篇数<br>安装以下插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">code</div><div class="line">    hexo-generator-index</div><div class="line">    hexo-generator-archive</div><div class="line">    hexo-generator-tag</div></pre></td></tr></table></figure></p><p>站点配置文章中设定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">index_generator:</div><div class="line">  per_page: 5</div><div class="line"></div><div class="line">archive_generator:</div><div class="line">  per_page: 20</div><div class="line">  yearly: true</div><div class="line">  monthly: true</div><div class="line"></div><div class="line">tag_generator:</div><div class="line">  per_page: 10</div></pre></td></tr></table></figure></p><p>畅言评论系统</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;或许您已经通Git + Hexo 搭建个人博客网站了解到如何通过HEXO + GIT 实现个人博客网站的建立。但是尽管您已经成功建立博客网站，但是你需要对网站做合适的配置和调整才能迎合你的网站要求。本文主要介绍HEXO的基本操作命令和网站的基本配置方法。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要围绕两部分进行介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、HEXO的基本命令与基本目录结构&lt;br&gt;2、HEXO网站的配置文件与基本配置&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hexo教程" scheme="http://jiaxiaoxuan.top/categories/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://jiaxiaoxuan.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>生平简介-未完待续～～～～～～</title>
    <link href="http://jiaxiaoxuan.top/2017/06/16/about/"/>
    <id>http://jiaxiaoxuan.top/2017/06/16/about/</id>
    <published>2017-06-16T15:35:09.000Z</published>
    <updated>2018-01-02T15:02:41.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="岛屿"><a href="#岛屿" class="headerlink" title="岛屿:"></a>岛屿:</h2><p>瞧到我的简历你一定很开心吧^_^,相信我能给你带来好运，我也相信每个看我简历的人也能给我带来好运！</p><p>##基本情况<br>姓名：贾新轩<br>高度：170<br>性别：男<br>妈妈生我的那一天：1995年正月19日<br>性格：活泼开朗，热爱生活，爱睡懒觉，不喜熬夜但忍不住不熬夜…….,洁身自好，至今单身。</p><h2 id="教育情况"><a href="#教育情况" class="headerlink" title="教育情况"></a>教育情况</h2><p>你没听说过的大学：商丘师范学院<br>本科学历，学士学位。<br><strong>校园生活：</strong><br>丰富而多彩，深得广大师生的好评。学习不怎么优秀，因为考的分不高….平常爱打球，不会打篮球，就是羽毛球、排球之类的，偶尔踢个足球，<br>拥有一批爱球的好友，一起玩了四年，大学最后一场运动就是打排球……天黑以后喜欢去机房，基本10点以后回寝室，在<br>机房和学长敲敲代码，和同学拆拆电脑，换个硬盘啥的。最后我成学长了就教学妹们敲代码拆电脑什么的，很感谢我的学长<br>教我Java和C语言，带我搭建人生的第一个网站，感谢老师给我开小灶。搞过ACM，写过Android程序，搞过JSP网站，都是小打小闹了，<br>比不上大神啊。那时候的小网站，小程序，现在想想真low……,啥也不说了！我还有一群快乐的小学弟学妹，可是我已经没他们厉害了，哎！！！！！！！</p><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><p>16年暑假出来实习，也很巧，暑假刚开始就在北京找到工作了，工作地点在京城烟花之地三里屯优衣库-大概两百米的SOHO办公区。<br>财新传媒有限公司，在里面做个小小的开发实习僧，从此九六五的生活。一直到现在，以后渴望去南方，上海、杭州等等城市，南方的<br>水养人，北方缺水……</p><p><em>重点来了</em></p><h2 id="工作技能"><a href="#工作技能" class="headerlink" title="工作技能"></a>工作技能</h2><p>主要从事服务器开发，擅长Java、JavaScript，也会点py,喜欢用py写个爬虫脚本什么的，方便快捷。<br>hibernate,spring系列（boot、MVC、templete、jpa、cloud）,mybatis,lucence,solr,mq等等，研读多springMVC和mybatis的源码，大学的时候读过jdk7的源码，熟悉微服务架构，有过<br>相关研究，财新公司就是微服务架构，那是我进入公司三个月之后来了两个新的架构师重新把财新的系统给设计了一遍。</p><h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><p>我的毕业设计：《基于nutch的全文搜索引擎》，在这个项目中，我了解并会使用nutch、solr、lucence,自己搭建的单机系统<br>以我学校官网为种子URL抓取。将抓取到的数据存到MySQL数据库中，再用solr建立索引，使用mmseg4j进行中文分词等等。<br>财新系列：<br>首先说明，财新传媒是以原创财经新闻为主的新闻出版公司。</p><ul><li>一线系统：<br>功能： 财新短消息新闻，股票涨跌等新闻。内容短小精悍。<br>技能： spring templete,struts2,spring mvc,spring</li><li>抢红包系统：<br>功能： 让拥有财新收费文章权限的人可以以红包分享的形式让没有权限的人阅读。就是把每次的分享当做红包，并对分享链接进行访问控制。<br>技能： 秒杀，redis,spring boot,mybatis等。</li><li>私房课系统：<br>功能：财新平台下的收费直播系统。<br>技能：ssm,Spring websocket。</li><li>SEO系统：<br>功能：热词推荐系统，SEO搜集关键词，导入系统生成关键词页面，搜索服务由财新搜索提供。<br>技能：spring data jpa,freemarker模板技术。</li><li>邮件发送系统：<br>功能:像财新订阅用户发送新闻咨询。<br>技能：ssm,邮件发送相关技术</li><li>兑换码系统：<br>功能:推广营销用的，生成二维码和兑换码，来获取财新收费文章的阅读权限<br>技能： ssm</li><li>CMS系统：<br>功能： 财新新闻内容管理系统，是编辑发新闻的主要地方，是财新核心的业务系统。<br>技能： velocity模板开发，groovy脚本编写。<br>以上就是我写过或者维护过的系统。由于平常使用乌班图系统开发，所以很熟悉Linux系统。会使用nginx,能编写简单的bash脚本。<br>工作遇到过的问题解决方式，都在博客上，有些可能没有放上去，在有道云笔记里面。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;岛屿&quot;&gt;&lt;a href=&quot;#岛屿&quot; class=&quot;headerlink&quot; title=&quot;岛屿:&quot;&gt;&lt;/a&gt;岛屿:&lt;/h2&gt;&lt;p&gt;瞧到我的简历你一定很开心吧^_^,相信我能给你带来好运，我也相信每个看我简历的人也能给我带来好运！&lt;/p&gt;
&lt;p&gt;##基本情况&lt;br&gt;姓
      
    
    </summary>
    
      <category term="about" scheme="http://jiaxiaoxuan.top/categories/about/"/>
    
    
      <category term="about" scheme="http://jiaxiaoxuan.top/tags/about/"/>
    
  </entry>
  
</feed>
