<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小咸菜</title>
  
  <subtitle>海到无边天做涯，山登绝顶我为峰。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiaxiaoxuan.top/"/>
  <updated>2018-05-27T13:52:15.452Z</updated>
  <id>http://jiaxiaoxuan.top/</id>
  
  <author>
    <name>二月江北</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rancher1.6环境的搭建</title>
    <link href="http://jiaxiaoxuan.top/2018/05/27/Rancher1.6%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://jiaxiaoxuan.top/2018/05/27/Rancher1.6环境的搭建/</id>
    <published>2018-05-27T13:48:50.000Z</published>
    <updated>2018-05-27T13:52:15.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>docker容器的编排技术有好几种。比如Swarm、Kubernetes、Mesos,这几种都是比较成熟，用户量也是比较多的，其中swarm是docker公司的亲儿子，k8s是谷歌公司的，mesos是著名开源组织Apache的。我们公司偏偏选了个Rancher/Cattle，确实我很搞不懂，但是就我目前接触到的，自我感觉这个rancher还是很好用的。<br>ps1:知乎上关于编排工具的帖子 <a href="https://www.zhihu.com/question/55391506" target="_blank" rel="noopener">https://www.zhihu.com/question/55391506</a><br>ps2:容器编排工具 <a href="http://www.infoq.com/cn/articles/container-landscape-2016" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/container-landscape-2016</a></p><h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>在创作这篇文章的过程中，我发现一个问题，docker容器和容器编排工具以及图形管理界面到底是什么关系呢？比如rancher支持如下四种编排环境：Cattle/Kubernetes/Mesos/Swarm, Cattle是Rancher自己内置的缺省的编排环境，缺省的Default的即为Cattle类型的。这些编排工具又是运行在docker容器之上的。还有一些容器的辅助工具，这些有待一一理清。下面说的也许有不严禁之处，不过都是我个人见解，请见谅！</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在安装rancherr之前，必须先有一台安装好docker的Linux系统哦。我的是在本机做的实践。大致如下：  </p><ul><li>运行run命令，-d表示后台运行容器 -p 把容器的端口映射到主机的端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --restart=always -p 8080:8080 rancher/server</span><br></pre></td></tr></table></figure><p><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher1.png" alt="image"></p><ul><li>运行ps命令查看容器状态， -a是表示显示所有已创建容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure><p><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher2.png" alt="image">  </p><ul><li>查看本机内网IP（如果有公网IP最好）<a href="http://IP:8080,不要使用localhost和127.0.0.1这种本机IP" target="_blank" rel="noopener">http://IP:8080,不要使用localhost和127.0.0.1这种本机IP</a><br>你可以看右下角是可以选择语言的哦，如果你的英文不好，请选择汉语  </li></ul><p><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher3.png" alt="image">   </p><ul><li>创建权限认证<br>系统管理-》访问控制，选择本地认证  </li></ul><p><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher4.png" alt="image">     </p><ul><li>把自己的主机交给rancher管理<br>这一步rancher做的很人性化，每个步骤都提示的好好地，按照步骤来就可以了，不够要注意的是第四步，一定要填写公网IP或者域名，内网IP也可以，不过内网IP你切换网络可能就没有了。最重要的是不要填写127.0.0.1或者localhost这种地址</li></ul><p><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher5.png" alt="image">   </p><ul><li>在docker主机上运行rancher提供的命令安装rancher-agent<br><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher6.png" alt="image"> </li><li>运行命令 sudo docker logs -f 容器ID 查看rancher-agent安装日志<br><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher7.png" alt="image"> </li><li>如果出现了这个问题<br><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher8.png" alt="image"> <ul><li>答案在这里—》<a href="https://blog.csdn.net/qq_37146850/article/details/80089298" target="_blank" rel="noopener">https://blog.csdn.net/qq_37146850/article/details/80089298</a></li></ul></li><li>至此安装完毕<br><img src="http://jiaxiaoxuan.top/images/liganwangluo/rancher9.png" alt="image"> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;docker容器的编排技术有好几种。比如Swarm、Kubernetes、Mesos,这几种都是比较成熟，用户量也是比较多的，其中swarm
      
    
    </summary>
    
      <category term="立感网络" scheme="http://jiaxiaoxuan.top/categories/%E7%AB%8B%E6%84%9F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="rancher" scheme="http://jiaxiaoxuan.top/tags/rancher/"/>
    
      <category term="docker" scheme="http://jiaxiaoxuan.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>立感网络架构概述</title>
    <link href="http://jiaxiaoxuan.top/2018/05/27/%E7%AB%8B%E6%84%9F%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <id>http://jiaxiaoxuan.top/2018/05/27/立感网络架构概述/</id>
    <published>2018-05-27T08:52:45.000Z</published>
    <updated>2018-05-27T13:52:37.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>进入新公司-立感网络已经两个月了，业务和系统架构已经了解的非常清楚，趁着这几天比较闲，把架构给梳理一遍。一来整理下学到的东西，二来也给后人入手这套东西留下一份文档。</p><h2 id="业务概述"><a href="#业务概述" class="headerlink" title="业务概述"></a>业务概述</h2><p>立感网络是做物流保险行业的业务的。相当于卖保险的吧，也是给保险公司打工的。卖出一份保险公司的保险，公司会得到一份提成或者推广费之类的收益。同时我们也招收代理人，他们可以拿着产品去卖，当然这时我们也会收提成。</p><ol><li>需要对接保险公司</li><li>将保险公司的产品虚拟化为商品，让用户可以购买</li><li>招收代理人，就要有分销分账的机制</li></ol><p>根据以上的业务需求，新系统架构师采用的是当前比较热门的微服务架构，旧系统还是传统的SOA架构。新系统现阶段将业务划分为以下几个服务。</p><h2 id="服务的划分"><a href="#服务的划分" class="headerlink" title="服务的划分"></a>服务的划分</h2><h3 id="新系统采用的技术有："><a href="#新系统采用的技术有：" class="headerlink" title="新系统采用的技术有："></a>新系统采用的技术有：</h3><p>框架: Spring Cloud、Spring、Spring data jpa、Spring boot、Spring Mvc、Ibatis、Spring auth2。<br>数据库: MySql<br>构建工具:  Gradle<br>持续集成:  Jenkins+Gitlab<br>部署工具:  Docker+Runcher<br>服务网关:  kong、nginx<br>前端技术:  vue2.0+gulp+webpack-&gt;H5页面、angular+webpack-&gt;后台管理系统</p><h3 id="代码结构图"><a href="#代码结构图" class="headerlink" title="代码结构图"></a>代码结构图</h3><p><img src="http://jiaxiaoxuan.top/images/liganwangluo/fuwujiagou.png" alt="代码结构图"></p><ul><li>app<ul><li>专门为app服务的项目，提供和核心业务无关联的接口，但是是APP必须使用的接口。</li></ul></li><li>common<ul><li>作为所有项目的依赖，提供统一的工具、异常、分页、常量、模块间访问的VO等各模块公用的类。</li></ul></li><li>crm<ul><li>用户管理模块，负责用户登录验证、权限控制   </li></ul></li><li>message<ul><li>短信、邮件模块，接入阿里云短信服务，邮件服务</li></ul></li><li>payment<ul><li>支付模块，接入的是宝付的支付系统，因为宝付提供分账功能</li></ul></li><li>policy<ul><li>投保模块，提供投保工能，对接各个保险公司。</li></ul></li><li>product<ul><li>产品模块，将各个保险公司抽象为产品，提供产品查询设置功能 </li></ul></li><li>route<ul><li>Spring Cloud Eureka的注册中心 </li></ul></li><li>security<ul><li>安全模块，采用Spring auth2,作为各模块的依赖，提供统一的权限验证，跨域设置。</li></ul></li><li>task<ul><li>任务模块，对于非自动出单的保险产品，需要人工处理，这里提供一系列的处理流。<h3 id="对系统服务划分的思考"><a href="#对系统服务划分的思考" class="headerlink" title="对系统服务划分的思考"></a>对系统服务划分的思考</h3>以上服务的划分，都是我来之前架构师已经搭建好的，后来架构走了，这个系统的演变也就停止了。后来的许多开发者各自遵循自己的代码风格，导致代码难以维护，一些原本很好的设计，由于大家都不准守，也就成了摆设。在数据访问层各个开发者采用自己喜欢的crm框架，SQL语句散落于代码中间。出现错误时都难以调整。至于其他方面也是差异颇多。  <h6 id="服务的划分边界大体上是清晰的，架构师把握的也很好，如果由架构师不走，也许会演变的更好。对于服务的划分，我的理解是：以业务为导向，厘清业务之间的关系，划分出业务边界。同时抽象出各业务公用的业务，再次进行划分。最后将一些边缘业务整合在一起，作为补充。"><a href="#服务的划分边界大体上是清晰的，架构师把握的也很好，如果由架构师不走，也许会演变的更好。对于服务的划分，我的理解是：以业务为导向，厘清业务之间的关系，划分出业务边界。同时抽象出各业务公用的业务，再次进行划分。最后将一些边缘业务整合在一起，作为补充。" class="headerlink" title="服务的划分边界大体上是清晰的，架构师把握的也很好，如果由架构师不走，也许会演变的更好。对于服务的划分，我的理解是：以业务为导向，厘清业务之间的关系，划分出业务边界。同时抽象出各业务公用的业务，再次进行划分。最后将一些边缘业务整合在一起，作为补充。"></a>服务的划分边界大体上是清晰的，架构师把握的也很好，如果由架构师不走，也许会演变的更好。对于服务的划分，我的理解是：以业务为导向，厘清业务之间的关系，划分出业务边界。同时抽象出各业务公用的业务，再次进行划分。最后将一些边缘业务整合在一起，作为补充。</h6>老夫资质驽钝，天资所限。对于划分服务的思考也只总结出这些。随着时间的增长，自己阅历的增加，定能更好的把握好这些。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>业务，服务的划分大致上就是这些了，微服务架构是最近两年比较流行的，特别是Spring Cloud这一系列的，当然还有别的微服务框架，比如阿里的dubbo，新浪微博的Motan等等，架构和框架是两个概念，实现微服务架构的框架等待我们去挖掘。同时和微服务架构一起兴起的还有容器技术，比如他的代名词docker。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;进入新公司-立感网络已经两个月了，业务和系统架构已经了解的非常清楚，趁着这几天比较闲，把架构给梳理一遍。一来整理下学到的东西，二来也给后人入
      
    
    </summary>
    
      <category term="立感网络" scheme="http://jiaxiaoxuan.top/categories/%E7%AB%8B%E6%84%9F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="立感网络" scheme="http://jiaxiaoxuan.top/tags/%E7%AB%8B%E6%84%9F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="系统架构" scheme="http://jiaxiaoxuan.top/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jiaxiaoxuan.top/2018/03/09/2018%E6%98%A5%E5%AD%A3%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://jiaxiaoxuan.top/2018/03/09/2018春季面试总结/</id>
    <published>2018-03-09T15:18:38.957Z</published>
    <updated>2018-03-09T15:18:38.949Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 2018春季面试总结<br>toc: true<br>date: 2018-03-09 23:03:13<br>tags: 面试总结</p><h2 id="categories-面试总结"><a href="#categories-面试总结" class="headerlink" title="categories: 面试总结"></a>categories: 面试总结</h2><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>又到了一个跳槽求职的季节，在求职的过程中，我遇到的面试常问的一些面试问题，现在总结一下，以备后用。也希望面试官一直问我这些问题，<br>这样一来，我就什么都不怕了，反正都背下来了。</p><h1 id="自述类问题"><a href="#自述类问题" class="headerlink" title="自述类问题"></a>自述类问题</h1><ol><li>面试自我介绍</li><li>为什么换工作</li><li>举一个到两个项目难点<h1 id="技术类问题"><a href="#技术类问题" class="headerlink" title="技术类问题"></a>技术类问题</h1></li><li>sql调优</li><li>redis原理和应用</li><li>多线程</li><li>常用注解</li><li>反射和注解原理</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li>Linux的日志查询</li><li>spring boot 和 spring cloud 应用</li><li>常用查询sql</li><li>设计模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单例模式</span><br><span class="line">工厂模式</span><br><span class="line">代理模式</span><br></pre></td></tr></table></figure><ol start="13"><li>手写常用算法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二分查找</span><br><span class="line">数组合并</span><br><span class="line">Dijkstra算法</span><br><span class="line">Floyd算法</span><br><span class="line">快速排序算法</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 2018春季面试总结&lt;br&gt;toc: true&lt;br&gt;date: 2018-03-09 23:03:13&lt;br&gt;tags: 面试总结&lt;/p&gt;
&lt;h2 id=&quot;categories-面试总结&quot;&gt;&lt;a href=&quot;#categories-面试总结&quot; cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新年计划</title>
    <link href="http://jiaxiaoxuan.top/2018/01/25/%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    <id>http://jiaxiaoxuan.top/2018/01/25/新年计划/</id>
    <published>2018-01-25T15:08:16.000Z</published>
    <updated>2018-01-25T15:56:41.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>2017年已经过去半个多月了，到了这个份上也该计划一下自己2018年度的任务了，大概有以下几点：学习，情感，旅行，健身。怀着对过去的不舍，计划美好的将来。  </p><p><img src="/images/dayuhaitang-01.png" alt=""></p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>学习使我快乐，我热爱学习！我的学习任务大概有两个方向： </p><h2 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h2><ul><li>使用vue和react写一个商城</li><li>使用scrapy框架写一个分布式爬虫</li><li>学习SOA架构、微服务架构，把doubble框架学习一遍，深入学习分布式系统的开发</li><li>学习一下容器的使用</li><li>如有空闲时间再学习一下其他内容 </li></ul><h2 id="非专业"><a href="#非专业" class="headerlink" title="非专业"></a>非专业</h2><ul><li>看懂红楼梦</li><li>看几本世界名著</li><li>读一下柳永词  </li></ul><h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><ul><li>找一个女朋友，最好是能追上自己喜欢的她。  </li></ul><p><img src="/images/love/love.jpg" alt="">  </p><h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><ul><li>爬两个山</li><li>玩一下杭州，去一下厦门  </li></ul><h1 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h1><ul><li>腹肌，腹肌</li><li>让自己变得健康、自信  </li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2017已经远了，难道还要错过2018吗？再不伸手和疯狂，什么都没有了，趁着还能动，做自己想做的事，追自己想追的人。  </p><p><img src="/images/dayuhaitang.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;2017年已经过去半个多月了，到了这个份上也该计划一下自己2018年度的任务了，大概有以下几点：学习，情感，旅行，健身。怀着对过去的不舍，计
      
    
    </summary>
    
      <category term="杂记" scheme="http://jiaxiaoxuan.top/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="http://jiaxiaoxuan.top/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>vue-study-01-小例子及学习感想</title>
    <link href="http://jiaxiaoxuan.top/2018/01/22/vue-study-01/"/>
    <id>http://jiaxiaoxuan.top/2018/01/22/vue-study-01/</id>
    <published>2018-01-22T06:27:49.000Z</published>
    <updated>2018-01-25T16:01:27.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>前段去面试，目的并不是不是找什么工作，而是为了看看一年过去了，现在面试都会问那些东西。这不就是国道了vue.js,这个框架国产的，文档较多，既然问道了，我就要学习学习，更新一下自己的知识储备。<br>下面是学习的心得。</p><h1 id="vue-运行小例子"><a href="#vue-运行小例子" class="headerlink" title="vue 运行小例子"></a>vue 运行小例子</h1><p>这个官网入门例子中较为复杂的一个组件模板。</p><blockquote><p>vue组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注册一个vue组件</span><br><span class="line">Vue.component(&apos;todo-item&apos;, &#123;</span><br><span class="line">       props: [&apos;todo&apos;],</span><br><span class="line">       template: &apos;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&apos;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>组件实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-7&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      现在我们为每个 todo-item 提供 todo 对象</span><br><span class="line">      todo 对象是变量，即其内容可以是动态的。</span><br><span class="line">      我们也需要为每个组件提供一个“key”，稍后再</span><br><span class="line">      作详细解释。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;todo-item    v-for=&quot;item in groceryList&quot;      v-bind:todo=&quot;item&quot;      v-bind:key=&quot;item.id&quot;&gt;</span><br><span class="line">    &lt;/todo-item&gt;</span><br><span class="line">  &lt;/ol&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>数据</p><pre><code>var app7 = new Vue({   el: &apos;#app-7&apos;,   data: {       groceryList: [           { id: 0, text: &apos;蔬菜&apos; },           { id: 1, text: &apos;奶酪&apos; },           { id: 2, text: &apos;随便其它什么人吃的东西&apos; }       ]   }})</code></pre></blockquote><h1 id="我的理解和思考"><a href="#我的理解和思考" class="headerlink" title="我的理解和思考"></a>我的理解和思考</h1><p>vue里面有很多“v-”开头的命令，称之为指令。这个指令就是用来处理数据，vue容器负责解释执行。web页面中，每个功能都可以拆分模块，就如同Java里面的方法，能尽量抽象出来复用的就复用。将功能拆分为模块以后，关注点便集中在当前模块了。这时需要的便是数据和样式。操作就是根据数据来改变样式了，根据数据进行渲染。同时各个组件并不能孤立，而是相互联系的，可通信的。这就依赖于框架的设计了。就vue来说，组件的内容和数据是分离的。设计好组件内容以后，便只是关心数据了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;前段去面试，目的并不是不是找什么工作，而是为了看看一年过去了，现在面试都会问那些东西。这不就是国道了vue.js,这个框架国产的，文档较多，
      
    
    </summary>
    
      <category term="vue" scheme="http://jiaxiaoxuan.top/categories/vue/"/>
    
    
      <category term="vue" scheme="http://jiaxiaoxuan.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>红楼梦</title>
    <link href="http://jiaxiaoxuan.top/2018/01/21/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"/>
    <id>http://jiaxiaoxuan.top/2018/01/21/红楼梦/</id>
    <published>2018-01-21T06:28:53.000Z</published>
    <updated>2018-01-21T14:41:53.424Z</updated>
    
    <content type="html"><![CDATA[<p>初看红楼梦，并不以为意。看了几遍电视剧再去看看原著，脉络渐渐清晰起来。这周末又看一遍电视剧，看到第33集，仔细想想忍不住泪花簌簌。想来这盛极必衰的道理，谁都明白，可细细去看时，谁能不叹息。这一集不详之事一出接着一出，一环扣着一环。曹老先生没有忍心结尾的，却被电视剧拍了出来。到最后真真的落了个白茫茫一片、、、<br><img src="/images/hongloumeng.jpg" alt=""><br>常言说戏如人生，这红楼梦一书好比人生，大观园好比大学。这“三春过后诸芳尽，各自须寻各自门”一句不就是这大学四年吗？大一到大三，大四我们就各奔东西了。那些热闹的场景不过就是一瞬间，大三是我们玩的最痛快的一年，过完这一年就都散了。想来这盛宴总是要散的，所以在该乐呵时一定要尽兴。<br>好友聚会时的照片：<br><img src="/images/photos/IMG_20150502_204054_BURST1.jpg" alt=""><br>室友过生日的照片：<br><img src="/images/photos/IMG20141214191012.jpg" alt=""><br>寝室日常生活照片:<br><img src="/images/photos/IMG_20141009_181711.jpg" alt=""><br>我的照片镇楼:<br><img src="/images/photos/IMG_20160926_080155.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初看红楼梦，并不以为意。看了几遍电视剧再去看看原著，脉络渐渐清晰起来。这周末又看一遍电视剧，看到第33集，仔细想想忍不住泪花簌簌。想来这盛极必衰的道理，谁都明白，可细细去看时，谁能不叹息。这一集不详之事一出接着一出，一环扣着一环。曹老先生没有忍心结尾的，却被电视剧拍了出来。
      
    
    </summary>
    
      <category term="杂记" scheme="http://jiaxiaoxuan.top/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="红楼梦" scheme="http://jiaxiaoxuan.top/tags/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"/>
    
  </entry>
  
  <entry>
    <title>spring-data-redis2</title>
    <link href="http://jiaxiaoxuan.top/2017/12/17/spring-data-redis2/"/>
    <id>http://jiaxiaoxuan.top/2017/12/17/spring-data-redis2/</id>
    <published>2017-12-17T06:53:43.000Z</published>
    <updated>2018-01-02T15:02:41.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>spring集成redis的RedisTemplate,也分别提供的对这些数据类型的操作。<br>主要有5大类：</p><ul><li>redisTemplate.opsForValue();//操作字符串</li><li>redisTemplate.opsForHash();//操作hash</li><li>redisTemplate.opsForList();//操作list</li><li>redisTemplate.opsForSet();//操作set</li><li>redisTemplate.opsForZSet();//操作有序set<h1 id="String类："><a href="#String类：" class="headerlink" title="String类："></a>String类：</h1></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.redisTemplate.opsForValue().set(key,value)); //设置指定键的值</span><br><span class="line">2.redisTemplate.opsForValue().get(key)); //获取指定键的值。</span><br><span class="line">3.redisTemplate.opsForValue().get(key, start, end);//获取存储在键上的字符串的子字符串。</span><br><span class="line">4.redisTemplate.opsForValue().getAndSet(key, value);//设置键的字符串值并返回其旧值。</span><br><span class="line">5.redisTemplate.opsForValue().getBit(key, offset);//返回在键处存储的字符串值中偏移处的位值。</span><br><span class="line">6.redisTemplate.opsForValue().multiGet(keys);//获取所有给定键的值</span><br><span class="line">7.redisTemplate.opsForValue().setBit(key, offset, value);//存储在键上的字符串值中设置或清除偏移处的位</span><br><span class="line">8.redisTemplate.opsForValue().set(K key, V value, long timeout, TimeUnit unit);//使用键和到期时间来设置值</span><br><span class="line">9.redisTemplate.opsForValue().setIfAbsent(key, value);//设置键的值，仅当键不存在时</span><br><span class="line">10.redisTemplate.opsForValue().set(K key, V value, long offset);//在指定偏移处开始的键处覆盖字符串的一部分</span><br><span class="line">11.redisTemplate.opsForValue().size(key));//获取存储在键中的值的长度</span><br><span class="line">12.redisTemplate.opsForValue().multiGet(Collection keys);//为多个键分别设置它们的值</span><br><span class="line">13.redisTemplate.opsForValue().multiSetIfAbsent(Map m);// 为多个键分别设置它们的值，仅当键不存在时</span><br></pre></td></tr></table></figure><h1 id="Hash类"><a href="#Hash类" class="headerlink" title="Hash类:"></a>Hash类:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.redisTemplate.opsForHash().delete(H key, Object... hashKeys);//删除一个或多个哈希字段。</span><br><span class="line">2.redisTemplate.opsForHash().hasKey(key, hashKey)；//判断是否存在散列字段。</span><br><span class="line">3.redisTemplate.opsForHash().get(key, hashKey)；//     获取存储在指定键的哈希字段的值。</span><br><span class="line">4.redisTemplate.opsForHash().entries(key);//返回map集合</span><br><span class="line">5.redisTemplate.opsForHash().increment(H key, HK hashKey, long delta);//获取存储在指定键的哈希中的所有字段和值</span><br><span class="line">6.redisTemplate.opsForHash().keys(key)；//返回map的key集合Set</span><br><span class="line">7.redisTemplate.opsForHash().size(key)； //获取散列中的字段数量</span><br><span class="line">8.redisTemplate.opsForHash().multiGet(H key, Collection hashKeys);//获取所有给定哈希字段的值</span><br><span class="line">9.redisTemplate.opsForHash().putAll(H key, Map m)；//为多个哈希字段分别设置它们的值</span><br><span class="line">10.redisTemplate.opsForHash().put(key, hashKey, value);//设置散列字段的字符串值</span><br><span class="line">11.redisTemplate.opsForHash().putIfAbsent(key, hashKey, value)；//仅当字段不存在时，才设置散列字段的值</span><br><span class="line">12.redisTemplate.opsForHash().values(key);// 获取哈希中的所有值</span><br></pre></td></tr></table></figure><h1 id="list类："><a href="#list类：" class="headerlink" title="list类："></a>list类：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.redisTemplate.opsForList().leftPush(key, value);//从左向右存压栈</span><br><span class="line">2.redisTemplate.opsForList().rightPush(key, value);//从右向左存压栈</span><br><span class="line">3.redisTemplate.opsForList().size(key);//获取大小</span><br><span class="line">4.redisTemplate.opsForList().range(key, start, end);//范围检索,根据下标，返回[start,end]的List</span><br><span class="line">5.redisTemplate.opsForList().remove(key, i, value);//移除key中值为value的i个,返回删除的个数；如果没有这个元素则返回0</span><br><span class="line">6.redisTemplate.opsForList().index(key, index);//检索</span><br><span class="line">7.redisTemplate.opsForList().set(key, index, value);//赋值.给指定位置的元素赋值，和String的set可不一样。</span><br><span class="line">8.redisTemplate.opsForList().trim(key, start, end);//裁剪,void,删除除了[start,end]以外的所有元素  </span><br><span class="line">9.redisTemplate.opsForList().rightPopAndLeftPush(String sourceKey, String destinationKey);//将源key的队列的右边的一个值删除，然后塞入目标key的队列的左边，返回这个值</span><br></pre></td></tr></table></figure><h1 id="set类："><a href="#set类：" class="headerlink" title="set类："></a>set类：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.redisTemplate.opsForSet().add(key, value); ;//如果不存在这个字符串，将字符串存入set集合，返回存入元素的个数；如果存在这个字符串就不操作，返回0；</span><br><span class="line">2.redisTemplate.opsForSet().members(key);//列出key的所有set集合</span><br><span class="line">3.redisTemplate.opsForSet().randomMember(key);//随机取key的一个set元素</span><br><span class="line">4.redisTemplate.opsForSet().distinctRandomMembers(key,n);//随机取N次key的元素，组成一个set集合，不可以重复取出</span><br><span class="line">5.redisTemplate.opsForSet().size(key);//返回set长度</span><br><span class="line">6.redisTemplate.opsForSet().difference(key, otherkey);//比较key与otherKey的set集合，取出与otherKey的set集合不一样的set集合</span><br><span class="line">7.redisTemplate.opsForSet().intersect(key, otherkey);//比较key与otherKey的set集合，取出二者交集，返回set交集合</span><br><span class="line">8.redisTemplate.opsForSet().union(key, otherkey);////比较key与otherKey的set集合，取出二者并集，返回set并集合</span><br><span class="line">9.redisTemplate.opsForSet().unionAndStore(key, otherkey,destkey);////比较key与otherKey的set集合，取出二者并集，并存入destKey集合，返回destKey集合个数</span><br></pre></td></tr></table></figure><h1 id="zset："><a href="#zset：" class="headerlink" title="zset："></a>zset：</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;spring集成redis的RedisTemplate,也分别提供的对这些数据类型的操作。&lt;br&gt;主要有5大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="redis" scheme="http://jiaxiaoxuan.top/categories/redis/"/>
    
    
      <category term="spring" scheme="http://jiaxiaoxuan.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring-data-redis1</title>
    <link href="http://jiaxiaoxuan.top/2017/12/17/spring-data-redis1/"/>
    <id>http://jiaxiaoxuan.top/2017/12/17/spring-data-redis1/</id>
    <published>2017-12-17T06:52:03.000Z</published>
    <updated>2018-01-02T15:02:41.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>常常用到redis做缓存，每次在新项目用的时候，总是copy以前写过的代码，对其中的原理并不是很清楚，趁着最近有空研究一下，做点笔记以备忘。  </p><h1 id="redis的数据库的存储格式"><a href="#redis的数据库的存储格式" class="headerlink" title="redis的数据库的存储格式"></a>redis的数据库的存储格式</h1><p>redis支持的数据格式主要有以下几种：  </p><ul><li>String——字符串</li><li>Hash——字典</li><li>List——列表</li><li>Set——集合</li><li>Sorted Set(zset)——有序集合<br>关于这几种数据的解释请看   <a href="http://www.jb51.net/article/54774.htm" target="_blank" rel="noopener">链接</a>    </li></ul><h1 id="spring与redis的集成"><a href="#spring与redis的集成" class="headerlink" title="spring与redis的集成"></a>spring与redis的集成</h1><p>由于jedisclientAPI不好操作，spring对其进行了封装，在spring-data-redis包中提供了两种操作redis的封装类，一种是RedisTemplate和他的子类<br>StringRedisTemplate，这两个类的只有一个地方是不相同的，就是对数据的序列化方式，RedisTemplate对数据的序列化方式是使用JdkSerializationRedisSerializer这个类。下面这段代码会在获取到redis链接之前执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line"></span><br><span class="line">super.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">boolean defaultUsed = false;</span><br><span class="line"></span><br><span class="line">if (defaultSerializer == null) &#123;</span><br><span class="line"></span><br><span class="line">defaultSerializer = new JdkSerializationRedisSerializer(</span><br><span class="line">classLoader != null ? classLoader : this.getClass().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (enableDefaultSerializer) &#123;</span><br><span class="line"></span><br><span class="line">if (keySerializer == null) &#123;</span><br><span class="line">keySerializer = defaultSerializer;</span><br><span class="line">defaultUsed = true;</span><br><span class="line">&#125;</span><br><span class="line">if (valueSerializer == null) &#123;</span><br><span class="line">valueSerializer = defaultSerializer;</span><br><span class="line">defaultUsed = true;</span><br><span class="line">&#125;</span><br><span class="line">if (hashKeySerializer == null) &#123;</span><br><span class="line">hashKeySerializer = defaultSerializer;</span><br><span class="line">defaultUsed = true;</span><br><span class="line">&#125;</span><br><span class="line">if (hashValueSerializer == null) &#123;</span><br><span class="line">hashValueSerializer = defaultSerializer;</span><br><span class="line">defaultUsed = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (enableDefaultSerializer &amp;&amp; defaultUsed) &#123;</span><br><span class="line">Assert.notNull(defaultSerializer, &quot;default serializer null and not all serializers initialized&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (scriptExecutor == null) &#123;</span><br><span class="line">this.scriptExecutor = new DefaultScriptExecutor&lt;&gt;(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initialized = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringRedisTemplate作为子类，在构造方法里面就指定StringRedisSerializer类来做序列化，代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public StringRedisTemplate() &#123;</span><br><span class="line">RedisSerializer&lt;String&gt; stringSerializer = new StringRedisSerializer();</span><br><span class="line">setKeySerializer(stringSerializer);</span><br><span class="line">setValueSerializer(stringSerializer);</span><br><span class="line">setHashKeySerializer(stringSerializer);</span><br><span class="line">setHashValueSerializer(stringSerializer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者有什么不同之处呢，StringRedisSerializer会将数据数列化成字符串，是在redis客户端中是可读的，JdkSerializationRedisSerializer类会将数据序列化为字节数据是不可读的。</p><p>请看下列代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * redis 单机模式测试</span><br><span class="line">   */</span><br><span class="line">  private static void redisStandaloneTest()&#123;</span><br><span class="line">      //以单机模式创建redis链接工厂</span><br><span class="line">      RedisStandaloneConfiguration config=new RedisStandaloneConfiguration();</span><br><span class="line">      config.setPassword(RedisPassword.of(&quot;123456&quot;));</span><br><span class="line">      RedisConnectionFactory redisConnectionFactory=new JedisConnectionFactory(config);</span><br><span class="line"></span><br><span class="line">      //创建redis的spring封装类RedisTemplate</span><br><span class="line">      RedisTemplate redisTemplate=new RedisTemplate();</span><br><span class="line">      redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">      redisTemplate.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">      //必须执行初始化操作，否则不会设置序列化，就无法存取值</span><br><span class="line">      redisTemplate.afterPropertiesSet();</span><br><span class="line">      //存取值，并打印</span><br><span class="line">      redisTemplate.opsForValue().set(&quot;jia&quot;,&quot;xinxuain&quot;);</span><br><span class="line">      System.out.println(redisTemplate.opsForValue().get(&quot;jia&quot;));</span><br><span class="line"></span><br><span class="line">      //创建redis的spring封装类StringRedisTemplate</span><br><span class="line">      StringRedisTemplate stringRedisTemplate=new StringRedisTemplate(redisConnectionFactory);</span><br><span class="line">      stringRedisTemplate.opsForValue().set(&quot;xin&quot;,&quot;xuan&quot;);</span><br><span class="line">      System.out.println(stringRedisTemplate.opsForValue().get(&quot;xin&quot;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在redis中的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;test&quot;</span><br><span class="line">2) &quot;jia&quot;</span><br><span class="line">3) &quot;foo&quot;</span><br><span class="line">4) &quot;\xac\xed\x00\x05t\x00\x03jia&quot;</span><br><span class="line">127.0.0.1:6379&gt; get jia</span><br><span class="line">&quot;\xac\xed\x00\x05t\x00\bxinxuain&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>程序运行后的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/jia/java/bin/java ...</span><br><span class="line">xinxuain</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>对于RedisTemplate的对象，设置其key值使用StringRedisSerializer序列化，其value使用默认的JdkSerializationRedisSerializer序列化。在存取同一个值的时候，如果是不同系统，一定要约定序列化的方式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>spring在操作redis的时候，给提供的这两个封装类，stringRedisTemplate基本上就可以满足大部分需求了。RedisTemplate提供了更为灵活的配置。<br>在学习的过程中，遇到一个版本兼容的问题，一开始我使用的是jedis2.9版本，spring使用的是4.3版本，这时候sping-data-jedis的版本是2.0.2的。最新版本的dedis和spring-data-redis是支持Java8的，其中Java8里面有个重要的lambda表达式，而spring4.3是不支持Java8的。这样就出现bug了，后来把spring提升到5.0版本才好。<br>顺便再提一句，不知道什么时候，sprin-data-redis在创建RedisTemplate的时候，做了修改，反正就是对集群哨兵单机这三种情况，提供了配置文件的封装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;常常用到redis做缓存，每次在新项目用的时候，总是copy以前写过的代码，对其中的原理并不是很清楚，趁着最近有空研究一下，做点笔记以备忘。
      
    
    </summary>
    
      <category term="redis" scheme="http://jiaxiaoxuan.top/categories/redis/"/>
    
    
      <category term="spring" scheme="http://jiaxiaoxuan.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>使用py抓取b站影评</title>
    <link href="http://jiaxiaoxuan.top/2017/11/24/%E4%BD%BF%E7%94%A8py%E6%8A%93%E5%8F%96b%E7%AB%99%E5%BD%B1%E8%AF%84/"/>
    <id>http://jiaxiaoxuan.top/2017/11/24/使用py抓取b站影评/</id>
    <published>2017-11-24T13:36:18.000Z</published>
    <updated>2018-01-02T15:02:41.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>上周末看了一部甲方乙方的电影，看完以后发现下面的影评挺多的，就想分析一下，这个电影大家评论最多的关键词是什么。既然这么想了那就下手呗，f12查看b站评论的请求接口，一不小心被我找到了，，，，，，<br>那就请求这个接口呗，借用结巴分词和WordCloud词语，就是我想要的结果了。<br><a id="more"></a></p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p>当然话不多说，请看效果图<br><img src="/images/blibli.png" alt=""></p><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">简单Python爬虫，抓取b站某个电影的评论数据，生成词云</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import urllib.parse</span><br><span class="line">import urllib.request</span><br><span class="line">import urllib</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">import json</span><br><span class="line">import jieba</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># get请求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def login_get(url):</span><br><span class="line">    response = urllib.request.urlopen(url)</span><br><span class="line">    text = response.read()</span><br><span class="line">    return text.decode(&apos;UTF-8&apos;)</span><br><span class="line"># post 请求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def login_post(url, header, data):</span><br><span class="line">    data = urllib.parse.urlencode(data)</span><br><span class="line">    req = urllib.request.Request(url, data=data, headers=header)</span><br><span class="line">    response = urllib.request.urlopen(req, timeout=5)</span><br><span class="line">    return response.read().decode(&apos;UTF-8&apos;)</span><br><span class="line">#   写入文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def output_file(content, outPutFile):</span><br><span class="line">    outfile = open(file=outPutFile, mode=&quot;a&quot;, encoding=&quot;UTF-8&quot;)  # 以写的方式打开该文件</span><br><span class="line">    outfile.write(content)</span><br><span class="line">    outfile.flush()</span><br><span class="line"></span><br><span class="line"># 结巴分词</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sliptsentence(inputFile, outPutFile):</span><br><span class="line">    try:</span><br><span class="line">        # 以读的方式打开该文件</span><br><span class="line">        inFile=open(file=inputFile, mode=&quot;r&quot;,encoding=&quot;UTF-8&quot;)</span><br><span class="line">        # 以写的方式打开该文件</span><br><span class="line">        outFile=open(file=outPutFile,mode=&quot;w&quot;,encoding=&quot;UTF-8&quot;)</span><br><span class="line">        # 循环遍历打开的文件，取出其中每行，并对每行进行分词</span><br><span class="line">        for eachLine in inFile:</span><br><span class="line">            # 此句取某一行的数据，并且去除两端的空格，并以utf-8的形式编码</span><br><span class="line">            line=eachLine.strip().encode(&quot;UTF-8&quot;,&quot;ingore&quot;)</span><br><span class="line">            wordList=jieba.cut(line);</span><br><span class="line">            # 将当前行得到的分词数据，写入到输出文件中去</span><br><span class="line">            outstr=&apos;&apos;</span><br><span class="line">            for word in wordList:</span><br><span class="line">                outstr+=word</span><br><span class="line">                outstr+=&quot;/&quot;</span><br><span class="line">            outFile.write(outstr.strip()+&quot;\n&quot;)</span><br><span class="line">    except Exception as ex:</span><br><span class="line">        print(&quot;文件处理出错&quot;,ex)</span><br><span class="line">    finally:</span><br><span class="line">       inFile.close()</span><br><span class="line">       outFile.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(1,38):</span><br><span class="line">        url=&apos;http://api.bilibili.com/x/v2/reply?jsonp=jsonp&amp;pn=&apos;+str(i)+&apos;&amp;type=1&amp;oid=2651396&amp;sort=0&amp;_=1510978290823&apos;</span><br><span class="line">        result = login_get(url)</span><br><span class="line">        jsons = json.loads(result, encoding=&apos;UTF-8&apos;)</span><br><span class="line">        replies = jsons[&apos;data&apos;][&apos;replies&apos;]</span><br><span class="line">        message = &apos;&apos;</span><br><span class="line">        for user in replies:</span><br><span class="line">            content=user[&apos;content&apos;]</span><br><span class="line">            message += content[&apos;message&apos;]+&apos;\n&apos;</span><br><span class="line">            print(content[&apos;message&apos;])</span><br><span class="line">        output_file(message,&apos;/home/jia/content.log&apos;)</span><br><span class="line">    sliptsentence(&apos;/home/jia/content.log&apos;, &apos;/home/jia/jieba.json&apos;)</span><br><span class="line">    f = open(u&apos;/home/jia/jieba.json&apos;, &apos;r&apos;, encoding=&apos;UTF-8&apos;).read()</span><br><span class="line">    wordcloud = WordCloud(background_color=&quot;white&quot;, width=1000, height=860,</span><br><span class="line">                          margin=2, font_path=&apos;/home/jia/bole.ttf&apos;).generate(f)</span><br><span class="line">    plt.imshow(wordcloud)</span><br><span class="line">    plt.axis(&quot;off&quot;)</span><br><span class="line">    plt.show()</span><br><span class="line">    wordcloud.to_file(&apos;test.png&apos;)</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>请求评论的接口，请注意计算分页的大小。</li><li>使用WocrdCloud制作词语时，Linux系统一定要指定中文字体，不然人家不认识中文。Windows系统好像本来就是中文字体。。。</li><li>别的就没什么要注意的了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;上周末看了一部甲方乙方的电影，看完以后发现下面的影评挺多的，就想分析一下，这个电影大家评论最多的关键词是什么。既然这么想了那就下手呗，f12查看b站评论的请求接口，一不小心被我找到了，，，，，，&lt;br&gt;那就请求这个接口呗，借用结巴分词和WordCloud词语，就是我想要的结果了。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://jiaxiaoxuan.top/categories/python/"/>
    
    
      <category term="python" scheme="http://jiaxiaoxuan.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>linux日志查询技巧</title>
    <link href="http://jiaxiaoxuan.top/2017/11/24/linux%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E6%8A%80%E5%B7%A7/"/>
    <id>http://jiaxiaoxuan.top/2017/11/24/linux日志查询技巧/</id>
    <published>2017-11-24T13:26:28.000Z</published>
    <updated>2018-01-02T15:02:41.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统日志查询常用命令"><a href="#Linux系统日志查询常用命令" class="headerlink" title="Linux系统日志查询常用命令"></a>Linux系统日志查询常用命令</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>当线上程序出现bug的时候，往往都是由于某种小的原因导致的，这个时候bug不能适时地显示，只能通过日志文件来定位bug出现的位置。<br>上周程序出现bug个的时候，领导盯着我查，感觉当时好气，自己怎么不提前学习一下这些命令呢，现在总结以下，以备来日不时之需。<br>日志查询命令主要有以下几种:</p><ul><li>cat</li><li>tail</li><li>head</li><li>sed</li><li>more</li><li>less</li><li>grep<br>以后遇见新学习的命令，再添加。以下是详细总结。</li></ul><a id="more"></a><h1 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">-n 或 --number 由 1 开始对所有输出的行数编号</span><br><span class="line">-b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号</span><br><span class="line">-s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行</span><br><span class="line">-v 或 --show-nonprinting</span><br></pre></td></tr></table></figure><p>三总用法</p><ol><li>创建新文件<br>cat test，此命令只能创建新文件，不能够编辑已有文件。</li><li>连接文件并打印到标准输出设备上<br>当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。<br>cat test.log | more</li><li>合并文件<br>把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><p>把test.txt文件扔进垃圾箱，赋空值test.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; /etc/test.txt</span><br></pre></td></tr></table></figure><h1 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h1><p>tail命令用于显示文件中末尾的内容（默认显示最后10行内容）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tail语法格式：</span><br><span class="line">    tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]</span><br><span class="line">或者</span><br><span class="line">    tail [ -r ] [ -n Number ] [ File ]</span><br></pre></td></tr></table></figure></p><p>使用说明：</p><ul><li>tail 命令从指定点开始将 File 参数指定的文件写到标准输出。如果没有指定文件，则会使用标准输入。</li><li>Number 变量指定将多少单元写入标准输出。 Number 变量的值可以是正的或负的整数。</li><li>如果值的前面有 +（加号），从文件开头指定的单元数开始将文件写到标准输出。</li><li>如果值的前面有 -（减号），则从文件末尾指定的单元数开始将文件写到标准输出。</li><li>如果值前面没有 +（加号）或 -（减号），那么从文件末尾指定的单元号开始读取文件。<br>主要参数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-f  用于循环读取文件的内容，监视文件的增长,常用此命令监控日志。</span><br><span class="line"></span><br><span class="line">tail -f test.log</span><br><span class="line"></span><br><span class="line">-F 与-f类似，区别在于当将监视的文件删除重建后-F仍能监视该文件内容-f则不行，-F有重试的功能，会不断重试</span><br><span class="line"></span><br><span class="line">-c N 显示文件末尾N字节的内容</span><br><span class="line"></span><br><span class="line">tail -c 10 seo-test.log ,这样会显示文件最后十个英文字母</span><br><span class="line"></span><br><span class="line">-n  显示文件末尾n行内容</span><br><span class="line"></span><br><span class="line">tail -n 100 test.log,显示最后100行内容。</span><br><span class="line"></span><br><span class="line">-q  显示多文件的末尾内容时，不显示文件名</span><br><span class="line">-v  显示多文件的末尾内容时，显示文件名（此为tail的默认选项）</span><br><span class="line">-s N 与-f合用，表示休眠N秒后在读取文件内容（默认为1s）</span><br><span class="line"></span><br><span class="line">--pid=&lt;进程号PID&gt; 与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令</span><br></pre></td></tr></table></figure><h1 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h1><p>head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看文件的结尾。</p><p>使用说明：<br>用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。<br>常用参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-q   隐藏文件名</span><br><span class="line"></span><br><span class="line">-v   显示文件名</span><br><span class="line"></span><br><span class="line">以上两个命令多用于打开多文件的情况</span><br><span class="line"></span><br><span class="line">-c   &lt;字节&gt; 显示字节数</span><br><span class="line"></span><br><span class="line">-n   &lt;行数&gt; 显示的行数</span><br><span class="line"></span><br><span class="line">-z   像屏幕滚动输出所有内容</span><br></pre></td></tr></table></figure><h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><p>暂缺</p><h1 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h1><p>more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。</p><p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）可以用下列不同的方法对提示做出回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">按Space键：显示文本的下一屏内容。</span><br><span class="line">按Enier键：只显示文本的下一行内容。</span><br><span class="line">按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。</span><br><span class="line">按H键：显示帮助屏，该屏上有相关的帮助信息。</span><br><span class="line">按B键：显示上一屏内容。 按Q键：退出rnore命令。</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&lt;数字&gt;：指定每屏显示的行数；</span><br><span class="line">-d：显示“[press space to continue,&apos;q&apos; to quit.]”和“[Press &apos;h&apos; for instructions]”；</span><br><span class="line">-c：不进行滚屏操作。每次刷新这个屏幕；</span><br><span class="line">-s：将多个空行压缩成一行显示；</span><br><span class="line">-u：禁止下划线；</span><br><span class="line">+&lt;数字&gt;：从指定数字的行开始显示。</span><br></pre></td></tr></table></figure><p><strong><em>实例</em></strong><br>显示文件file的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -dc file</span><br></pre></td></tr></table></figure><p>显示文件file的内容，每10行显示一次，而且在显示之前先清屏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -c -10 file</span><br></pre></td></tr></table></figure><h1 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h1><p><a href="http://blog.csdn.net/mxj588love/article/details/54313769" target="_blank" rel="noopener">http://blog.csdn.net/mxj588love/article/details/54313769</a><br>放一篇博文链接,我没怎么使用过。</p><h1 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h1><p>这个命令很强大啊！我也不敢随便总结，下面是一位大神总结的，我感觉比较全了。<br><a href="https://www.cnblogs.com/end/archive/2012/02/21/2360965.html" target="_blank" rel="noopener">https://www.cnblogs.com/end/archive/2012/02/21/2360965.html</a></p><h1 id="常用查询命令组合"><a href="#常用查询命令组合" class="headerlink" title="常用查询命令组合:"></a>常用查询命令组合:</h1><p>1.查询日志中含有某个关键字的信息</p><p>cat app.log | grep ‘error’</p><p>2.查询日志尾部最后10行的日志</p><p>tail  -n 10  app.log</p><p>3.查询10行之后的所有日志</p><p>tail -n +10 app.log</p><p>4.查询日志文件中的头10行日志</p><p>head -n 10  app.log</p><p>5.查询日志文件除了最后10行的其他所有日志</p><p>head -n -10  app.log</p><p>6.查询日志中含有某个关键字的信息,显示出行号(在1的基础上修改)</p><p>cat -n  app.log | grep ‘error’</p><p>7.显示102行,前10行和后10行的日志</p><p>cat -n app.log | tail -n+92 | head -n 20</p><p>8.根据日期时间段查询(前提日志总必须打印日期,先通过grep确定是否有该时间点)</p><p><strong><em>sed -n ‘/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p’  app.log</em></strong></p><p>9.使用more和less命令(分页查看,使用空格翻页)</p><p> cat -n app.log | grep “error” |more</p><p>10.把日志保存到文件</p><p>cat -n app.log | grep “error”  &gt; temp.txt</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux系统日志查询常用命令&quot;&gt;&lt;a href=&quot;#Linux系统日志查询常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux系统日志查询常用命令&quot;&gt;&lt;/a&gt;Linux系统日志查询常用命令&lt;/h1&gt;&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;当线上程序出现bug的时候，往往都是由于某种小的原因导致的，这个时候bug不能适时地显示，只能通过日志文件来定位bug出现的位置。&lt;br&gt;上周程序出现bug个的时候，领导盯着我查，感觉当时好气，自己怎么不提前学习一下这些命令呢，现在总结以下，以备来日不时之需。&lt;br&gt;日志查询命令主要有以下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cat&lt;/li&gt;
&lt;li&gt;tail&lt;/li&gt;
&lt;li&gt;head&lt;/li&gt;
&lt;li&gt;sed&lt;/li&gt;
&lt;li&gt;more&lt;/li&gt;
&lt;li&gt;less&lt;/li&gt;
&lt;li&gt;grep&lt;br&gt;以后遇见新学习的命令，再添加。以下是详细总结。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="http://jiaxiaoxuan.top/categories/linux/"/>
    
    
      <category term="linux" scheme="http://jiaxiaoxuan.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>elk+logback的简单日志收集-单机版</title>
    <link href="http://jiaxiaoxuan.top/2017/11/08/elk-logback%E7%9A%84%E7%AE%80%E5%8D%95%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86-%E5%8D%95%E6%9C%BA%E7%89%88/"/>
    <id>http://jiaxiaoxuan.top/2017/11/08/elk-logback的简单日志收集-单机版/</id>
    <published>2017-11-08T08:59:44.000Z</published>
    <updated>2018-01-02T15:02:41.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>微服务架构中，多个服务都是分离部署的，在实际的操作中，常常需要实时监测运行日志，或者查找日志记录，以确定程序bug的所在位置。服务的分离部署就增加了查找难度，必须登录多台主机打开多个终端查看日志。elk日志搜集系统能够很好的解决这个问题，网上教程已是相当的多，这里仅仅是贴合自己的实际开发来搭建的，只是为了更好的同时监测多台服务器的日志。本文只是单机搭建实验，准备最近在公司测试环境搭建一份。</p><a id="more"></a><h1 id="组件介绍与安装"><a href="#组件介绍与安装" class="headerlink" title="组件介绍与安装"></a>组件介绍与安装</h1><p>日志流行图：</p><p><img src="/images/elk/elk-1.png" alt=""></p><p>从左边看起，每一台webserver上都会部署一个logstash-agent,它的作用是用类似tailf的方式监听日志文件，然后把新添加的日志发送到redis队列里面，logstash-indexer负责从redis相应的队列里面取出日志，对日志进进行加工后输出到elasticsearch中，elasticsearch会根据要求对日志进行索引归集，最后用户可以通过kibana来查看和分析日志。</p><p>在ELK官网下载相应的压缩包</p><p><a href="https://www.elastic.co/downloads" target="_blank" rel="noopener">https://www.elastic.co/downloads</a></p><h2 id="logstash和logbach的结合"><a href="#logstash和logbach的结合" class="headerlink" title="logstash和logbach的结合"></a>logstash和logbach的结合</h2><p>公司里面使用的是logback日志，通过在maven中添加logback-redis-appender依赖来结合logstash,进行日志收集。步骤如下：</p><p>1、加入apender jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.cwbase&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-redis-appender&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置logback.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property name=&quot;type.name&quot; value=&quot;&quot; /&gt;</span><br><span class="line">  &lt;appender name=&quot;TEST&quot; class=&quot;com.cwbase.logback.RedisAppender&quot;&gt;</span><br><span class="line">    &lt;source&gt;test-application&lt;/source&gt;</span><br><span class="line">    &lt;!--type 可定为项目类型--&gt;</span><br><span class="line">    &lt;type&gt;$&#123;type.name&#125;&lt;/type&gt;</span><br><span class="line">    &lt;!--redis ip--&gt;</span><br><span class="line">    &lt;host&gt;192.168.1.218&lt;/host&gt;</span><br><span class="line">    &lt;!--redis存放的key--&gt;</span><br><span class="line">    &lt;key&gt;logstash:redis&lt;/key&gt;</span><br><span class="line">    &lt;tags&gt;test-2&lt;/tags&gt;</span><br><span class="line">    &lt;mdc&gt;true&lt;/mdc&gt;</span><br><span class="line">    &lt;location&gt;true&lt;/location&gt;</span><br><span class="line">    &lt;callerStackIndex&gt;0&lt;/callerStackIndex&gt;</span><br><span class="line">    &lt;!--additionalField添加附加字段 用于head插件显示--&gt;</span><br><span class="line">    &lt;additionalField&gt;</span><br><span class="line">      &lt;key&gt;MyKey&lt;/key&gt;</span><br><span class="line">      &lt;value&gt;MyValue&lt;/value&gt;</span><br><span class="line">    &lt;/additionalField&gt;</span><br><span class="line">    &lt;additionalField&gt;</span><br><span class="line">      &lt;key&gt;MySecondKey&lt;/key&gt;</span><br><span class="line">      &lt;value&gt;MyOtherValue&lt;/value&gt;</span><br><span class="line">    &lt;/additionalField&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line">  &lt;!--日志输出--&gt;</span><br><span class="line">  &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">      &lt;fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">      &lt;!--日志回滚周期30天--&gt;</span><br><span class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;!-- &lt;encoder&gt;</span><br><span class="line">       &lt;pattern&gt;%logger&#123;15&#125; - %message%n%xException&#123;5&#125;&lt;/pattern&gt;</span><br><span class="line">     &lt;/encoder&gt;--&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-4relative [%thread] %-5level %logger&#123;35&#125; %caller&#123;3&#125; - %msg%n%xException&#123;5&#125;&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;logger name=&quot;application&quot; level=&quot;DEBUG&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;root level=&quot;DEBUG&quot;&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;TEST&quot; /&gt;</span><br><span class="line">  &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><p>安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span><br><span class="line">$ tar xzf redis-4.0.2.tar.gz</span><br><span class="line">$ cd redis-4.0.2</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ src/redis-server</span><br></pre></td></tr></table></figure><p>链接测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ src/redis-cli</span><br><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure><p>后台启动脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!bin/bash</span><br><span class="line">nohup ./src/redis-server &gt; /data/logs/redis.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><p>配置logstash的时候，log4j或者其他方式的日志收集，可能需要在webserver上配置logstash-agent。logback的话按照上面的方式在maven依赖添加相关jar包就可以了。然后在日志server上配置logstash-indexer.<br><strong>在日志server上安装logstash-indexer</strong></p><p>1.解压 tar -zxvf logstash<em>**</em></p><p>2.检验安装是否成功 bin/logstash -e “input{stdin{}}output{stdout{}}”,然后在终端输入hello，看看有没有内容返回<br>3.编写logstash-indexer.conf文件，保存至conf目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#输入日志</span><br><span class="line">input &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">    host =&gt; &quot;localhost&quot;#redis地址</span><br><span class="line">    data_type =&gt; &quot;list&quot;</span><br><span class="line">    key =&gt; &quot;logstash:redis:customer&quot;</span><br><span class="line">    type =&gt; &quot;redis-input&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#过滤日志</span><br><span class="line">#filter &#123;</span><br><span class="line">#    grok &#123;</span><br><span class="line">#    match =&gt; &#123;</span><br><span class="line">#    &quot;message&quot; =&gt; &quot;%&#123;TIMESTAMP_ISO8601:date&#125; \[(?.+?)\] (?\w+)\s*(?     #  &#125;</span><br><span class="line">#&#125;</span><br><span class="line">#定义时间格式</span><br><span class="line">date &#123;</span><br><span class="line">    match =&gt; [&quot;timestamp&quot;, &quot;dd/MMM/YYYY:HH:mm:ss Z&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#输出日志</span><br><span class="line">output &#123;</span><br><span class="line">    if[type] == &quot;customer_service&quot; &#123;</span><br><span class="line">                    elasticsearch &#123;</span><br><span class="line">                        #embedded =&gt; false</span><br><span class="line">                        #protocol =&gt; &quot;http&quot;</span><br><span class="line">                        hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">                        index =&gt; &quot;customer-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;else if[type] == &quot;其他类型&quot; &#123;</span><br><span class="line"></span><br><span class="line">                    elasticsearch &#123;</span><br><span class="line">                    #embedded =&gt; false</span><br><span class="line">                    #protocol =&gt; &quot;http&quot;</span><br><span class="line">                    hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">                    index =&gt; &quot;其他类型索引名字-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else &#123;</span><br><span class="line">                    //做其他处理</span><br><span class="line">    &#125;</span><br><span class="line">    stdout&#123; #输出到标准输出，可以去掉</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置，需要自行修改，方可使用。</p><p>启动logstash-indexer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./bin/logstash -f conf/logstash-indexer.conf 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>可以仿照redis的方式，写个启动脚本。</p><h2 id="elelasticsearch"><a href="#elelasticsearch" class="headerlink" title="elelasticsearch"></a>elelasticsearch</h2><p>1.解压tar -zxvf elasticsearch-2.3.1.tar.gz</p><p>2.修改安装目录下的配置文件config/elasticsearch.yml</p><p>把network.host字段给反注释掉，把地址改为0.0.0.0（官方并没明确说要去改这配置，默认配置应该就可以了，不过实测的时候发现如果不做这修改，elasticsearch访问不了）</p><p><img src="/images/elk/elk-3.png" alt=""></p><p>3.后台启动elasticsearch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./bin/elasticsearch &gt;  &amp;</span><br></pre></td></tr></table></figure><h2 id="安装elasticsearch-head插件"><a href="#安装elasticsearch-head插件" class="headerlink" title="安装elasticsearch-head插件"></a>安装elasticsearch-head插件</h2><p>在使用该插件时，请实现安装好nodejs。<br>1.下载安装包<br>下载地址:<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a><br>2.解压elasticsearch-head 包<br>3.全局安装grunt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g grunt -cli --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>4.在elasticsearch-head-master文件下的Gruntfile.js文件中增加server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">connect: &#123;</span><br><span class="line">    server: &#123;</span><br><span class="line">        options: &#123;</span><br><span class="line">            hostname: &apos;0.0.0.0&apos;,</span><br><span class="line">            port: 9100,</span><br><span class="line">            base: &apos;.&apos;,</span><br><span class="line">            keepalive: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.elasticsearch.yml 添加如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 是否支持跨域</span><br><span class="line">http.cors.enabled: true</span><br><span class="line"># *表示支持所有域名</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>安装完成以后，要注意重启elasticsearch,以让修改后的配置文件生效。</p><p>6.运行grunt服务<br>进入elasticsearch-head-master文件夹运行grunt server命令<br><img src="/images/elk/elk-4.png" alt=""><br><img src="/images/elk/elk-2.png" alt=""></p><h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.解压tar -zxvf kibana<strong>*</strong></p><p>2.后台启动kibana nohup ./bin/kibana &amp;</p><p>这里没有特别去配置kibana要访问的elasticsearch地址，默认它会找本地的，如果需要，可以到conf/kibana.yml修改</p><h3 id="访问kibana主页"><a href="#访问kibana主页" class="headerlink" title="访问kibana主页"></a>访问kibana主页</h3><p>1.打开kibana主页<a href="http://your-kibana-ip:5601/" target="_blank" rel="noopener">http://your-kibana-ip:5601/</a></p><p>2.按照页面提示输入，并点击create<br><img src="/images/elk/elk-5.png" alt=""></p><h2 id="编写日志服务器启动脚本"><a href="#编写日志服务器启动脚本" class="headerlink" title="编写日志服务器启动脚本"></a>编写日志服务器启动脚本</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;微服务架构中，多个服务都是分离部署的，在实际的操作中，常常需要实时监测运行日志，或者查找日志记录，以确定程序bug的所在位置。服务的分离部署就增加了查找难度，必须登录多台主机打开多个终端查看日志。elk日志搜集系统能够很好的解决这个问题，网上教程已是相当的多，这里仅仅是贴合自己的实际开发来搭建的，只是为了更好的同时监测多台服务器的日志。本文只是单机搭建实验，准备最近在公司测试环境搭建一份。&lt;/p&gt;
    
    </summary>
    
      <category term="elk" scheme="http://jiaxiaoxuan.top/categories/elk/"/>
    
    
      <category term="elk" scheme="http://jiaxiaoxuan.top/tags/elk/"/>
    
  </entry>
  
  <entry>
    <title>POI之SXSSF导出图片</title>
    <link href="http://jiaxiaoxuan.top/2017/10/22/POI%E4%B9%8BSXSSF%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87/"/>
    <id>http://jiaxiaoxuan.top/2017/10/22/POI之SXSSF导出图片/</id>
    <published>2017-10-22T14:22:24.000Z</published>
    <updated>2018-01-02T15:02:41.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在Java中经常要导出报表，基本上用的都是poi提供的解决方法。在实际操作中excel有两种格式的，一种是2003-xls,一种是2007-xlsx,poi在设计中提供了HSSF和XSSF分别对应，从poi3点几以后的版本有提供了SXSSF的方式。这种方式避免了直接创建workbook对象，而是以接口的形式。具体是的实例是根据读到的文件属性来创建。高明了许多。<br><a id="more"></a></p><h2 id="poi图片导出"><a href="#poi图片导出" class="headerlink" title="poi图片导出"></a>poi图片导出</h2><p>最近在项目中遇到使用SXSSF接口的形式导出图片，代码简记如下！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建字节输出流对象</span><br><span class="line">byteArrayOut = new ByteArrayOutputStream();</span><br><span class="line">bufferImg = ImageIO.read(new File(&quot;/data/www/&quot;+o.toString().substring(o.toString().lastIndexOf(&quot;//&quot;)+1)));</span><br><span class="line">ImageIO.write(bufferImg, &quot;jpg&quot;, byteArrayOut);</span><br><span class="line">int pictureIdx = wb.addPicture(byteArrayOut.toByteArray(), Workbook.PICTURE_TYPE_PNG);</span><br><span class="line">CreationHelper helper = wb.getCreationHelper();</span><br><span class="line">//获取绘制管理器</span><br><span class="line">Drawing drawing = sheet1.createDrawingPatriarch();</span><br><span class="line">ClientAnchor anchor = helper.createClientAnchor();</span><br><span class="line">// 图片插入坐标</span><br><span class="line">anchor.setCol1(h);</span><br><span class="line">anchor.setRow1(m);</span><br><span class="line">// 插入图片</span><br><span class="line">Picture pict = drawing.createPicture(anchor, pictureIdx);</span><br><span class="line">//一定要重新绘制图片大小</span><br><span class="line">pict.resize(1,1);</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实现中有些代码是直接创建HSSF或者XSSF类型的对象来输出图片。这样做代码就不具有健壮性，不同够同时适应2003和2007两种格式的导出需求。图片导出以后，其实是浮现在excel表格之上的，excel中表格中，并不能存放图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在Java中经常要导出报表，基本上用的都是poi提供的解决方法。在实际操作中excel有两种格式的，一种是2003-xls,一种是2007-xlsx,poi在设计中提供了HSSF和XSSF分别对应，从poi3点几以后的版本有提供了SXSSF的方式。这种方式避免了直接创建workbook对象，而是以接口的形式。具体是的实例是根据读到的文件属性来创建。高明了许多。&lt;br&gt;
    
    </summary>
    
      <category term="POI" scheme="http://jiaxiaoxuan.top/categories/POI/"/>
    
    
      <category term="-poi -SXSSF" scheme="http://jiaxiaoxuan.top/tags/poi-SXSSF/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu开发软件安装</title>
    <link href="http://jiaxiaoxuan.top/2017/10/14/ubuntu%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://jiaxiaoxuan.top/2017/10/14/ubuntu开发软件安装/</id>
    <published>2017-10-13T21:33:48.000Z</published>
    <updated>2018-01-19T15:49:24.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一个屌丝程序员，时常需要的软件也就那几个。当然，做为一个Java小白，我需要的软件大概就是以下几个，jdk、tomcat、git、vim、jb全家桶、chrome、atom、lantern等一些个人生活常用软件。下面就一一介绍以下这些软件如何安装。  </p><h2 id="软件安装介绍"><a href="#软件安装介绍" class="headerlink" title="软件安装介绍"></a>软件安装介绍</h2><p>在安装软件之前，首先要明白两个命令，sudo apt-get install 和 sudo dpck。这两个命令一个是在线安装，一个是下载deb的安装包即离线安装。不明白的可以参考别的博文。这里不在介绍!（所有安装包默认都已下载完毕,所有命令都是在非root用户下操作）<br><a id="more"></a></p><h3 id="vim和git的安装"><a href="#vim和git的安装" class="headerlink" title="vim和git的安装"></a>vim和git的安装</h3><p>这两个很简单，直接在终端中分别执行以下两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></p><h3 id="java开发环境的搭建"><a href="#java开发环境的搭建" class="headerlink" title="java开发环境的搭建"></a>java开发环境的搭建</h3><p>jdk的安装包直接可以在甲骨文公司的官方网站下载，ubuntu的安装包请下载tar.gz结尾的文件。下载成以后，自己选择安装目录，然后将压缩包拷贝过去，在终端中CD到安装目录，执行以下命令解压:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf XXX.tar.gz</span><br></pre></td></tr></table></figure></p><p>解压成以后使用mv命令重新命名为java，然后在终端中执行<strong><em>vim ~/.bashrc</em></strong>命令配置Java环境变量,该文件编辑的是当前用户的环境变量，不是全局的，只在当前用户生效。内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#java</span><br><span class="line">export JAVA_HOME=/home/jia/java</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure></p><p>编辑保存以后，执行<strong><em>source ~/.bashrc</em></strong> 命令，这条命令会使刚编译的配置文件生效，在终端中执行java\javac命令，查看环境变量是否生效。  </p><h3 id="maven的安装"><a href="#maven的安装" class="headerlink" title="maven的安装"></a>maven的安装</h3><p>在Apache的官方网站下载maven后，使用tar命令解压。建议解压后的文件和Java文件放在一起。然后配置maven环境变量，和Java环境变量一样。bashrc文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#maven</span><br><span class="line">MAVEN_HOME=/home/jia/maven/</span><br><span class="line">export MAVEN_HOME</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure></p><h3 id="JB全家桶安装"><a href="#JB全家桶安装" class="headerlink" title="JB全家桶安装"></a>JB全家桶安装</h3><p>JB公司的IDE很好用，我在学校学习的时候，也是使用的eclipse，后来就慢慢的换成idea了，后来接触了pycharm和webstrom,感觉这些都是神器啊。我在JB公司下载的都是tar.gz的压缩文件。安装十分简单。tar -zxvf ×××.tar.gz命令解压，然后在解压后的文件中找到sh启动脚本启动。一般脚本都是在bin目录下，仔细找找就能发现了，启动完成以后，IDE会自动创建桌面图标，不过它会智能的提问你一下，这时千万不要拒绝啊！    </p><h3 id="chrome、atom、lantern、搜狗输入法的安装"><a href="#chrome、atom、lantern、搜狗输入法的安装" class="headerlink" title="chrome、atom、lantern、搜狗输入法的安装"></a>chrome、atom、lantern、搜狗输入法的安装</h3><p>chrome下载传送门  <a href="https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" target="_blank" rel="noopener">chrome下载链接</a><br>lantern下载请移步github搜索关键词lantern<br>atom下载传送门  <a href="https://atom-installer.github.com/v1.21.1/atom-amd64.deb?s=1507768431&amp;ext=.deb" target="_blank" rel="noopener">atom</a><br>搜狗输入法下载传送门  <a href="http://cdn2.ime.sogou.com/dl/index/1491565850/sogoupinyin_2.1.0.0086_amd64.deb?st=H5kpm_eorYrsD3PGM4mueQ&amp;e=1507907727&amp;fn=sogoupinyin_2.1.0.0086_amd64.deb" target="_blank" rel="noopener">搜狗</a><br>这几个下载的都是deb安装包，必须使用dpck 命令安装，命令介绍如下：<br> dpkg dpkg命令软件包管理 dpkg命令是Linux系统用来安装、创建和管理软件包的实用工具。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">语法 dpkg(选项)(参数)</span><br><span class="line">选项</span><br><span class="line">-i：安装软件包；</span><br><span class="line">-r：删除软件包；</span><br><span class="line">-P：删除软件包的同时删除其配置文件；</span><br><span class="line">-L：显示于软件包关联的文件；</span><br><span class="line">-l：显示已安装软件包列表；</span><br><span class="line">--unpack：解开软件包；</span><br><span class="line">-c：显示软件包内文件列表；</span><br><span class="line">--confiugre：配置软件包。</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">Deb软件包：指定要操作的.deb软件包。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">dpkg -i package.deb #安装包</span><br><span class="line">dpkg -r package #删除包</span><br><span class="line">dpkg -P package #删除包（包括配置文件）</span><br><span class="line">dpkg -L package #列出与该包关联的文件</span><br><span class="line">dpkg -l package #显示该包的版本</span><br><span class="line">dpkg --unpack package.deb #解开deb包的内容</span><br><span class="line">dpkg -S keyword #搜索所属的包内容</span><br><span class="line">dpkg -l #列出当前已安装的包</span><br><span class="line">dpkg -c package.deb #列出deb包的内容 dpkg --configure package #配置包</span><br><span class="line">来自: http://man.linuxde.net/dpkg</span><br></pre></td></tr></table></figure></p><p>当然，以下三种也有在线安装的方式，喜欢的话可以自己尝试以下。<br><a href="http://www.linuxidc.com/Linux/2016-05/131096.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2016-05/131096.htm</a><br>上面的这个链接比较详细的介绍了chrome的命令行安装方式，当然这个是我尝试过的。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在Linux系统安装软件并不是很困难，命令就是那几个，多用几次就习惯了。这样基本的开发环境和学习环境就搭建起来了。喜欢听音乐的同学，可以安装一个网易云音乐，不过它ubuntu系统磨合的不太好，就每次切换音乐的时候会卡顿一次。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;一个屌丝程序员，时常需要的软件也就那几个。当然，做为一个Java小白，我需要的软件大概就是以下几个，jdk、tomcat、git、vim、jb全家桶、chrome、atom、lantern等一些个人生活常用软件。下面就一一介绍以下这些软件如何安装。  &lt;/p&gt;
&lt;h2 id=&quot;软件安装介绍&quot;&gt;&lt;a href=&quot;#软件安装介绍&quot; class=&quot;headerlink&quot; title=&quot;软件安装介绍&quot;&gt;&lt;/a&gt;软件安装介绍&lt;/h2&gt;&lt;p&gt;在安装软件之前，首先要明白两个命令，sudo apt-get install 和 sudo dpck。这两个命令一个是在线安装，一个是下载deb的安装包即离线安装。不明白的可以参考别的博文。这里不在介绍!（所有安装包默认都已下载完毕,所有命令都是在非root用户下操作）&lt;br&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://jiaxiaoxuan.top/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://jiaxiaoxuan.top/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu桌面美化</title>
    <link href="http://jiaxiaoxuan.top/2017/10/10/ubuntu%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    <id>http://jiaxiaoxuan.top/2017/10/10/ubuntu桌面美化/</id>
    <published>2017-10-10T14:03:46.000Z</published>
    <updated>2018-01-19T15:49:24.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>安装好ubuntu系统以后，作为一个简洁的程序员，一方面要美化操作系统，毕竟老夫也是有着一番少女心的，另一方面就要体现程序员的本色了。美化桌面环境和安装各种IDE。</p><h2 id="ubuntu桌面环境的美化"><a href="#ubuntu桌面环境的美化" class="headerlink" title="ubuntu桌面环境的美化"></a>ubuntu桌面环境的美化</h2><p>当你安装好ubuntu系统以后，肯定是欣喜若狂的，都听大婶说Linux操作系统妙用无穷，是程序员居家旅行必备良品。可是当你进入这系统以后，尝试着使用的时候，你却发现这么垃圾反人类的系统是给人用的嘛？当然喽，我第一次也就是这种感觉，垃圾的桌面环境，不友好的图形化操作！唯一看顺眼的就是ubuntu内置的火狐浏览器。不过当你喜欢上它以后就再也离不开他了！</p><a id="more"></a><h3 id="ubuntu-unity桌面"><a href="#ubuntu-unity桌面" class="headerlink" title="ubuntu unity桌面"></a>ubuntu unity桌面</h3><p>当你进入乌班图系统后，接触到的其实是unity桌面，根据百度百科的解释，它是脱胎于gnome桌面的，它使用了一些gnome桌面的一些组件，但是并没有完全使用gnome shell。<br><strong><em>百科解释</em></strong><br><img src="/images/ubuntu/ubuntu16.png" alt=""></p><h3 id="ubuntu-gnome-桌面的安装"><a href="#ubuntu-gnome-桌面的安装" class="headerlink" title="ubuntu gnome 桌面的安装"></a>ubuntu gnome 桌面的安装</h3><p>gnome桌面是很美的，你再选择一个美美哒的桌面背景，那美轮美奂的感觉，很快你就会忘记在失去Windows的痛苦，沉醉在这简洁的环境中，就像婴儿肌肤般的润滑。和Windows相比，它就行豆蔻年华的少女，通红的胴体，任由你去探索，而万恶的Windows就像浓妆艳抹的恶妇，臃肿不堪！<br>安装gnome桌面只需要以下几条命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">安装之前先添加库并更新，已保证后面的安装顺利</span><br><span class="line">sudo add-apt-repository ppa:gnome3-team/gnome3-staging</span><br><span class="line">sudo add-apt-repository ppa:gnome3-team/gnome3</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get dist-upgrade</span><br><span class="line"></span><br><span class="line">sudo apt-get install gnome-shell</span><br><span class="line">sudo apt-get install ubuntu-gnome-desktop</span><br></pre></td></tr></table></figure></p><p>安装时弹出窗选择如下:<br><img src="/images/ubuntu/ubuntu17.png" alt=""><br>当然萝卜白菜各有所爱，卸载命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove gnome-shell</span><br><span class="line">sudo apt-get remove ubuntu-gnome-desktop</span><br></pre></td></tr></table></figure></p><p>安装重启的时候要注意,登录的时候要选择第一项哦,千万不要尝试第二项，否则会开不了机，不要怪我没有告诉你！<br><img src="/images/ubuntu/ubuntu18.png" alt="">  </p><p>重启进入系统如下:<br><img src="/images/ubuntu/ubuntu14.png" alt=""></p><p>选择安装ARC主题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arc-theme安装方法：</span><br><span class="line">sudo add-apt-repository ppa:noobslab/themes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install arc-theme</span><br><span class="line">安装gnome-tweak-tool用于切换主题：</span><br><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">运行gnome-tweak-tool选择Arc-Dark为GTK+主题。</span><br></pre></td></tr></table></figure></p><p>arc主题提供了很多选择，各种颜色搭配。可以让你定制自己喜欢的桌面。  </p><h2 id="系统美化总结"><a href="#系统美化总结" class="headerlink" title="系统美化总结"></a>系统美化总结</h2><p>如果你喜欢Mac桌面下的那个dock风格，你也可以在乌班图下安装，就在乌班图的软件中心搜索dock即可，不过我个人认为那个工具很鸡肋，消耗内存，和乌班图系统融合的也不是很好，不太建议使用。arc-theme主题还在使用中感觉也很不错。配置高的话可以安装一个试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;安装好ubuntu系统以后，作为一个简洁的程序员，一方面要美化操作系统，毕竟老夫也是有着一番少女心的，另一方面就要体现程序员的本色了。美化桌面环境和安装各种IDE。&lt;/p&gt;
&lt;h2 id=&quot;ubuntu桌面环境的美化&quot;&gt;&lt;a href=&quot;#ubuntu桌面环境的美化&quot; class=&quot;headerlink&quot; title=&quot;ubuntu桌面环境的美化&quot;&gt;&lt;/a&gt;ubuntu桌面环境的美化&lt;/h2&gt;&lt;p&gt;当你安装好ubuntu系统以后，肯定是欣喜若狂的，都听大婶说Linux操作系统妙用无穷，是程序员居家旅行必备良品。可是当你进入这系统以后，尝试着使用的时候，你却发现这么垃圾反人类的系统是给人用的嘛？当然喽，我第一次也就是这种感觉，垃圾的桌面环境，不友好的图形化操作！唯一看顺眼的就是ubuntu内置的火狐浏览器。不过当你喜欢上它以后就再也离不开他了！&lt;/p&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://jiaxiaoxuan.top/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://jiaxiaoxuan.top/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu优盘安装</title>
    <link href="http://jiaxiaoxuan.top/2017/10/09/ubuntu%E4%BC%98%E7%9B%98%E5%AE%89%E8%A3%85/"/>
    <id>http://jiaxiaoxuan.top/2017/10/09/ubuntu优盘安装/</id>
    <published>2017-10-09T13:21:58.000Z</published>
    <updated>2018-01-19T15:49:24.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文将介绍如何通过u盘安装ubuntu系统，首先是在Windows系统下通过软通牒制作u盘镜像，其次是在安装过程中的分区问题，以及如何与自己的Windows系统共存，其实Windows10/8/7与ubuntu双系统是举一反三的，本人安装的是ubuntu17.04/Windows10双系统。（有些图是引用网络上的，步骤完全没问题）</p><a id="more"></a><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><p>在安装前请准备以下安装包和工具。<br>  1.U盘一个。<br>  2.ubuntu系统 <a href="http://releases.ubuntu.com/17.04/ubuntu-17.04-desktop-amd64.iso" target="_blank" rel="noopener">下载地址</a><br>  3.软通牒系统 <a href="http://sw.bos.baidu.com/sw-search-sp/software/25aa83cb6273c/uiso9_cn_9.7.0.3476.exe" target="_blank" rel="noopener">百度下载中心</a><br>在Windows系统上下载软通牒并安装，下载ubuntu系统备用。  </p><h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><p>1.软通牒软件如何安装不再介绍，安装好后选择试用即可。<br>如下图：<br><img src="/images/ubuntu/ubuntu1.png" alt=""><br>2.进入软通牒，选择文件-&gt;打开<br><img src="/images/ubuntu/ubuntu3.png" alt=""><br>3.选择已下载好的ubuntu镜像ISO文件<br><img src="/images/ubuntu/ubuntu4.png" alt=""><br>4.打开之后是这个样子，注意软件的顶部文字，显示的是打开ubuntu镜像的<br><img src="/images/ubuntu/ubuntu5.png" alt=""><br>5.然后选择启动-&gt;写入硬盘镜像<br><img src="/images/ubuntu/ubuntu6.png" alt=""><br>6.此时设置如图，注意引导的写入是USB-HDD++，写入时间较长，请耐心等待<br><img src="/images/ubuntu/ubuntu8.png" alt=""><br>7.写入完成以后，打开U盘是这个样子的！<br><img src="/images/ubuntu/ubuntu7.png" alt=""><br>制作好U盘镜像以后，接下来我们就要安装了！</p><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>系统安装并没有特殊的地方，和普通的Windows安装一样，F12（电脑型号不同按键可能不一样，同时有些人的电脑可能禁止了从u盘启动的选项，需要进入BIOS界面重新设置）进入启动选择操作。选择USB，也就是你的U盘，这样就可以直接进入ubuntu安装界面。<br><img src="/images/ubuntu/ubuntu11.png" alt=""><br>上图要选择安装语言，默认是英文，左侧列表往下拉，就能找到中文简体选项。<br>选择安装(当然你也可以选择试用)以后，会让选择是否链接WiFi，是否安装驱动和更新，全部选否，或者不要勾选，等安装完成再更新。<br><img src="/images/ubuntu/ubuntu9.png" alt=""><br>点击下一步，会出现下面两种情况，一种是已经安装有其他操作系统，一种是没有，如下图。<br><img src="/images/ubuntu/ubuntu10.png" alt=""><img src="/images/ubuntu/ubuntu12.png" alt=""><br>傻瓜式安装选择第一项就可。<br>下面的选择继续<br><img src="/images/ubuntu/ubuntu13.png" alt=""><br>后面的过程就是下一步，下一步了。时区、键盘设置、用户密码设置不在叙述。  </p><h2 id="分区问题"><a href="#分区问题" class="headerlink" title="分区问题"></a>分区问题</h2><p>如果在上面不是选择傻瓜式安装，而是选择自定义分区了，怎么办呢，其实作为从事开发工作的就应该选择自定义安装，这确实能够学到些东西。  </p><p>以下知乎上面说的，我截取了下了<br>作者：知乎用户<br>链接：<a href="https://www.zhihu.com/question/20565314/answer/15518260" target="_blank" rel="noopener">https://www.zhihu.com/question/20565314/answer/15518260</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p> Ubuntu 桌面系统的分区方案。<br> 要了解分区方案，先从 Linux 系统的目录结构说起。使用 Windows 系统的用户都知道，Windows 系统先有分区的存在，然后在不同的分区下创建文件目录结构。于是我们看到诸如 C:\Windows D:\Downloads 之类目录，也就是说每一个目录首先是存在于某个分区的。Linux 系统则相反，它首先确定有目录的存在，例如：/， /usr， /media/usb，/media/cdrom， /disk 然后才确定这个目录上挂载的是哪个分区（甚至挂载的可能是CDROM， USB等外设以及ISO光盘镜像文件：类似 Windows 下虚拟光驱的作用）。访问某个目录，实质上就相当于访问挂载在这个目录上的分区，外设或者光盘镜像文件。<br> 我们在 上一篇 博客中提到过一个系统存储重要数据的目录： /home 目录， 在通常的最佳实践中，可以把这个 home 目录作为一个单独的挂载点，挂载一个独立分区。这样做有几个好处：<br> 系统分区如果损坏，幷不影响到 /home 分区所在的数据。这些数据通常非常重要，包括有你常用的软件，重要的文档以及各类软件的配置信息，反过来我们也鼓励把重要的数据存放在 /home 目录下，使得他们保存在系统分区以外的分区，避免因为系统的问题受损。在重装系统，或者升级系统以后，/home 分区的数据可以得到保留，最大程度的避免了软件安装和重新配置的耗时工作。在日常备份的工作中可以选择只备份 /home 分区所在的数据，避免做全盘的备份。我自己就曾经因为在两年前安装Ubuntu 10.04的时候只分了一个分区，把 /home 目录下的数据和系统文件存储在了同一个分区下，导致在安装Ubuntu 12.04的时候，在没有第二个分区和第二台电脑用来备份/home目录数据的情况下，忍痛将整个系统连同/home目录里的数据全部格式化，损失惨重， 教训深刻。<br> 所以一般来说一个 Ubuntu 的系统在安装之初应该有三个分区，他们分别是挂载于根目录： /, home目录： /home 的两个分区以及 swap 分区。swap分区是指虚拟内存的交换区，一般设置为实际内存容量的两倍大小即可。假设你有一台500G硬盘，2G内存的PC，那么比较好的分区分配方案是：根目录所在分区分配50G左右， swap分区分配4G，剩余空间全部留给 /home 所在分区即可。<br><strong>安装注意事项在安装之前</strong>  ，记得备份本机重要数据。在电脑上插入启动U盘后，选择从U盘启动计算机：大多数电脑可以在出现启动画面的时候按F12选择启动媒介，此时选择U盘即可。之后一路安装 Ubuntu 会比较顺利，但是以下几个地方仍然需要注意：在 Installation type 界面选择 Something else 选项，这样你才有机会调整，保留现有分区以及分区上的数据，并将多个分区挂载到同一个系统的不同挂载点（上文所述的根目录和home目录）【推荐】。选择 ext4 文件系统格式作为 Linux 的文件系统格式。三个分区大小可按上个小节分配，根目录分区大小不必过大，50G至多，如果硬盘本身不大，只分配15G问题也不大。大多的数据应该存放在 /home， 因此 /home 所在分区应该足够大。Installation type 界面中 Device for boot loader installation 选项列表中记得选择硬盘所在条目一般是：/dev/sda，笔者安装 12.04 时因为不慎选择了 USB 所在媒介：/dev/sdb 导致安装完毕后只有插着USB才能启动系统，悲剧！(此种情况本人在安装过程也遇到了，只能费劲再重新来过！！！！！！)   </p><p>下面是本人整理的分区方案:</p><table><thead><tr><th>目录</th><th>建议大小</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>/</td><td>10G-20G</td><td>ext4</td><td>根目录</td></tr><tr><td>swap</td><td>&lt;2048M</td><td>swap</td><td>交换空间</td></tr><tr><td>/boot</td><td>500M左右</td><td>ext4</td><td>Linux的内核及引导系统程序所需要的文件，比如 vmlinuz initrd.img文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；启动撞在文件存放位置，如kernels，initrd，grub。有人说200M可惜ubuntu17不够用，我被迫重装。</td></tr><tr><td>/tmp</td><td>5G左右</td><td>ext4</td><td>系统的临时文件，一般系统重启不会被保存。（建立服务器需要？）</td></tr><tr><td>/home</td><td>尽量大些</td><td>ext4</td><td>用户工作目录；个人配置文件，如个人环境变量等；所有账号分配一个工作目录。</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>国庆八天假，几乎每天回来都会倒腾ubuntu系统，来来回回重装了好几次，可是折腾死我了！明天再接着介绍如何美化ubuntu，总不能装个那么丑的ubuntu工作吧，原生的unity主题太丑，影响我心情！  放个图!  </p><p><img src="/images/ubuntu/ubuntu14.png" alt="">  </p><p>JB公司全家桶！<br><img src="/images/ubuntu/ubuntu15.png" alt="">   </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文将介绍如何通过u盘安装ubuntu系统，首先是在Windows系统下通过软通牒制作u盘镜像，其次是在安装过程中的分区问题，以及如何与自己的Windows系统共存，其实Windows10/8/7与ubuntu双系统是举一反三的，本人安装的是ubuntu17.04/Windows10双系统。（有些图是引用网络上的，步骤完全没问题）&lt;/p&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://jiaxiaoxuan.top/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="http://jiaxiaoxuan.top/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://jiaxiaoxuan.top/2017/09/25/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jiaxiaoxuan.top/2017/09/25/装饰模式/</id>
    <published>2017-09-25T06:23:43.000Z</published>
    <updated>2018-01-02T15:02:41.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>装饰设计模式</em></strong></p><h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。<br>（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2） 装饰对象包含一个真实对象的引用（reference）<br>（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</p><a id="more"></a><h1 id="理论详解"><a href="#理论详解" class="headerlink" title="理论详解"></a>理论详解</h1><p>要求：自定义一些Reader类，读取不同的数据(装饰和继承的区别)<br>MyReader //专门用于读取数据的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|--MyTextReader</span><br><span class="line">        |--MyBufferTextReader</span><br><span class="line">|--MyMediaReader</span><br><span class="line">        |--MyBufferMediaReader</span><br><span class="line">|--MyDataReader</span><br><span class="line">        |--MyBufferDataReader</span><br></pre></td></tr></table></figure><p>如果将他们抽取出来，设计一个MyBufferReader，可以根据传入的类型进行增强</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyBufferReader &#123;</span><br><span class="line">    MyBufferReader (MyTextReader text) &#123;&#125;</span><br><span class="line">    MyBufferReader (MyMediaReader media) &#123;&#125;</span><br><span class="line">    MyBufferReader (MyDataReader data) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的类拓展性很差。找到其参数的共同类型即共同实现的接口或者继承的类，通过多态的形式，可以提高拓展性.这样以后的类只要继承共同的类型,都能用这个增强类增强自身的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class MyBufferReader  extends MyReader&#123;</span><br><span class="line">    private MyReader r;                        //从继承变为了组成模式  装饰设计模式</span><br><span class="line">    MyBufferReader(MyReader r) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的体系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|--MyTextReader</span><br><span class="line">    |--MyMediaReader</span><br><span class="line">    |--MyDataReader</span><br><span class="line">    |--MyBufferReader</span><br></pre></td></tr></table></figure><p> //增强上面三个。装饰模式比继承灵活，避免继承体系的臃肿。降低类与类之间的耦合性</p><p>装饰类只能增强已有的对象，具备的功能是相同的。所以装饰类和被装饰类属于同一个体系.</p><p>MyBuffereReader类：  自己写一个MyBuffereReader类，功能与BuffereReader相同</p><h1 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.Reader;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 基于i/o流的装饰模式练习</span><br><span class="line"> * @author Administrator</span><br><span class="line"> * 2017年8月18日  下午4:32:00</span><br><span class="line"> */</span><br><span class="line">public class MyBufferReader extends Reader&#123;</span><br><span class="line"></span><br><span class="line">     private Reader r;  </span><br><span class="line">     MyBufferReader(Reader r)&#123;  </span><br><span class="line">          this.r  = r;  </span><br><span class="line">     &#125;</span><br><span class="line">@Override</span><br><span class="line">public int read(char[] cbuf, int off, int len) throws IOException &#123;</span><br><span class="line">return  r.read(cbuf,off,len);  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() throws IOException &#123;</span><br><span class="line"> r.close();  </span><br><span class="line">&#125;</span><br><span class="line">   //一次读一行数据的方法  </span><br><span class="line">   public String myReaderline()  throws IOException &#123;  </span><br><span class="line">       //定义一个临时容器，原BufferReader封装的是字符数组。  </span><br><span class="line">       //为了演示方便。定义一个StringBuilder容器。最终要将数据变成字符串  </span><br><span class="line">       StringBuilder sb = new StringBuilder();  </span><br><span class="line">       int ch = 0;  </span><br><span class="line">       while((ch = r.read()) != -1)  </span><br><span class="line">       &#123;  </span><br><span class="line">           if(ch == &apos;\r&apos;)   </span><br><span class="line">               continue;  </span><br><span class="line">           if(ch == &apos;\n&apos;)                    //遇到换行符\n,返回字符串  </span><br><span class="line">               return sb.toString();  </span><br><span class="line">           else  </span><br><span class="line">           sb.append((char)ch);  </span><br><span class="line">       &#125;  </span><br><span class="line">       if(sb.length()!=0)                    //当最后一行不是以\n结束时候，这里需要判断  </span><br><span class="line">           return sb.toString();  </span><br><span class="line">       return null;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   @SuppressWarnings(&quot;resource&quot;)</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">   MyBufferReader myReader=new MyBufferReader(new InputStreamReader(new FileInputStream(&quot;E:/files.txt&quot;)));</span><br><span class="line">   System.out.println(myReader.myReaderline());</span><br><span class="line">   myReader.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>装饰模式相当于对房屋进行装修，不过在设计的时候，要避免对一个房屋装修，应该通过接口，定义一类房屋，对实现了这个接口的一类房屋进行装修。这样设计出来的装饰类，更具拓展性。只要符合这个接口的新建房屋都可以使用这个装修队来装修。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;装饰设计模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot; title=&quot;摘要：&quot;&gt;&lt;/a&gt;摘要：&lt;/h1&gt;&lt;p&gt;装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;br&gt;（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。&lt;br&gt;（2） 装饰对象包含一个真实对象的引用（reference）&lt;br&gt;（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。&lt;br&gt;（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://jiaxiaoxuan.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="装饰模式" scheme="http://jiaxiaoxuan.top/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC之参数绑定</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/SpringMVC%E4%B9%8B%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/SpringMVC之参数绑定/</id>
    <published>2017-09-24T14:44:15.000Z</published>
    <updated>2018-01-02T15:02:41.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><p>前段时间项目中用到了REST风格来开发程序，但是当用POST、PUT模式提交数据时，发现服务器端接受不到提交的数据（服务器端参数绑定没有加任何注解），查看了提交方式为application/json， 而且服务器端通过request.getReader() 打出的数据里确实存在浏览器提交的数据。为了找出原因，便对参数绑定<br>@RequestParam<br>@RequestBody<br>@RequestHeader<br>@PathVariable<br>进行了研究，同时也看了一下HttpMessageConverter的相关内容，在此一并总结。</p><p>此篇文章虽然也是摘抄自网络，但是也解决了最近一来我得困惑，对这些注解的选用，同样的我也在继续的研究中!<br><a id="more"></a></p><h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>RequestMapping注解有六个属性，下面我们把她分成三类进行说明。  </p><h2 id="1、-value，-method"><a href="#1、-value，-method" class="headerlink" title="1、 value， method"></a>1、 value， method</h2><ul><li><p>value:指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；当之设置value一个属性时，value可以省略不写，当有其他属性时则需要加上进行区分，如下图：<br>　　　　　<br>　　<img src="/images/spring1.png" alt="image">　　　</p></li><li><p>method：  指定请求的method类型， GET、POST、PUT、DELETE等；</p><h2 id="2、-consumes，produces"><a href="#2、-consumes，produces" class="headerlink" title="2、 consumes，produces:"></a>2、 consumes，produces:</h2></li><li><p>consumes:指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;  </p></li><li><p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；  </p><h2 id="3、-params，headers"><a href="#3、-params，headers" class="headerlink" title="3、 params，headers:"></a>3、 params，headers:</h2></li><li>params： 指定request中必须包含某些参数值是，才让该方法处理。  </li><li>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。  <h1 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h1><h2 id="1、value-method-示例"><a href="#1、value-method-示例" class="headerlink" title="1、value  / method 示例"></a>1、value  / method 示例</h2>默认RequestMapping(“….str…”)即为value的值；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Controller  </span><br><span class="line">@RequestMapping(&quot;/appointments&quot;)  </span><br><span class="line">public class AppointmentsController &#123;  </span><br><span class="line"></span><br><span class="line">    private final AppointmentBook appointmentBook;  </span><br><span class="line"></span><br><span class="line">    @Autowired  </span><br><span class="line">    public AppointmentsController(AppointmentBook appointmentBook) &#123;  </span><br><span class="line">        this.appointmentBook = appointmentBook;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @RequestMapping(method = RequestMethod.GET)  </span><br><span class="line">    public Map&lt;String, Appointment&gt; get() &#123;  </span><br><span class="line">        return appointmentBook.getAppointmentsForToday();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/&#123;day&#125;&quot;, method = RequestMethod.GET)  </span><br><span class="line">    public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) &#123;  </span><br><span class="line">        return appointmentBook.getAppointmentsForDay(day);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/new&quot;, method = RequestMethod.GET)  </span><br><span class="line">    public AppointmentForm getNewForm() &#123;  </span><br><span class="line">        return new AppointmentForm();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @RequestMapping(method = RequestMethod.POST)  </span><br><span class="line">    public String add(@Valid AppointmentForm appointment, BindingResult result) &#123;  </span><br><span class="line">        if (result.hasErrors()) &#123;  </span><br><span class="line">            return &quot;appointments/new&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">        appointmentBook.addAppointment(appointment);  </span><br><span class="line">        return &quot;redirect:/appointments&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value的uri值为以下三类：<br>A） 可以指定为普通的具体值；<br>B)  可以指定为含有某变量的一类值(URI Template Patterns with Path Variables)；<br>C) 可以指定为含正则表达式的一类值( URI Template Patterns with Regular Expressions);   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example B)</span><br><span class="line">@RequestMapping(value=&quot;/owners/&#123;ownerId&#125;&quot;, method=RequestMethod.GET)  </span><br><span class="line">public String findOwner(@PathVariable String ownerId, Model model) &#123;  </span><br><span class="line">  Owner owner = ownerService.findOwner(ownerId);    </span><br><span class="line">  model.addAttribute(&quot;owner&quot;, owner);    </span><br><span class="line">  return &quot;displayOwner&quot;;   </span><br><span class="line">&#125;</span><br><span class="line">example C)</span><br><span class="line">@RequestMapping(&quot;/spring-web/&#123;symbolicName:[a-z-]+&#125;-&#123;version:\d\.\d\.\d&#125;.&#123;extension:\.[a-z]&#125;&quot;)  </span><br><span class="line">  public void handle(@PathVariable String version, @PathVariable String extension) &#123;      </span><br><span class="line">    // ...  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-consumes、produces-示例"><a href="#2-consumes、produces-示例" class="headerlink" title="2 consumes、produces 示例"></a>2 consumes、produces 示例</h2><p><strong>cousumes的样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 @Controller  </span><br><span class="line">2 @RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;)  </span><br><span class="line">3 public void addPet(@RequestBody Pet pet, Model model) &#123;      </span><br><span class="line">4     // implementation omitted  </span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure><p>方法仅处理request Content-Type为“application/json”类型的请求。  </p><p><strong>produces的样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Controller  </span><br><span class="line">@RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, produces=&quot;application/json&quot;)  </span><br><span class="line">@ResponseBody  </span><br><span class="line">public Pet getPet(@PathVariable String petId, Model model) &#123;      </span><br><span class="line">    // implementation omitted  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法仅处理request请求中Accept头中包含了”application/json”的请求，同时暗示了返回的内容类型为application/json;  </p><h2 id="3-params、headers-示例"><a href="#3-params、headers-示例" class="headerlink" title="3 params、headers 示例"></a>3 params、headers 示例</h2><p><strong>params的样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 @Controller  </span><br><span class="line">2 @RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)  </span><br><span class="line">3 public class RelativePathUriTemplateController &#123;  </span><br><span class="line">4   </span><br><span class="line">5   @RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)  </span><br><span class="line">6   public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;      </span><br><span class="line">7     // implementation omitted  </span><br><span class="line">8   &#125;  </span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure><p>仅处理请求中包含了名为“myParam”，值为“myValue”的请求；<br><strong>headers的样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 @Controller  </span><br><span class="line">2 @RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)  </span><br><span class="line">3 public class RelativePathUriTemplateController &#123;  </span><br><span class="line">4   </span><br><span class="line">5 @RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)  </span><br><span class="line">6   public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;      </span><br><span class="line">7     // implementation omitted  </span><br><span class="line">8   &#125;  </span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure><p>仅处理request的header中包含了指定“Refer”请求头和对应值为“<a href="http://www.ifeng.com/”的请求；" target="_blank" rel="noopener">http://www.ifeng.com/”的请求；</a>  </p><h1 id="参数绑定注解简介："><a href="#参数绑定注解简介：" class="headerlink" title="参数绑定注解简介："></a>参数绑定注解简介：</h1><p>handler method 参数绑定常用的注解,我们根据他们处理的Request的不同内容部分分为四类七个注解 ：（主要讲解常用类型）<br>A、处理requet uri 部分（这里指uri template中variable，不含queryString部分）的注解：   @PathVariable;<br>B、处理request header部分的注解：   @RequestHeader, @CookieValue;<br>C、处理request body部分的注解：@RequestParam,  @RequestBody;<br>D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;   </p><h2 id="1、-PathVariable"><a href="#1、-PathVariable" class="headerlink" title="1、 @PathVariable"></a>1、 @PathVariable</h2><p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。<br>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. @Controller  </span><br><span class="line">2. @RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)  </span><br><span class="line">3. public class RelativePathUriTemplateController &#123;  </span><br><span class="line">4. @RequestMapping(&quot;/pets/&#123;petId&#125;&quot;)  </span><br><span class="line">5. public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123;      </span><br><span class="line">6. // implementation omitted  </span><br><span class="line">7.   &#125;  </span><br><span class="line">8. &#125;</span><br></pre></td></tr></table></figure><p>上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。</p><h2 id="2、-RequestHeader、-CookieValue"><a href="#2、-RequestHeader、-CookieValue" class="headerlink" title="2、 @RequestHeader、@CookieValue"></a>2、 @RequestHeader、@CookieValue</h2><p><strong>@RequestHeader</strong> 注解，可以把Request请求header部分的值绑定到方法的参数上。<br>示例代码：<br>这是一个Request 的header部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Host                    localhost:8080  </span><br><span class="line">2. Accept                  text/html,application/xhtml+xml,application/xml;q=0.9  </span><br><span class="line">3. Accept-Language         fr,en-gb;q=0.7,en;q=0.3  </span><br><span class="line">4. Accept-Encoding         gzip,deflate  </span><br><span class="line">5. Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7  </span><br><span class="line">6. Keep-Alive              300</span><br></pre></td></tr></table></figure></p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. @RequestMapping(&quot;/displayHeaderInfo.do&quot;)  </span><br><span class="line">2. public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,  </span><br><span class="line">3. @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive)  &#123;  </span><br><span class="line">4. //...  </span><br><span class="line">5. &#125;</span><br></pre></td></tr></table></figure><p>上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。<br><strong>@CookieValue</strong> 可以把Request header中关于cookie的值绑定到方法的参数上。<br>例如有如下Cookie值：  </p><pre><code>1. JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84  </code></pre><p>参数绑定的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. @RequestMapping(&quot;/displayHeaderInfo.do&quot;)  </span><br><span class="line">2. public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  &#123;  </span><br><span class="line">3. //...  </span><br><span class="line">4. &#125;</span><br></pre></td></tr></table></figure><p>即把JSESSIONID的值绑定到参数cookie上。  </p><h2 id="3、-RequestParam-RequestBody"><a href="#3、-RequestParam-RequestBody" class="headerlink" title="3、@RequestParam, @RequestBody"></a>3、@RequestParam, @RequestBody</h2><p><strong>@RequestParam</strong><br>A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；<br>因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；</p><p>B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；  </p><p>C) 该注解有两个属性： value、required；  </p><p>value用来指定要传入值的id名称，required用来指示参数是否必须绑定；<br>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. @Controller  </span><br><span class="line">2. @RequestMapping(&quot;/pets&quot;)  </span><br><span class="line">3. @SessionAttributes(&quot;pet&quot;)  </span><br><span class="line">4. public class EditPetForm &#123;  </span><br><span class="line">5. // ...  </span><br><span class="line">6. @RequestMapping(method = RequestMethod.GET)  </span><br><span class="line">7. public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) &#123;  </span><br><span class="line">8.         Pet pet = this.clinic.loadPet(petId);  </span><br><span class="line">9.         model.addAttribute(&quot;pet&quot;, pet);  </span><br><span class="line">10. return &quot;petForm&quot;;  </span><br><span class="line">11.     &#125;  </span><br><span class="line">12. // ...</span><br></pre></td></tr></table></figure><p><strong>@RequestBody</strong><br>该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；<br>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。<br>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;<br>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. @RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)  </span><br><span class="line">2. public void handle(@RequestBody String body, Writer writer) throws IOException &#123;  </span><br><span class="line">3.   writer.write(body);  </span><br><span class="line">4. &#125;</span><br></pre></td></tr></table></figure><h2 id="4、-SessionAttributes-ModelAttribute"><a href="#4、-SessionAttributes-ModelAttribute" class="headerlink" title="4、@SessionAttributes, @ModelAttribute"></a>4、@SessionAttributes, @ModelAttribute</h2><p><strong>@SessionAttributes:</strong><br>该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。<br>该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象；<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. @Controller  </span><br><span class="line">2. @RequestMapping(&quot;/editPet.do&quot;)  </span><br><span class="line">3. @SessionAttributes(&quot;pet&quot;)  </span><br><span class="line">4. public class EditPetForm &#123;  </span><br><span class="line">5. // ...  </span><br><span class="line">6. &#125;</span><br></pre></td></tr></table></figure></p><h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><p>该注解有两个用法，一个是用于方法上，一个是用于参数上；  </p><ul><li>用于方法上时：  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；   </li><li>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：<br>A） @SessionAttributes 启用的attribute 对象上；<br>B） @ModelAttribute 用于方法上时指定的model对象；<br>C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。<br>用到方法上@ModelAttribute的示例代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. // Add one attribute  </span><br><span class="line">2. // The return value of the method is added to the model under the name &quot;account&quot;  </span><br><span class="line">3. // You can customize the name via @ModelAttribute(&quot;myAccount&quot;)  </span><br><span class="line">4. @ModelAttribute  </span><br><span class="line">5. public Account addAccount(@RequestParam String number) &#123;  </span><br><span class="line">6. return accountManager.findAccount(number);  </span><br><span class="line">7. &#125;</span><br></pre></td></tr></table></figure><p>这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）；  </p><p>用在参数上的@ModelAttribute示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. @RequestMapping(value=&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)  </span><br><span class="line">2. public String processSubmit(@ModelAttribute Pet pet) &#123;  </span><br><span class="line">3. &#125;</span><br></pre></td></tr></table></figure></p><p>首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。</p><h1 id="源码剖析："><a href="#源码剖析：" class="headerlink" title="源码剖析："></a>源码剖析：</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：<br>i) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；<br>ii) 再把HttpMessageConverter返回的对象数据绑定到   controller中方法的参数上。</p><pre><code>使用时机：  A) GET、POST方式提时， 根据request header Content-Type的值来判断:● application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam,  @ModelAttribute也可以处理，当然@RequestBody也能处理）；● multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；● 其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；B) PUT方式提交时， 根据request header Content-Type的值来判断:  ●  application/x-www-form-urlencoded， 必须；  ●  multipart/form-data, 不能处理；  ●  其他格式， 必须；  </code></pre><p>说明：request的body部分的数据编码格式由header部分的Content-Type指定；  </p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>作用：<br>该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">HttpMessageConverter</span><br><span class="line">1. &quot;font-family:Microsoft YaHei;&quot;&gt;/**</span><br><span class="line">2.  * Strategy interface that specifies a converter that can convert from and to HTTP requests and responses.</span><br><span class="line">3.  *</span><br><span class="line">4.  * @author Arjen Poutsma</span><br><span class="line">5.  * @author Juergen Hoeller</span><br><span class="line">6.  * @since 3.0</span><br><span class="line">7.  */  </span><br><span class="line">8. public interface HttpMessageConverter &#123;  </span><br><span class="line">9. /**</span><br><span class="line">10.      * Indicates whether the given class can be read by this converter.</span><br><span class="line">11.      * @param clazz the class to test for readability</span><br><span class="line">12.      * @param mediaType the media type to read, can be &#123;@code null&#125; if not specified.</span><br><span class="line">13.      * Typically the value of a &#123;@code Content-Type&#125; header.</span><br><span class="line">14.      * @return &#123;@code true&#125; if readable; &#123;@code false&#125; otherwise</span><br><span class="line">15.      */  </span><br><span class="line">16. boolean canRead(Class clazz, MediaType mediaType);  </span><br><span class="line">17. /**</span><br><span class="line">18.      * Indicates whether the given class can be written by this converter.</span><br><span class="line">19.      * @param clazz the class to test for writability</span><br><span class="line">20.      * @param mediaType the media type to write, can be &#123;@code null&#125; if not specified.</span><br><span class="line">21.      * Typically the value of an &#123;@code Accept&#125; header.</span><br><span class="line">22.      * @return &#123;@code true&#125; if writable; &#123;@code false&#125; otherwise</span><br><span class="line">23.      */  </span><br><span class="line">24. boolean canWrite(Class clazz, MediaType mediaType);  </span><br><span class="line">25. /**</span><br><span class="line">26.      * Return the list of &#123;@link MediaType&#125; objects supported by this converter.</span><br><span class="line">27.      * @return the list of supported media types</span><br><span class="line">28.      */  </span><br><span class="line">29.     List getSupportedMediaTypes();  </span><br><span class="line">30. /**</span><br><span class="line">31.      * Read an object of the given type form the given input message, and returns it.</span><br><span class="line">32.      * @param clazz the type of object to return. This type must have previously been passed to the</span><br><span class="line">33.      * &#123;@link #canRead canRead&#125; method of this interface, which must have returned &#123;@code true&#125;.</span><br><span class="line">34.      * @param inputMessage the HTTP input message to read from</span><br><span class="line">35.      * @return the converted object</span><br><span class="line">36.      * @throws IOException in case of I/O errors</span><br><span class="line">37.      * @throws HttpMessageNotReadableException in case of conversion errors</span><br><span class="line">38.      */  </span><br><span class="line">39.     T read(Classextends T&gt; clazz, HttpInputMessage inputMessage)  </span><br><span class="line">40. throws IOException, HttpMessageNotReadableException;  </span><br><span class="line">41. /**</span><br><span class="line">42.      * Write an given object to the given output message.</span><br><span class="line">43.      * @param t the object to write to the output message. The type of this object must have previously been</span><br><span class="line">44.      * passed to the &#123;@link #canWrite canWrite&#125; method of this interface, which must have returned &#123;@code true&#125;.</span><br><span class="line">45.      * @param contentType the content type to use when writing. May be &#123;@code null&#125; to indicate that the</span><br><span class="line">46.      * default content type of the converter must be used. If not &#123;@code null&#125;, this media type must have</span><br><span class="line">47.      * previously been passed to the &#123;@link #canWrite canWrite&#125; method of this interface, which must have</span><br><span class="line">48.      * returned &#123;@code true&#125;.</span><br><span class="line">49.      * @param outputMessage the message to write to</span><br><span class="line">50.      * @throws IOException in case of I/O errors</span><br><span class="line">51.      * @throws HttpMessageNotWritableException in case of conversion errors</span><br><span class="line">52.      */  </span><br><span class="line">53. void write(T t, MediaType contentType, HttpOutputMessage outputMessage)  </span><br><span class="line">54. throws IOException, HttpMessageNotWritableException;  </span><br><span class="line">55. &#125;  </span><br><span class="line">56.</span><br></pre></td></tr></table></figure><p>该接口定义了四个方法，分别是读取数据时的 canRead(), read() 和 写入数据时的canWrite(), write()方法。<br>在使用 标签配置时，默认配置了RequestMappingHandlerAdapter（注意是RequestMappingHandlerAdapter不是AnnotationMethodHandlerAdapter,详情查看spring 3.1 document “16.14 Configuring Spring MVC”章节），并为他配置了一下默认的HttpMessageConverter：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. ByteArrayHttpMessageConverter converts byte arrays.  </span><br><span class="line">2. StringHttpMessageConverter converts strings.  </span><br><span class="line">3. ResourceHttpMessageConverter converts to/from org.springframework.core.io.Resource for all media types.  </span><br><span class="line">4. SourceHttpMessageConverter converts to/from a javax.xml.transform.Source.  </span><br><span class="line">5. FormHttpMessageConverter converts form data to/from a MultiValueMap.  </span><br><span class="line">6. Jaxb2RootElementHttpMessageConverter converts Java objects to/from XML — added if JAXB2 is present on the classpath.  </span><br><span class="line">7. MappingJacksonHttpMessageConverter converts to/from JSON — added if Jackson is present on the classpath.  </span><br><span class="line">8. AtomFeedHttpMessageConverter converts Atom feeds — added if Rome is present on the classpath.  </span><br><span class="line">9. RssChannelHttpMessageConverter converts RSS feeds — added if Rome is present on the classpath.</span><br></pre></td></tr></table></figure><ul><li>ByteArrayHttpMessageConverter:负责读取二进制格式的数据和写出二进制格式的数据；</li><li>StringHttpMessageConverter：   负责读取字符串格式的数据和写出二进制格式的数据；</li><li>ResourceHttpMessageConverter：负责读取资源文件和写出资源文件数据；</li><li>FormHttpMessageConverter：<br>负责读取form提交的数据（能读取的数据格式为 application/x-www-form-urlencoded，不能读取multipart/form-data格式数据）；负责写入application/x-www-from-urlencoded和multipart/form-data格式的数据；</li><li>MappingJacksonHttpMessageConverter:  负责读取和写入json格式的数据；</li><li>SouceHttpMessageConverter：                   负责读取和写入 xml 中javax.xml.transform.Source定义的数据；</li><li>Jaxb2RootElementHttpMessageConverter:  负责读取和写入xml 标签格式的数据；</li><li>AtomFeedHttpMessageConverter:              负责读取和写入Atom格式的数据；</li><li>RssChannelHttpMessageConverter:           负责读取和写入RSS格式的数据；<br>当使用@RequestBody和@ResponseBody注解时，RequestMappingHandlerAdapter就使用它们来进行读取或者写入相应格式的数据。<br>HttpMessageConverter匹配过程：<br><strong>@RequestBody注解时：</strong><br>根据Request对象header部分的Content-Type类型，逐一匹配合适的HttpMessageConverter来读取数据；<br>spring 3.1源代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;font-family:Microsoft YaHei;&quot;&gt;private Object readWithMessageConverters(MethodParameter methodParam, HttpInputMessage inputMessage, Class paramType)  </span><br><span class="line">  2. throws Exception &#123;  </span><br><span class="line">  3.         MediaType contentType = inputMessage.getHeaders().getContentType();  </span><br><span class="line">  4. if (contentType == null) &#123;  </span><br><span class="line">  5.             StringBuilder builder = new StringBuilder(ClassUtils.getShortName(methodParam.getParameterType()));  </span><br><span class="line">  6.             String paramName = methodParam.getParameterName();  </span><br><span class="line">  7. if (paramName != null) &#123;  </span><br><span class="line">  8.                 builder.append(&apos; &apos;);  </span><br><span class="line">  9.                 builder.append(paramName);  </span><br><span class="line">  10.             &#125;  </span><br><span class="line">  11. throw new HttpMediaTypeNotSupportedException(  </span><br><span class="line">  12. &quot;Cannot extract parameter (&quot; + builder.toString() + &quot;): no Content-Type found&quot;);  </span><br><span class="line">  13.         &#125;  </span><br><span class="line">  14.         List allSupportedMediaTypes = new ArrayList();  </span><br><span class="line">  15. if (this.messageConverters != null) &#123;  </span><br><span class="line">  16. for (HttpMessageConverter messageConverter : this.messageConverters) &#123;  </span><br><span class="line">  17.                 allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());  </span><br><span class="line">  18. if (messageConverter.canRead(paramType, contentType)) &#123;  </span><br><span class="line">  19. if (logger.isDebugEnabled()) &#123;  </span><br><span class="line">  20.                         logger.debug(&quot;Reading [&quot; + paramType.getName() + &quot;] as \&quot;&quot; + contentType  </span><br><span class="line">  21.                                 +&quot;\&quot; using [&quot; + messageConverter + &quot;]&quot;);  </span><br><span class="line">  22.                     &#125;  </span><br><span class="line">  23. return messageConverter.read(paramType, inputMessage);  </span><br><span class="line">  24.                 &#125;  </span><br><span class="line">  25.             &#125;  </span><br><span class="line">  26.         &#125;  </span><br><span class="line">  27. throw new HttpMediaTypeNotSupportedException(contentType, allSupportedMediaTypes);  </span><br><span class="line">  28.     &#125;</span><br></pre></td></tr></table></figure><p><strong>@ResponseBody注解时：</strong> 根据Request对象header部分的Accept属性（逗号分隔），逐一按accept中的类型，去遍历找到能处理的HttpMessageConverter；<br>源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;font-family:Microsoft YaHei;&quot;&gt;private void writeWithMessageConverters(Object returnValue,  </span><br><span class="line">2.                 HttpInputMessage inputMessage, HttpOutputMessage outputMessage)  </span><br><span class="line">3. throws IOException, HttpMediaTypeNotAcceptableException &#123;  </span><br><span class="line">4.             List acceptedMediaTypes = inputMessage.getHeaders().getAccept();  </span><br><span class="line">5. if (acceptedMediaTypes.isEmpty()) &#123;  </span><br><span class="line">6.                 acceptedMediaTypes = Collections.singletonList(MediaType.ALL);  </span><br><span class="line">7.             &#125;  </span><br><span class="line">8.             MediaType.sortByQualityValue(acceptedMediaTypes);  </span><br><span class="line">9.             Class returnValueType = returnValue.getClass();  </span><br><span class="line">10.             List allSupportedMediaTypes = new ArrayList();  </span><br><span class="line">11. if (getMessageConverters() != null) &#123;  </span><br><span class="line">12. for (MediaType acceptedMediaType : acceptedMediaTypes) &#123;  </span><br><span class="line">13. for (HttpMessageConverter messageConverter : getMessageConverters()) &#123;  </span><br><span class="line">14. if (messageConverter.canWrite(returnValueType, acceptedMediaType)) &#123;  </span><br><span class="line">15.                             messageConverter.write(returnValue, acceptedMediaType, outputMessage);  </span><br><span class="line">16. if (logger.isDebugEnabled()) &#123;  </span><br><span class="line">17.                                 MediaType contentType = outputMessage.getHeaders().getContentType();  </span><br><span class="line">18. if (contentType == null) &#123;  </span><br><span class="line">19.                                     contentType = acceptedMediaType;  </span><br><span class="line">20.                                 &#125;  </span><br><span class="line">21.                                 logger.debug(&quot;Written [&quot; + returnValue + &quot;] as \&quot;&quot; + contentType +  </span><br><span class="line">22. &quot;\&quot; using [&quot; + messageConverter + &quot;]&quot;);  </span><br><span class="line">23.                             &#125;  </span><br><span class="line">24. this.responseArgumentUsed = true;  </span><br><span class="line">25. return;  </span><br><span class="line">26.                         &#125;  </span><br><span class="line">27.                     &#125;  </span><br><span class="line">28.                 &#125;  </span><br><span class="line">29. for (HttpMessageConverter messageConverter : messageConverters) &#123;  </span><br><span class="line">30.                     allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());  </span><br><span class="line">31.                 &#125;  </span><br><span class="line">32.             &#125;  </span><br><span class="line">33. throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);  </span><br><span class="line">34.         &#125;</span><br></pre></td></tr></table></figure><p>补充：<br>MappingJacksonHttpMessageConverter调用了objectMapper.writeValue(OutputStream stream, Object)方法，使用@ResponseBody注解返回的对象就传入Object参数内。若返回的对象为已经格式化好的json串时，不使用@RequestBody注解，而应该这样处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、response.setContentType(&quot;application/json; charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">2、response.getWriter().print(jsonStr);</span><br></pre></td></tr></table></figure><p>直接输出到body区，然后的视图为void。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot; title=&quot;摘要：&quot;&gt;&lt;/a&gt;摘要：&lt;/h1&gt;&lt;p&gt;前段时间项目中用到了REST风格来开发程序，但是当用POST、PUT模式提交数据时，发现服务器端接受不到提交的数据（服务器端参数绑定没有加任何注解），查看了提交方式为application/json， 而且服务器端通过request.getReader() 打出的数据里确实存在浏览器提交的数据。为了找出原因，便对参数绑定&lt;br&gt;@RequestParam&lt;br&gt;@RequestBody&lt;br&gt;@RequestHeader&lt;br&gt;@PathVariable&lt;br&gt;进行了研究，同时也看了一下HttpMessageConverter的相关内容，在此一并总结。&lt;/p&gt;
&lt;p&gt;此篇文章虽然也是摘抄自网络，但是也解决了最近一来我得困惑，对这些注解的选用，同样的我也在继续的研究中!&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://jiaxiaoxuan.top/categories/Spring/"/>
    
    
      <category term="SpringMvc" scheme="http://jiaxiaoxuan.top/tags/SpringMvc/"/>
    
  </entry>
  
  <entry>
    <title>swagger注解说明</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/swagger%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/swagger注解说明/</id>
    <published>2017-09-24T09:58:04.000Z</published>
    <updated>2018-01-02T15:02:42.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用到的注解有："><a href="#常用到的注解有：" class="headerlink" title="常用到的注解有："></a>常用到的注解有：</h1><p>  ● Api<br>  ● ApiModel<br>  ● ApiModelProperty<br>  ● ApiOperation<br>  ● ApiParam<br>  ● ApiResponse<br>  ● ApiResponses<br>  ● ResponseHeader<br>  <a id="more"></a></p><h1 id="1-api标记"><a href="#1-api标记" class="headerlink" title="1. api标记"></a>1. api标记</h1><p>Api 用在类上，说明该类的作用。可以标记一个Controller类做为swagger 文档资源，使用方式：</p><pre><code>@Api(value = &quot;/user&quot;, description = &quot;Operations about user&quot;)</code></pre><p>与Controller注解并列使用。 属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>url的路径值</td></tr><tr><td>tags</td><td>如果设置这个值、value的值会被覆盖</td></tr><tr><td>description</td><td>对api资源的描述</td></tr><tr><td>basePath</td><td>基本路径可以不配置</td></tr><tr><td>position</td><td>如果配置多个Api 想改变显示的顺序位置</td></tr><tr><td>produces</td><td>For example, “application/json, application/xml”</td></tr><tr><td>consumes</td><td>For example, “application/json, application/xml”</td></tr><tr><td>protocols</td><td>Possible values: http, https, ws, wss.</td></tr><tr><td>authorizations</td><td>高级特性认证时配置</td></tr><tr><td>hidden</td><td>配置为true 将在文档中隐藏</td></tr></tbody></table><p>在SpringMvc中的配置如下：  </p><pre><code>@Controller    @RequestMapping(value = &quot;/api/pet&quot;, produces = {APPLICATION_JSON_VALUE, APPLICATION_XML_VALUE})  @Api(value = &quot;/pet&quot;, description = &quot;Operations about pets&quot;)  public class PetController {}</code></pre><h1 id="2-ApiOperation标记"><a href="#2-ApiOperation标记" class="headerlink" title="2. ApiOperation标记"></a>2. ApiOperation标记</h1><p>ApiOperation：用在方法上，说明方法的作用，每一个url资源的定义,使用方式：</p><pre><code>@ApiOperation(value = &quot;Find purchase order by ID&quot;,notes = &quot;For valid response try integer IDs with value &lt;= 5 or &gt; 10. Other values will generated exceptions&quot;,response = Order,          tags = {&quot;Pet Store&quot;})</code></pre><p>与Controller中的方法并列使用。</p><p>属性配置：  </p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>url的路径值</td></tr><tr><td>tags</td><td>如果设置这个值、value的值会被覆盖</td></tr><tr><td>description</td><td>对api资源的描述</td></tr><tr><td>basePath</td><td>基本路径可以不配置</td></tr><tr><td>position</td><td>如果配置多个Api 想改变显示的顺序位置</td></tr><tr><td>produces</td><td>For example, “application/json, application/xml”</td></tr><tr><td>consumes</td><td>For example, “application/json, application/xml”</td></tr><tr><td>protocols</td><td>Possible values: http, https, ws, wss.</td></tr><tr><td>authorizations</td><td>高级特性认证时配置</td></tr><tr><td>hidden</td><td>配置为true 将在文档中隐藏</td></tr><tr><td>response</td><td>返回的对象</td></tr><tr><td>responseContainer</td><td>这些对象是有效的 “List”, “Set” or “Map”.，其他无效</td></tr><tr><td>httpMethod</td><td>“GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH”</td></tr><tr><td>code</td><td>http的状态码 默认 200</td></tr><tr><td>extensions</td><td>扩展属性</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><pre><code>@RequestMapping(value = &quot;/order/{orderId}&quot;, method = GET)@ApiOperation(    value = &quot;Find purchase order by ID&quot;,    notes = &quot;For valid response try integer IDs with value &lt;= 5 or &gt; 10. Other values will generated exceptions&quot;,    response = Order.class,    tags = { &quot;Pet Store&quot; })    public ResponseEntity getOrderById(@PathVariable(&quot;orderId&quot;) String orderId)      throws NotFoundException {    Order order = storeData.get(Long.valueOf(orderId));    if (null != order) {    return ok(order);        } else {    throw new NotFoundException(404, &quot;Order not found&quot;);    }}</code></pre><h1 id="3-ApiParam标记"><a href="#3-ApiParam标记" class="headerlink" title="3. ApiParam标记"></a>3. ApiParam标记</h1><p>ApiParam请求属性,使用方式：  </p><pre><code>public ResponseEntity createUser(@RequestBody @ApiParam(value = &quot;Created user object&quot;, required = true)  User user)</code></pre><p>与Controller中的方法并列使用。</p><p>属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>name</td><td>属性名称</td></tr><tr><td>value</td><td>属性值</td></tr><tr><td>defaultValue</td><td>默认属性值</td></tr><tr><td>allowableValues</td><td>可以不配置</td></tr><tr><td>required</td><td>是否属性必填</td></tr><tr><td>access</td><td>不过多描述</td></tr><tr><td>allowMultiple</td><td>默认为false</td></tr><tr><td>hidden</td><td>隐藏该属性</td></tr><tr><td>example</td><td>举例子</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><pre><code>public ResponseEntity getOrderById(@ApiParam(value = &quot;ID of pet that needs to be fetched&quot;, allowableValues = &quot;range[1,5]&quot;, required = true)@PathVariable(&quot;orderId&quot;) String orderId)</code></pre><h1 id="4-ApiResponse"><a href="#4-ApiResponse" class="headerlink" title="4. ApiResponse"></a>4. ApiResponse</h1><p>ApiResponse：响应配置，使用方式：</p><pre><code>@ApiResponse(code = 400, message = &quot;Invalid user supplied&quot;)</code></pre><p>与Controller中的方法并列使用。 属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>code</td><td>http的状态码</td></tr><tr><td>message</td><td>描述</td></tr><tr><td>response</td><td>默认响应类 Void</td></tr><tr><td>reference</td><td>参考ApiOperation中配置</td></tr><tr><td>responseHeaders</td><td>参考 ResponseHeader 属性配置说明</td></tr><tr><td>responseContainer</td><td>参考ApiOperation中配置</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><pre><code>@RequestMapping(value = &quot;/order&quot;, method = POST)@ApiOperation(value = &quot;Place an order for a pet&quot;, response = Order.class)  @ApiResponses({ @ApiResponse(code = 400, message = &quot;Invalid Order&quot;) })  public ResponseEntity placeOrder(@ApiParam(value = &quot;order placed for purchasing the pet&quot;, required = true) Order order) {storeData.add(order);return ok(&quot;&quot;);}</code></pre><h1 id="5-ApiResponses"><a href="#5-ApiResponses" class="headerlink" title="5. ApiResponses"></a>5. ApiResponses</h1><p>ApiResponses：响应集配置，使用方式：</p><pre><code>@ApiResponses({ @ApiResponse(code = 400, message = &quot;Invalid Order&quot;) })</code></pre><p>与Controller中的方法并列使用。 属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>value</td><td>多个ApiResponse配置</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/order&quot;, method = POST)   </span><br><span class="line">@ApiOperation(value = &quot;Place an order for a pet&quot;, response = Order.class)</span><br><span class="line">@ApiResponses(&#123; @ApiResponse(code = 400, message = &quot;Invalid Order&quot;) &#125;)  </span><br><span class="line">public ResponseEntity placeOrder(</span><br><span class="line">@ApiParam(value = &quot;order placed for purchasing the pet&quot;, required = true) Order order) &#123;</span><br><span class="line">storeData.add(order);</span><br><span class="line">return ok(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-ResponseHeader"><a href="#6-ResponseHeader" class="headerlink" title="6. ResponseHeader"></a>6. ResponseHeader</h1><p>响应头设置，使用方法</p><pre><code>@ResponseHeader(name=&quot;head1&quot;,description=&quot;response head conf&quot;)</code></pre><p>与Controller中的方法并列使用。 属性配置：</p><table><thead><tr><th>属性名称</th><th>备注</th></tr></thead><tbody><tr><td>name</td><td>响应头名称</td></tr><tr><td>description</td><td>头描述</td></tr><tr><td>response</td><td>默认响应类 Void</td></tr><tr><td>responseContainer</td><td>参考ApiOperation中配置</td></tr></tbody></table><p>在SpringMvc中的配置如下：</p><pre><code>@ApiModel(description = &quot;群组&quot;)</code></pre><h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h1><p>● @ApiImplicitParams：用在方法上包含一组参数说明；<br>● @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面</p><pre><code>○ paramType：参数放在哪个地方  ○ name：参数代表的含义  ○ value：参数名称  ○ dataType： 参数类型，有String/int，无用  ○ required ： 是否必要  ○ defaultValue：参数的默认值  </code></pre><p>● @ApiResponses：用于表示一组响应；<br>● @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息；</p><pre><code>○ code： 响应码(int型)，可自定义  ○ message：状态码对应的响应信息  </code></pre><p>● @ApiModel：描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候；<br>● @ApiModelProperty：描述一个model的属性。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用到的注解有：&quot;&gt;&lt;a href=&quot;#常用到的注解有：&quot; class=&quot;headerlink&quot; title=&quot;常用到的注解有：&quot;&gt;&lt;/a&gt;常用到的注解有：&lt;/h1&gt;&lt;p&gt;  ● Api&lt;br&gt;  ● ApiModel&lt;br&gt;  ● ApiModelProperty&lt;br&gt;  ● ApiOperation&lt;br&gt;  ● ApiParam&lt;br&gt;  ● ApiResponse&lt;br&gt;  ● ApiResponses&lt;br&gt;  ● ResponseHeader&lt;br&gt;
    
    </summary>
    
      <category term="swagger" scheme="http://jiaxiaoxuan.top/categories/swagger/"/>
    
    
      <category term="swagger" scheme="http://jiaxiaoxuan.top/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>swagger简明教程</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/swagger%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/swagger简明教程/</id>
    <published>2017-09-24T09:24:09.000Z</published>
    <updated>2018-01-02T15:02:41.961Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://my.oschina.net/dlam/blog/808315" target="_blank" rel="noopener">https://my.oschina.net/dlam/blog/808315</a>  </p><h1 id="1：认识Swagger"><a href="#1：认识Swagger" class="headerlink" title="1：认识Swagger"></a>1：认识Swagger</h1><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。<br> 作用：  </p><pre><code>1. 接口的文档在线自动生成。  2. 功能测试。  </code></pre><p>Swagger是一组开源项目，其中主要要项目如下：  </p><a id="more"></a><ol><li>Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。  </li><li>Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。  </li><li>Swagger-js: 用于JavaScript的Swagger实现。  </li><li>Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。  </li><li>Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。  </li><li>Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。  </li></ol><h1 id="2：Maven-配置"><a href="#2：Maven-配置" class="headerlink" title="2：Maven 配置"></a>2：Maven 配置</h1><p>版本号请根据实际情况自行更改。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt; 2.2.2&lt;/version&gt;&lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;io.springfox &lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt; 2.2.2 &lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="3：创建Swagger2配置类"><a href="#3：创建Swagger2配置类" class="headerlink" title="3：创建Swagger2配置类"></a>3：创建Swagger2配置类</h1><p>在Application.java同级创建Swagger2的配置类Swagger2    </p><pre><code>package com.swaggerTest;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Swagger2配置类 * 在与spring boot集成时，放在与Application.java同级的目录下。 * 通过@Configuration注解，让Spring来加载该类配置。 * 再通过@EnableSwagger2注解来启用Swagger2。 */@Configuration@EnableSwagger2public class Swagger2 {    /**     * 创建API应用     * apiInfo() 增加API相关信息     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，     * 本例采用指定扫描的包路径来定义指定要建立API的目录。     *      * @return     */    @Bean    public Docket createRestApi() {        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.swaggerTest.controller&quot;))                .paths(PathSelectors.any())                .build();    }    /**     * 创建该API的基本信息（这些基本信息会展现在文档页面中）     * 访问地址：http://项目实际地址/swagger-ui.html     * @return     */    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)                .description(&quot;更多请关注http://www.baidu.com&quot;)                .termsOfServiceUrl(&quot;http://www.baidu.com&quot;)                .contact(&quot;sunf&quot;)                .version(&quot;1.0&quot;)                .build();    }}</code></pre><p>如上代码所示，通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。  </p><h1 id="4：添加文档内容"><a href="#4：添加文档内容" class="headerlink" title="4：添加文档内容"></a>4：添加文档内容</h1><p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，描述的主要来源是函数的命名，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。<br>Swagger使用的注解及其说明：<br>@Api：用在类上，说明该类的作用。<br>@ApiOperation：注解来给API增加方法说明。<br>@ApiImplicitParams : 用在方法上包含一组参数说明。<br>@ApiImplicitParam：用来注解来给方法入参增加说明。<br>@ApiResponses：用于表示一组响应<br>@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息<br>l   code：数字，例如400<br>l   message：信息，例如”请求参数没填好”<br>l   response：抛出异常的类<br>@ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）<br>l   @ApiModelProperty：描述一个model的属性  </p><p>==注意：@ApiImplicitParam的参数说明：==   </p><pre><code>paramType：指定参数放在哪个地方   header：请求参数放置于Request Header，使用@RequestHeader获取  query：请求参数放置于请求地址，使用@RequestParam获取  path：（用于restful接口）--&gt;请求参数的获取：@PathVariablebody：（不常用）    form（不常用）  name：参数名   dataType：参数类型   required：参数是否必须传 true | false  value：说明参数的意思   defaultValue：参数的默认值 </code></pre><p>例子：</p><pre><code>package com.swaggerTest.controller;import org.springframework.stereotype.Controller;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;/** * 一个用来测试swagger注解的控制器 * 注意@ApiImplicitParam的使用会影响程序运行，如果使用不当可能造成控制器收不到消息 *  * @author SUNF */@Controller@RequestMapping(&quot;/say&quot;)@Api(value = &quot;SayController|一个用来测试swagger注解的控制器&quot;)public class SayController {    @ResponseBody    @RequestMapping(value =&quot;/getUserName&quot;, method= RequestMethod.GET)    @ApiOperation(value=&quot;根据用户编号获取用户姓名&quot;, notes=&quot;test: 仅1和2有正确返回&quot;)    @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;userNumber&quot;, value = &quot;用户编号&quot;, required = true, dataType = &quot;Integer&quot;)    public String getUserName(@RequestParam Integer userNumber){        if(userNumber == 1){            return &quot;张三丰&quot;;        }        else if(userNumber == 2){            return &quot;慕容复&quot;;        }        else{            return &quot;未知&quot;;        }    }    @ResponseBody    @RequestMapping(&quot;/updatePassword&quot;)    @ApiOperation(value=&quot;修改用户密码&quot;, notes=&quot;根据用户id修改密码&quot;)    @ApiImplicitParams({        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;userId&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;),        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;password&quot;, value = &quot;旧密码&quot;, required = true, dataType = &quot;String&quot;),        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;newPassword&quot;, value = &quot;新密码&quot;, required = true, dataType = &quot;String&quot;)    })    public String updatePassword(@RequestParam(value=&quot;userId&quot;) Integer userId, @RequestParam(value=&quot;password&quot;) String password,             @RequestParam(value=&quot;newPassword&quot;) String newPassword){      if(userId &lt;= 0 || userId &gt; 2){          return &quot;未知的用户&quot;;      }      if(StringUtils.isEmpty(password) || StringUtils.isEmpty(newPassword)){          return &quot;密码不能为空&quot;;      }      if(password.equals(newPassword)){          return &quot;新旧密码不能相同&quot;;      }      return &quot;密码修改成功!&quot;;    }}</code></pre><p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a><br><img src="/images/swagger1.png" alt="image"><br>如上图，可以看到暴漏出来的控制器信息，点击进入可以看到详细信息。<br><img src="/images/swagger2.png" alt="image"><br>两个注意点：<br><strong>1.  paramType会直接影响程序的运行期，如果paramType与方法参数获取使用的注解不一致，会直接影响到参数的接收。</strong><br>例如：<br><img src="/images/swagger3.png" alt="image"><br>使用Sawgger UI进行测试，接收不到！<br><img src="/images/swagger4.png" alt="image"><br><strong>2.  还有一个需要注意的地方：</strong><br>Conntroller中定义的方法必须在@RequestMapper中显示的指定RequestMethod类型，否则SawggerUi会默认为全类型皆可访问， API列表中会生成多条项目。<br><img src="/images/swagger5.png" alt="image"><br>如上图：updatePassword()未指定requestMethod，结果生成了7条API信息。所以如果没有特殊需求，建议根据实际情况加上requestMethod。<br><img src="/images/swagger6.png" alt="image"> </p><h1 id="5：Swagger-UI面板说明"><a href="#5：Swagger-UI面板说明" class="headerlink" title="5：Swagger UI面板说明"></a>5：Swagger UI面板说明</h1><p><img src="/images/swagger7.png" alt="image"> </p><h1 id="6：参考"><a href="#6：参考" class="headerlink" title="6：参考"></a>6：参考</h1><p><a href="http://blog.didispace.com/springbootswagger2/" target="_blank" rel="noopener">http://blog.didispace.com/springbootswagger2/</a><br><a href="http://blog.csdn.net/jia20003/article/details/50700736" target="_blank" rel="noopener">http://blog.csdn.net/jia20003/article/details/50700736</a><br>Swagger官网 ：<a href="http://swagger.io/" target="_blank" rel="noopener">http://swagger.io/</a><br>Spring Boot &amp; Swagger UI ： <a href="http://fruzenshtein.com/spring-boot-swagger-ui/" target="_blank" rel="noopener">http://fruzenshtein.com/spring-boot-swagger-ui/</a></p><h2 id="Github：https-github-com-swagger-api-swagger-core-wiki-Annotations"><a href="#Github：https-github-com-swagger-api-swagger-core-wiki-Annotations" class="headerlink" title="Github：https://github.com/swagger-api/swagger-core/wiki/Annotations"></a>Github：<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-core/wiki/Annotations</a></h2><h1 id="7：接收对象传参的例子"><a href="#7：接收对象传参的例子" class="headerlink" title="7：接收对象传参的例子"></a>7：接收对象传参的例子</h1><p>在POJO上增加<br>    package com.zhongying.api.model.base;</p><pre><code>import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * 医生对象模型，不要使用该类 * @author SUNF * */@ApiModel(value=&quot;医生对象模型&quot;)public class DemoDoctor{    @ApiModelProperty(value=&quot;id&quot; ,required=true)    private Integer id;    @ApiModelProperty(value=&quot;医生姓名&quot; ,required=true)    private String name;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public String toString() {        return &quot;DemoDoctor [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;    }}</code></pre><p>==注意： 在后台采用对象接收参数时，Swagger自带的工具采用的是JSON传参，    测试时需要在参数上加入@RequestBody,正常运行采用form或URL提交时候请删除。==   </p><pre><code>package com.zhongying.api.controller.app;import java.util.ArrayList;import java.util.List;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.github.pagehelper.PageInfo;import com.zhongying.api.exception.HttpStatus401Exception;import com.zhongying.api.model.base.DemoDoctor;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;/** * 医生类（模拟） * @author SUNF */@RequestMapping(&quot;/api/v1&quot;)@Controller@Api(value = &quot;DoctorTestController-医生信息接口模拟&quot;)public class DoctorTestController {    /**     * 添加医生     *      * 在使用对象封装参数进行传参时，需要在该对象添加注解，将其注册到swagger中     * @link com.zhongying.api.model.base.DemoDoctor     *      * 注意： 在后台采用对象接收参数时，Swagger自带的工具采用的是JSON传参，     *     测试时需要在参数上加入@RequestBody,正常运行采用form或URL提交时候请删除。     *          * @param doctor 医生类对象     * @return     * @throws Exception     */    @ResponseBody    @RequestMapping(value=&quot;/doctor&quot;,  method= RequestMethod.POST )    @ApiOperation(value=&quot;添加医生信息&quot;, notes=&quot;&quot;)    public String addDoctor(@RequestBody DemoDoctor doctor) throws Exception{        if(null == doctor || doctor.getId() == null){            throw new HttpStatus401Exception(&quot;添加医生失败&quot;,&quot;DT3388&quot;,&quot;未知原因&quot;,&quot;请联系管理员&quot;);        }        try {          System.out.println(&quot;成功-----------&gt;&quot;+doctor.getName());          } catch (Exception e) {            throw new HttpStatus401Exception(&quot;添加医生失败&quot;,&quot;DT3388&quot;,&quot;未知原因&quot;,&quot;请联系管理员&quot;);        }        return doctor.getId().toString();    }    /**     * 删除医生     * @param doctorId 医生ID     * @return     */    @ResponseBody    @RequestMapping(value=&quot;/doctor/{doctorId}&quot;,  method= RequestMethod.DELETE )    @ApiOperation(value=&quot;删除医生信息&quot;, notes=&quot;&quot;)    @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;doctorId&quot;, value = &quot;医生ID&quot;, required = true, dataType = &quot;Integer&quot;)    public String deleteDoctor(@RequestParam Integer doctorId){        if(doctorId &gt; 2){            return &quot;删除失败&quot;;        }        return &quot;删除成功&quot;;    }    /**     * 修改医生信息     * @param doctorId 医生ID     * @param doctor 医生信息     * @return     * @throws HttpStatus401Exception     */    @ResponseBody    @RequestMapping(value=&quot;/doctor/{doctorId}&quot;,  method= RequestMethod.POST )    @ApiOperation(value=&quot;修改医生信息&quot;, notes=&quot;&quot;)    @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;doctorId&quot;, value = &quot;医生ID&quot;, required = true, dataType = &quot;Integer&quot;)    public String updateDoctor(@RequestParam Integer doctorId, @RequestBody DemoDoctor doctor) throws HttpStatus401Exception{        if(null == doctorId || null == doctor){            throw new HttpStatus401Exception(&quot;修改医生信息失败&quot;,&quot;DT3391&quot;,&quot;id不能为空&quot;,&quot;请修改&quot;);        }        if(doctorId &gt; 5 ){            throw new HttpStatus401Exception(&quot;医生不存在&quot;,&quot;DT3392&quot;,&quot;错误的ID&quot;,&quot;请更换ID&quot;);        }        System.out.println(doctorId);        System.out.println(doctor);        return &quot;修改成功&quot;;    }    /**     * 获取医生详细信息     * @param doctorId 医生ID     * @return     * @throws HttpStatus401Exception     */    @ResponseBody    @RequestMapping(value=&quot;/doctor/{doctorId}&quot;,  method= RequestMethod.GET )    @ApiOperation(value=&quot;获取医生详细信息&quot;, notes=&quot;仅返回姓名..&quot;)    @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;doctorId&quot;, value = &quot;医生ID&quot;, required = true, dataType = &quot;Integer&quot;)    public DemoDoctor getDoctorDetail(@RequestParam Integer doctorId) throws HttpStatus401Exception{        System.out.println(doctorId);        if(null == doctorId){            throw new HttpStatus401Exception(&quot;查看医生信息失败&quot;,&quot;DT3390&quot;,&quot;未知原因&quot;,&quot;请联系管理员&quot;);        }        if(doctorId &gt; 3){            throw new HttpStatus401Exception(&quot;医生不存在&quot;,&quot;DT3392&quot;,&quot;错误的ID&quot;,&quot;请更换ID&quot;);        }        DemoDoctor doctor = new DemoDoctor();        doctor.setId(1);        doctor.setName(&quot;测试员&quot;);        return doctor;    }    /**     * 获取医生列表     * @param pageIndex 当前页数     * @param pageSize 每页记录数     * @param request     * @return     * @throws HttpStatus401Exception     */    @ResponseBody    @RequestMapping(value=&quot;/doctor&quot;,  method= RequestMethod.GET )    @ApiOperation(value=&quot;获取医生列表&quot;, notes=&quot;目前一次全部取，不分页&quot;)    @ApiImplicitParams({        @ApiImplicitParam(paramType=&quot;header&quot;, name = &quot;token&quot;, value = &quot;token&quot;, required = true, dataType = &quot;String&quot;),        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;pageIndex&quot;, value = &quot;当前页数&quot;, required = false, dataType = &quot;String&quot;),        @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;pageSize&quot;, value = &quot;每页记录数&quot;, required = true, dataType = &quot;String&quot;),    })    public PageInfo&lt;DemoDoctor&gt; getDoctorList(@RequestParam(value = &quot;pageIndex&quot;, required = false, defaultValue = &quot;1&quot;) Integer pageIndex,            @RequestParam(value = &quot;pageSize&quot;, required = false) Integer pageSize,            HttpServletRequest request) throws HttpStatus401Exception{        String token = request.getHeader(&quot;token&quot;);        if(null == token){            throw new HttpStatus401Exception(&quot;没有权限&quot;,&quot;SS8888&quot;,&quot;没有权限&quot;,&quot;请查看操作文档&quot;);        }        if(null == pageSize){            throw new HttpStatus401Exception(&quot;每页记录数不粗安在&quot;,&quot;DT3399&quot;,&quot;不存在pageSize&quot;,&quot;请查看操作文档&quot;);        }        DemoDoctor doctor1 = new DemoDoctor();        doctor1.setId(1);        doctor1.setName(&quot;测试员1&quot;);        DemoDoctor doctor2 = new DemoDoctor();        doctor2.setId(2);        doctor2.setName(&quot;测试员2&quot;);        List&lt;DemoDoctor&gt; doctorList = new ArrayList&lt;DemoDoctor&gt;();        doctorList.add(doctor1);        doctorList.add(doctor2);        return new PageInfo&lt;DemoDoctor&gt;(doctorList);    }}</code></pre><p>增加header:<br>现在很多请求需要在header增加额外参数，可以参考getDoctorList()的做法，使用request接收。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://my.oschina.net/dlam/blog/808315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.oschina.net/dlam/blog/808315&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;1：认识Swagger&quot;&gt;&lt;a href=&quot;#1：认识Swagger&quot; class=&quot;headerlink&quot; title=&quot;1：认识Swagger&quot;&gt;&lt;/a&gt;1：认识Swagger&lt;/h1&gt;&lt;p&gt;Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。&lt;br&gt; 作用：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 接口的文档在线自动生成。  
2. 功能测试。  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Swagger是一组开源项目，其中主要要项目如下：  &lt;/p&gt;
    
    </summary>
    
      <category term="swagger" scheme="http://jiaxiaoxuan.top/categories/swagger/"/>
    
    
      <category term="swagger" scheme="http://jiaxiaoxuan.top/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>maven详细介绍</title>
    <link href="http://jiaxiaoxuan.top/2017/09/24/maven%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jiaxiaoxuan.top/2017/09/24/maven详细介绍/</id>
    <published>2017-09-24T08:36:11.000Z</published>
    <updated>2018-01-02T15:02:41.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;maven的用途、核心概念(Pom、Repositories、Artifact、Build Lifecycle、Goal)节点介绍、用法（Archetype意义及创建各种项目）、maven常用参数和命令以及简单故障排除、maven扩展（eclipse、cobertura、findbugs、插件开发）、maven配置。  </p><p>本文较长，可根据个人需要有选择性的查看，比如先看用法再回过头来看核心概念。  </p><a id="more"></a><h1 id="1、maven的用途"><a href="#1、maven的用途" class="headerlink" title="1、maven的用途"></a>1、maven的用途</h1><pre><code>1.maven是一个项目构建和管理的工具，提供了帮助管理构建、文档、报告、依赖、scms、发布、分发的方法。    2.可以方便的编译代码、进行依赖管理、管理二进制库等等。  3.maven的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性  4.利用maven自身及其插件还可以获得代码检查报告、单元测试覆盖率、实现持续集成等等。</code></pre><h1 id="2、maven的核心概念介绍"><a href="#2、maven的核心概念介绍" class="headerlink" title="2、maven的核心概念介绍"></a>2、maven的核心概念介绍</h1><h2 id="2-1-Pom"><a href="#2-1-Pom" class="headerlink" title="2.1 Pom"></a>2.1 Pom</h2><p>1.pom是指project object&nbsp;Model(项目对象文档模型)。pom是一个xml，在maven2为pom.xml。是maven工作的基础，在执行task或者goal时，maven会去项目根目录下读取pom.xml获得需要的配置信息。 </p><p>2.pom文件中包含了项目的信息和mave&nbsp;build项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和goal、build选项等等pom是可以继承的，通常对于一个大型的项目或是多个module的情况，子模块的pom需要指定父模块的pom。</p><pre><code>pom文件中节点解释如下：1. project pom文件的顶级元素  2. modelVersion 所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。除非maven开发者升级模板，否则不需要修改    3. groupId 是项目创建团体或组织的唯一标志符，通常是域名倒写，如groupId  org.apache.maven.plugins就是为所有maven插件预留的  4. artifactId 是项目artifact唯一的基地址名  5. packaging artifact打包的方式，如jar、war、ear等等。默认为jar。这个不仅表示项目最终产生何种后缀的文件，也表示build过程使用什么样的.6. version artifact的版本，通常能看见为类似0.0.1-SNAPSHOT，其中SNAPSHOT表示项目开发中，为开发版本  7. name 表示项目的展现名，在maven生成的文档中使用  8. url表示项目的地址，在maven生成的文档中使用  9. description 表示项目的描述，在maven生成的文档中使用  10. dependencies表示依赖，在子节点dependencies中添加具体依赖的groupId artifactId和version  11. build 表示build配置  12. parent 表示父pom  </code></pre><p>==其中groupId:artifactId:version唯一确定了一个artifact==</p><h2 id="2-2-Artifact"><a href="#2-2-Artifact" class="headerlink" title="2.2 Artifact"></a>2.2 Artifact</h2><p>这个有点不好解释，大致说就是一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId:artifactId:version组成的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(见Repository)中   </p><h2 id="2-3-Repositories"><a href="#2-3-Repositories" class="headerlink" title="2.3 Repositories"></a>2.3 Repositories</h2><ol><li>Repositories是用来存储Artifact的。如果说我们的项目产生的Artifact是一个个小工具，那么Repositories就是一个仓库，里面有我们自己创建的工具，也可以储存别人创建的工具，我们在项目中需要使用某种工具时，在pom中声明dependency，编译代码时就会根据dependency去下载工具（Artifact），供自己使用。</li><li>对于自己的项目完成后可以通过mvn&nbsp;install命令将项目放到仓库（Repositories）中。  </li><li>仓库分为本地仓库和远程仓库，远程仓库是指远程服务器上用于存储Artifact的仓库，本地仓库是指本机存储Artifact的仓库，对于windows机器本地仓库地址为系统用户的.m2/repository下面。对于需要的依赖，在pom中添加dependency即可，可以在maven的仓库中搜索：<a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a><h2 id="2-4-Build-Lifecycle"><a href="#2-4-Build-Lifecycle" class="headerlink" title="2.4 Build Lifecycle"></a>2.4 Build Lifecycle</h2>是指一个项目build的过程。maven的Build&nbsp;Lifecycle分为三种，分别为default（处理项目的部署）、clean（处理项目的清理）、site（处理项目的文档生成）,Build Lifecycle是由phases构成的，下面重点介绍default Build Lifecycle几个重要的phase    </li></ol><pre><code>Xml代码1. validate 验证项目是否正确以及必须的信息是否可用  2. compile 编译源代码  3. test 测试编译后的代码，即执行单元测试代码  4. package 打包编译后的代码，在target目录下生成package文件  5. integration-test 处理package以便需要时可以部署到集成测试环境  6. verify 检验package是否有效并且达到质量标准  7. install 安装package到本地仓库，方便本地其它项目使用  8. deploy 部署，拷贝最终的package到远程仓库和替他开发这或项目共享，在集成或发布环境完成  </code></pre><p>以上的phase是有序的（注意实际两个相邻phase之间还有其他phase被省略，完整phase见lifecycle），下面一个phase的执行必须在上一个phase完成后<br>若直接以某一个phase为goal，将先执行完它之前的phase，如mvn install<br>将会先validate、compile、test、package、integration-test、verify最后再执行install phase</p><h2 id="2-5-Goal"><a href="#2-5-Goal" class="headerlink" title="2.5 Goal"></a>2.5 Goal</h2><p>goal代表一个特定任务<br>A goal represents a specific task (finer than a build phase) which contributes to the building and managing of a project.  </p><p>mvn package<br>&nbsp;&nbsp;&nbsp;表示打包的任务，通过上面的介绍我们知道，这个任务的执行会先执行package phase之前的phase<br>mvn deploy<br>&nbsp;&nbsp;&nbsp;表示部署的任务<br>mven clean install<br>&nbsp;&nbsp;&nbsp;则表示先执行clean的phase（包含其他子phase），再执行install的phase。</p><h1 id="3、maven用法"><a href="#3、maven用法" class="headerlink" title="3、maven用法"></a>3、maven用法</h1><p> 主要讲下Archetype（原型）以及几种常用项目的创建<br> maven创建项目是根据Archetype（原型）创建的。下面先介绍下Archetype</p><h2 id="3-1-Archetype"><a href="#3-1-Archetype" class="headerlink" title="3.1 Archetype"></a>3.1 Archetype</h2><ul><li><p>1.原型对于项目的作用就相当于模具对于工具的作用，我们想做一个锤子，将铁水倒入模具成型后，稍加修改就可以了。</p></li><li><p>2.类似我们可以根据项目类型的需要使用不同的Archetype创建项目。通过Archetype我们可以快速标准的创建项目。利用Archetype创建完项目后都有标准的文件夹目录结构。</p></li><li><p>3.既然Archetype相当于模具，那么当然可以自己再造模具了啊，创建Archetype。下面介绍利用maven自带的集中Archetype创建项目。创建项目的goal为mvn archetype:generate，并且指定archetypeArtifactId，其中archetypeArtifactId见maven自带的archetypeArtifactId</p></li></ul><h2 id="3-2-quick-start工程"><a href="#3-2-quick-start工程" class="headerlink" title="3.2 quick start工程"></a>3.2 quick start工程</h2><p>创建一个简单的quick start项目，指定 -DarchetypeArtifactId为maven-archetype-quickstart，如下命令</p><ol><li>mvn archetype:generate -DgroupId=com.trinea.maven.test -DartifactId=maven-quickstart -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false </li></ol><p>其中DgroupId指定groupId，DartifactId指定artifactId，DarchetypeArtifactId指定ArchetypeId，<br>DinteractiveMode表示是否使用交互模式，交互模式会让用户填写版本信息之类的，非交互模式采用默认值<br>这样我们便建好了一个简单的maven项目，目录结构如下：<br><img src="/images/maven1.jpeg" alt="image"><br>现在我们可以利用2.4的build Lifecycle进行一些操作，先命令行到工程根目录下<br>编译 mvn  compile<br>打包 mvn package，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件<br>打包并安装到本地仓库mvn  install，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。  </p><h2 id="3-3-web工程"><a href="#3-3-web工程" class="headerlink" title="3.3 web工程"></a>3.3 web工程</h2><p>创建一个简单的web项目，只需要修 -DarchetypeArtifactId为maven-archetype-webapp即可，如下命令</p><pre><code>Java代码 1. mvn archetype:generate -DgroupId=com.trinea.maven.web.test -DartifactId=maven-web -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false</code></pre><p><img src="/images/maven2.jpeg" alt="image"><br>其他：<br>src\main\resources文件夹是用来存放资源文件的，maven工程默认没有resources文件夹，如果我们需要用到类似log4j.properties这样的配置文件，就需要在src\main文件夹下新建resources文件夹，并将log4j.properties放入其中。<br>test需要用到资源文件，类似放到src\test下<br>对于apache的log4j没有log4j.properties文件或是目录错误，会报如下异常</p><pre><code>Xml代码 1. log4j:WARN No appenders could be found for logger (org.apache.commons.httpclient.HttpClient).  2. log4j:WARN Please initialize the log4j system properly.  </code></pre><h1 id="4、maven常用参数和命令"><a href="#4、maven常用参数和命令" class="headerlink" title="4、maven常用参数和命令"></a>4、maven常用参数和命令</h1><p>主要介绍maven常用参数和命令以及简单故障排除  </p><h2 id="4-1-mvn常用参数"><a href="#4-1-mvn常用参数" class="headerlink" title="4.1 mvn常用参数"></a>4.1 mvn常用参数</h2><p>mvn -e 显示详细错误<br>mvn -U 强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）<br>mvn -o 运行offline模式，不联网更新依赖<br>mvn -N仅在当前项目模块执行命令，关闭reactor<br>mvn -pl module_name在指定模块上执行命令<br>mvn -ff 在递归执行命令过程中，一旦发生错误就直接退出<br>mvn -Dxxx=yyy指定java全局属性<br>mvn -Pxxx引用profile xxx    </p><h2 id="4-2-首先是2-4-Build-Lifecycle中介绍的命令"><a href="#4-2-首先是2-4-Build-Lifecycle中介绍的命令" class="headerlink" title="4.2 首先是2.4 Build Lifecycle中介绍的命令"></a>4.2 首先是2.4 Build Lifecycle中介绍的命令</h2><p>mvn test-compile 编译测试代码<br>mvn test 运行程序中的单元测试<br>mvn  compile 编译项目<br>mvn package 打包，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件<br>mvn install 打包并安装到本地仓库，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。<br>每个phase都可以作为goal，也可以联合，如之前介绍的mvn clean install  </p><h2 id="4-3-maven-日用三板斧"><a href="#4-3-maven-日用三板斧" class="headerlink" title="4.3 maven 日用三板斧"></a>4.3 maven 日用三板斧</h2><p>mvn archetype:generate 创建maven项目<br>mvn package 打包，上面已经介绍过了<br>mvn package -Prelease打包，并生成部署用的包，比如deploy/*.tgz<br>mvn install 打包并安装到本地库<br>mvn eclipse:eclipse 生成eclipse项目文件<br>mvn eclipse:clean 清除eclipse项目文件<br>mvn site 生成项目相关信息的网站  </p><h2 id="4-4-maven插件常用参数"><a href="#4-4-maven插件常用参数" class="headerlink" title="4.4 maven插件常用参数"></a>4.4 maven插件常用参数</h2><p>mvn -Dwtpversion=2.0 指定maven版本<br>mvn -Dmaven.test.skip=true 如果命令包含了test phase，则忽略单元测试<br>mvn -DuserProp=filePath 指定用户自定义配置文件位置<br>mvn -DdownloadSources=true -Declipse.addVersionToProjectName=true   eclipse:eclipse 生成eclipse项目文件，尝试从仓库下载源代码，并且生成的项目包含模块版本（注意如果使用公用POM，上述的开关缺省已打开）  </p><h2 id="4-5-maven简单故障排除"><a href="#4-5-maven简单故障排除" class="headerlink" title="4.5 maven简单故障排除"></a>4.5 maven简单故障排除</h2><p>mvn -Dsurefire.useFile=false如果执行单元测试出错，用该命令可以在console输出失败的单元测试及相关信息<br>set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=256m   调大jvm内存和持久代，maven/jvm out of memory error<br>mvn -X maven log level设定为debug在运行<br>mvn debug 运行jpda允许remote debug<br>mvn –help 这个就不说了。。  </p><h1 id="5、maven扩展"><a href="#5、maven扩展" class="headerlink" title="5、maven扩展"></a>5、maven扩展</h1><p>maven常用插件配置和使用<br><img src="/images/maven3.png" alt="images"><br>参考资料：<br>Maven官方文档：<a href="http://maven.apache.org/guides/index.html" target="_blank" rel="noopener">http://maven.apache.org/guides/index.html</a><br>Maven权威指南：<a href="http://www.sonatype.com/books/maven-book/reference_zh/public-book.html" target="_blank" rel="noopener">http://www.sonatype.com/books/maven-book/reference_zh/public-book.html</a><br>maven安装：<a href="http://maven.apache.org/download.html" target="_blank" rel="noopener">http://maven.apache.org/download.html</a><br><a href="http://www.infoq.com/cn/search.action?queryString=maven%E5%AE%9E%E6%88%98&amp;searchOrder=relevance&amp;search=maven%E5%AE%9E%E6%88%98" target="_blank" rel="noopener">http://www.infoq.com/cn/search.action?queryString=maven%E5%AE%9E%E6%88%98&amp;searchOrder=relevance&amp;search=maven%E5%AE%9E%E6%88%98</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot; title=&quot;摘要：&quot;&gt;&lt;/a&gt;摘要：&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;maven的用途、核心概念(Pom、Repositories、Artifact、Build Lifecycle、Goal)节点介绍、用法（Archetype意义及创建各种项目）、maven常用参数和命令以及简单故障排除、maven扩展（eclipse、cobertura、findbugs、插件开发）、maven配置。  &lt;/p&gt;
&lt;p&gt;本文较长，可根据个人需要有选择性的查看，比如先看用法再回过头来看核心概念。  &lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="http://jiaxiaoxuan.top/categories/maven/"/>
    
    
      <category term="maven" scheme="http://jiaxiaoxuan.top/tags/maven/"/>
    
  </entry>
  
</feed>
